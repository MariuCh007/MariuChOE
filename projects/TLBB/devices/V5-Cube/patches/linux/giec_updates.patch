diff --git a/arch/arm/mach-meson8b/pm.c b/arch/arm/mach-meson8b/pm.c
index 8bfa282..385c4e78 100755
--- a/arch/arm/mach-meson8b/pm.c
+++ b/arch/arm/mach-meson8b/pm.c
@@ -47,6 +47,7 @@
 static struct early_suspend early_suspend;
 static int early_suspend_flag = 0;
 #endif
+#include <linux/amlogic/aml_gpio_consumer.h>
 
 #define CONFIG_AO_TRIG_CLK 1
 #ifdef CONFIG_AO_TRIG_CLK
@@ -59,6 +60,9 @@ static int early_suspend_flag = 0;
 static unsigned int  cec_config;       // 4 bytes: use to control cec switch on/off,distinguish between Mbox and Tablet. bit[0]:1:Mbox; 0:Tablet
 static struct meson_pm_config *pdata;
 static struct device_node *cec_np = NULL;
+static unsigned int power_led_sys;
+static unsigned int power_led_wake;
+static unsigned int power_3v3_5v_en;
 
 #define CLK(addr)  \
 { \
@@ -81,7 +85,6 @@ static void uart_change_buad(unsigned reg,unsigned clk_rate){
 	aml_clr_reg32_mask(reg, 0x7FFFFF);
 	aml_set_reg32_bits(reg, (((clk_rate / (115200 * 4)) - 1) & 0x7fffff)|(1<<23), 0, 24);
 }
-
 static void wait_uart_empty(void)
 {
 	do{
@@ -106,11 +109,10 @@ void clk_switch(int flag)
 					udelay(10);
 					aml_set_reg32_mask(clks[i].clk_addr,(1<<8));//switch to pll
 					udelay(10);
-					if(!(aml_read_reg32(P_AO_UART_REG5) & (1 << 24)))//Not from crystal pad
-						uart_change_buad(P_AO_UART_REG5,uart_rate_clk);
+					uart_change_buad(P_AO_UART_REG5,uart_rate_clk);
 					clks[i].clk_flag = 0;
 				}
-			printk(KERN_INFO "clk %s(%x) on\n", clks[i].clk_name, ((clks[i].clk_addr)&0xffff)>>2);
+                	printk(KERN_INFO "clk %s(%x) on\n", clks[i].clk_name, ((clks[i].clk_addr)&0xffff)>>2);
 			}
 		}
 	} else {
@@ -124,8 +126,7 @@ void clk_switch(int flag)
 					udelay(10);
 					aml_clr_reg32_mask(clks[i].clk_addr, (1 << 7)); // switch to 24M
 					udelay(10);
-					if(!(aml_read_reg32(P_AO_UART_REG5) & (1 << 24)))//Not from crystal pad
-						uart_change_buad(P_AO_UART_REG5,uart_rate_clk);
+					uart_change_buad(P_AO_UART_REG5,uart_rate_clk);
 					clks[i].clk_flag=1;
 				}
 			}
@@ -175,7 +176,7 @@ void analog_switch(int flag)
         for (i = 0; i < ANALOG_COUNT; i++) {
             if (analog_regs[i].enable && (analog_regs[i].set_bits || analog_regs[i].clear_bits)) {
                 if (analog_regs[i].enable == 1) {
-				aml_write_reg32(analog_regs[i].reg_addr, analog_regs[i].reg_value);
+                		aml_write_reg32(analog_regs[i].reg_addr, analog_regs[i].reg_value);
                 } else if (analog_regs[i].enable == 2) {
                     aml_write_reg32(analog_regs[i].reg_addr, analog_regs[i].reg_value);
                 } else if (analog_regs[i].enable == 3) {
@@ -204,11 +205,11 @@ void analog_switch(int flag)
                     analog_regs[i].reg_value = aml_read_reg32(analog_regs[i].reg_addr);
                     printk("%s(0x%x):0x%x", analog_regs[i].name, analog_regs[i].reg_addr, analog_regs[i].reg_value);
                     if (analog_regs[i].clear_bits) {
-				aml_clr_reg32_mask(analog_regs[i].reg_addr, analog_regs[i].clear_bits);
+                    		aml_clr_reg32_mask(analog_regs[i].reg_addr, analog_regs[i].clear_bits);
                         printk(" & ~0x%x", analog_regs[i].clear_bits);
                     }
                     if (analog_regs[i].set_bits) {
-				aml_set_reg32_mask(analog_regs[i].reg_addr, analog_regs[i].set_bits);
+                    		aml_set_reg32_mask(analog_regs[i].reg_addr, analog_regs[i].set_bits);
                         printk(" | 0x%x", analog_regs[i].set_bits);
                     }
                     reg_value = aml_read_reg32(analog_regs[i].reg_addr);
@@ -243,6 +244,9 @@ static void meson_system_early_suspend(struct early_suspend *h)
 	}
 		//early_clk_switch(OFF);
 		//early_power_gate_switch(OFF);
+		if (pdata->set_vccx2) {
+			pdata->set_vccx2(OFF);
+	    }
 		early_suspend_flag = 1;
 	}
 }
@@ -253,117 +257,60 @@ static void meson_system_late_resume(struct early_suspend *h)
 		//early_power_gate_switch(ON);
 		//early_clk_switch(ON);
 		early_suspend_flag = 0;
+		if (pdata->set_vccx2) {
+			pdata->set_vccx2(ON);
+	    }
 		printk(KERN_INFO "%s\n",__func__);
 	}
 }
 #endif
 
 #ifdef CONFIG_AO_TRIG_CLK
-int run_arc_program_rtc(void)
-{
-	//int i;
-	unsigned v;
-
-	if (cec_config & 0x1)// 4 bytes: use to control cec switch on/off,distinguish between Mbox and Tablet. bit[0]:1:Mbox; 0:Tablet
-	{
-		aml_write_reg32(P_AO_REMAP_REG0,0);
-		udelay(10);
-
-		v = ((IO_SRAM_PHY_BASE & 0xFFFFF)>>12);
-#ifdef CONFIG_MESON_TRUSTZONE
-		meson_secure_reg_write(P_AO_SECURE_REG0, v<<8 | meson_secure_reg_read(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
-#else
-		aml_write_reg32(P_AO_SECURE_REG0, v<<8 | aml_read_reg32(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
-#endif
-
-		aml_write_reg32(P_AO_RTI_STATUS_REG1, 0);//clean status
-
-		//    	writel(0x200,P_AO_CPU_CNTL);//halt first
-		aml_write_reg32(P_RESET2_REGISTER, aml_read_reg32(P_RESET2_REGISTER)|(1<<13));//reset AO_CPU
-
-		udelay(10);
-
-		//      enable arc
-		aml_write_reg32(P_AO_CPU_CNTL, 0x0c900101);//remap is right?
-
-		udelay(20);
-		if (aml_read_reg32(P_AO_RTI_STATUS_REG1) == 0xeeeeaaaa) {
-			printk("AO cpu runs ok.\n");
-			return 0;
-		}
-		else{
-			printk("AO cpu runs fail. 0x%x\n",aml_read_reg32(P_AO_RTI_STATUS_REG1));
-			return -1;
-		}
-	}
-	return -1;
-}
-
 int run_arc_program(void)
 {
 //	int i;
 	unsigned vaddr2,v;
-#ifndef CONFIG_MESON_TRUSTZONE
 	unsigned* pbuffer;
-#endif
-
-#ifdef CONFIG_MESON_TRUSTZONE
-	int ret_val;
-	struct sram_hal_api_arg arg;
-
-	vaddr2 = IO_SRAM_PHY_BASE;
-#else
 	vaddr2 = IO_SRAM_BASE;
-#endif
 
 	if(cec_config & 0x1)// 4 bytes: use to control cec switch on/off,distinguish between Mbox and Tablet. bit[0]:1:Mbox; 0:Tablet
-	{
-		aml_write_reg32(P_AO_REMAP_REG0,0);
-		udelay(10);
+    {
+	aml_write_reg32(P_AO_REMAP_REG0,0);
+	udelay(10);
+	pbuffer = (unsigned*)vaddr2;
 
+	memcpy(pbuffer,arc_code,sizeof(arc_code));//need not flush cache for sram. Sram locates at io mapping.
 
-#ifdef CONFIG_MESON_TRUSTZONE
-		arg.cmd = (unsigned int)TRUSTZONE_HAL_API_SRAM_WR_ADDR;
-		arg.req_len = sizeof(arc_code);
-		arg.res_len = sizeof(arc_code);
-		arg.req_phy_addr = vaddr2;
-		arg.res_phy_addr = virt_to_phys(arc_code);
-		arg.ret_phy_addr = virt_to_phys(&ret_val);
-		meson_secure_sram_copy(&arg);
-#else
-		pbuffer = (unsigned*)vaddr2;
-		memcpy(pbuffer,arc_code,sizeof(arc_code));//need not flush cache for sram. Sram locates at io mapping.
-#endif
+//    	for(i = 0; i<sizeof(arc_code)/4; i+=4,pbuffer+=4)
+//    		printk(" 0x%x	0x%x	0x%x	0x%x \n",*(pbuffer),*(pbuffer+1),*(pbuffer+2),*(pbuffer+3));
+        v = ((IO_SRAM_PHY_BASE & 0xFFFFF)>>12);
+    #ifdef CONFIG_MESON_TRUSTZONE
+	    meson_secure_reg_write(P_AO_SECURE_REG0, v<<8 | meson_secure_reg_read(P_AO_SECURE_REG0));
+    #else
+        aml_write_reg32(P_AO_SECURE_REG0, v<<8 | aml_read_reg32(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
+    #endif
 
-		//    	for(i = 0; i<sizeof(arc_code)/4; i+=4,pbuffer+=4)
-		//    		printk(" 0x%x	0x%x	0x%x	0x%x \n",*(pbuffer),*(pbuffer+1),*(pbuffer+2),*(pbuffer+3));
-		v = ((IO_SRAM_PHY_BASE & 0xFFFFF)>>12);
-#ifdef CONFIG_MESON_TRUSTZONE
-		meson_secure_reg_write(P_AO_SECURE_REG0, v<<8 | meson_secure_reg_read(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
-#else
-		aml_write_reg32(P_AO_SECURE_REG0, v<<8 | aml_read_reg32(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
-#endif
+        aml_write_reg32(P_AO_RTI_STATUS_REG1, 0);//clean status
 
-		aml_write_reg32(P_AO_RTI_STATUS_REG1, 0);//clean status
+//    	writel(0x200,P_AO_CPU_CNTL);//halt first
+	aml_write_reg32(P_RESET2_REGISTER, aml_read_reg32(P_RESET2_REGISTER)|(1<<13));//reset AO_CPU
 
-		//    	writel(0x200,P_AO_CPU_CNTL);//halt first
-		aml_write_reg32(P_RESET2_REGISTER, aml_read_reg32(P_RESET2_REGISTER)|(1<<13));//reset AO_CPU
+	udelay(10);
 
-		udelay(10);
-		//      enable arc
-		aml_write_reg32(P_AO_CPU_CNTL, 0x0c900101);//remap is right?
+//      enable arc
+        aml_write_reg32(P_AO_CPU_CNTL, 0x0c900101);//remap is right?
 
-		udelay(20);
-		if (aml_read_reg32(P_AO_RTI_STATUS_REG1) == 0xeeeeaaaa) {
-			printk("AO cpu runs ok.\n");
-			return 0;
-		}
-		else {
-			printk("AO cpu runs fail. 0x%x\n",aml_read_reg32(P_AO_RTI_STATUS_REG1));
-			return -1;
-		}
+	udelay(20);
+	if(aml_read_reg32(P_AO_RTI_STATUS_REG1) == 0xeeeeaaaa){
+		printk("AO cpu runs ok.\n");
+		return 0;
+	}
+	else{
+		printk("AO cpu runs fail. 0x%x\n",aml_read_reg32(P_AO_RTI_STATUS_REG1));
+		return -1;
 	}
-	return -1;
+    }
+    return -1;
 }
 
 int stop_ao_cpu(void)
@@ -387,6 +334,10 @@ int stop_ao_cpu(void)
 
 extern int det_pwr_key(void);
 extern void clr_pwr_key(void);
+#ifdef CONFIG_SCREEN_ON_EARLY
+int power_key_pressed;
+EXPORT_SYMBOL(power_key_pressed);
+#endif
 
 static void meson_pm_suspend(void)
 {
@@ -466,6 +417,12 @@ static void meson_pm_suspend(void)
 #ifdef CONFIG_AO_TRIG_CLK
 	run_arc_program();
 #endif
+
+	#ifdef CONFIG_SCREEN_ON_EARLY
+    if (READ_AOBUS_REG(AO_RTI_STATUS_REG2) == FLAG_WAKEUP_PWRKEY) {
+        power_key_pressed = 1;
+    }
+	#endif
 }
 
 static int meson_pm_prepare(void)
@@ -504,12 +461,19 @@ static void m6ref_set_vccx2(int power_on)
 {
     if(power_on == OFF) {
         printk("m6ref_set_vccx2: OFF");
-        CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<15);
-        SET_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<31);
+        //CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<15);
+        //SET_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<31);
+		//amlogic_gpio_direction_output(power_led_sys, 1, "POWER_LED_SYS");
+		//amlogic_gpio_direction_output(power_led_wake, 1, "POWER_LED_WAKE");
+        amlogic_gpio_direction_output(power_3v3_5v_en, 1, "POWER_3V3_5V_EN");
     } else {
         printk("m6ref_set_vccx2: ON");
-        CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<15);
-        CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<31);
+        //CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<15);
+        //CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<31);
+		//amlogic_gpio_direction_output(power_led_sys, 0, "POWER_LED_SYS");
+		aml_clr_reg32_mask(P_AO_RTI_PIN_MUX_REG, ((1<<31)|(1<<13)|(1<<3))); //Giec wuxutao 20151208 added for suspend led breath
+		amlogic_gpio_direction_output(power_led_wake, 0, "POWER_LED_WAKE");
+        amlogic_gpio_direction_output(power_3v3_5v_en, 0, "POWER_3V3_5V_EN");
     }
     return;
 }
@@ -542,6 +506,16 @@ static int __init meson_pm_probe(struct platform_device *pdev)
 	}
 	suspend_set_ops(&meson_pm_ops);
 
+	//set gpioy_10 as gpio
+	power_led_sys= amlogic_gpio_name_map_num("GPIOAO_13");
+	amlogic_gpio_request(power_led_sys, "POWER_LED_SYS");
+	//set gpioy_11 as gpio
+	power_led_wake= amlogic_gpio_name_map_num("GPIOAO_2");
+	amlogic_gpio_request(power_led_wake, "POWER_LED_WAKE");
+    //set gpiodv_29 as gpio
+    power_3v3_5v_en = amlogic_gpio_name_map_num("GPIODV_29");
+    amlogic_gpio_request(power_3v3_5v_en, "POWER_3V3_5V_EN");
+
 	clk81 = clk_get_sys("clk81", NULL);
 	clkxtal = clk_get_sys("xtal", NULL);
 
@@ -596,3 +570,4 @@ static int __init meson_pm_init(void)
 	return platform_driver_probe(&meson_pm_driver, meson_pm_probe);
 }
 late_initcall(meson_pm_init);
+
diff --git a/drivers/amlogic/ethernet/am_net8218.c b/drivers/amlogic/ethernet/am_net8218.c
index cc8cf72..73a324d 100755
--- a/drivers/amlogic/ethernet/am_net8218.c
+++ b/drivers/amlogic/ethernet/am_net8218.c
@@ -1699,8 +1699,8 @@ static int __init mac_addr_set(char *line)
 	return 1;
 }
 
-__setup("mac=", mac_addr_set);
-
+//__setup("mac=", mac_addr_set);
+__setup("androidboot.mac=", mac_addr_set);//GIEC wuxutao 20151014 modified for bug 234  (usb boardtest)
 
 /* --------------------------------------------------------------------------*/
 /**
diff --git a/drivers/amlogic/input/new_remote/remote_func.c b/drivers/amlogic/input/new_remote/remote_func.c
index e36e272..de9d835 100755
--- a/drivers/amlogic/input/new_remote/remote_func.c
+++ b/drivers/amlogic/input/new_remote/remote_func.c
@@ -35,8 +35,6 @@ static const remotereg_t *remoteregsTab[] = {
 	RDECODEMODE_SANYO,
 	RDECODEMODE_SKIPLEADER,
 	RDECODEMODE_SW,
-	RDECODEMODE_NEC_RCA_2IN1,
-	RDECODEMODE_NEC_TOSHIBA_2IN1,
 	RDECODEMODE_SW_NEC,
 	NULL,
 	RDECODEMODE_SW_DUOKAN
@@ -45,7 +43,6 @@ extern char *remote_log_buf;
 static int auto_repeat_count,repeat_count = 0;
 static void remote_rel_timer_sr(unsigned long data);
 static void remote_repeat_sr(unsigned long data);
-static void remote_rca_repeat_sr(unsigned long data);
 static int dbg_printk(const char *fmt, ...)
 {
 	char buf[100];
@@ -60,8 +57,7 @@ static int dbg_printk(const char *fmt, ...)
 	va_end(args);
 	return 0;
 }
-int set_remote_mode(int mode)
-{
+int set_remote_mode(int mode){
 	const remotereg_t *reg;
 	reg = remoteregsTab[mode];
 	while(CONFIG_END != reg->reg)
@@ -75,14 +71,13 @@ void setremotereg(const remotereg_t *r)
 	am_remote_write_reg(r->reg, r->val);
 	printk("[0x%x] = 0x%x\n", r->reg, r->val);
 }
-void config_sw_init_window(struct remote *remote_data)
-{
-	switch(remote_data->work_mode) {
+void config_sw_init_window(struct remote *remote_data){
+	switch(remote_data->work_mode){
 		case DECODEMODE_SW_NEC:
 			remote_data->bit_count = 32;
 			remote_data->debug_enable = 1;
-			remote_data->release_delay[remote_data->map_num]  = 108;
-			remote_data->repeat_enable  = 0;
+			remote_data->release_delay = 108;
+			remote_data->repeat_enable = 0;
 			remote_data->time_window[0] = 500;
 			remote_data->time_window[1] = 700;
 			remote_data->time_window[2] = 50;
@@ -120,89 +115,41 @@ void kdb_send_key(struct input_dev *dev, unsigned int scancode,
 
 void set_remote_init(struct remote *remote_data)
 {
-	if(remote_data->work_mode <= DECODEMODE_MAX) {
-		if(remote_data->work_mode > DECODEMODE_NEC) {
-			if(remote_data->work_mode == DECODEMODE_NEC_RCA_2IN1)
-				setup_timer(&remote_data->repeat_timer, remote_rca_repeat_sr, 0);
-			else
-				setup_timer(&remote_data->repeat_timer, remote_repeat_sr, 0);
+	if(remote_data->work_mode <= DECODEMODE_MAX){
+		if(remote_data->work_mode > DECODEMODE_NEC){
+			setup_timer(&remote_data->repeat_timer, remote_repeat_sr, 0);
 			printk("enter in sw repeat mode \n");
 		}
 		return ;
 	}
 	config_sw_init_window(remote_data);
 }
-void changeduokandecodeorder(struct remote *remote_data)
-{
+void changeduokandecodeorder(struct remote *remote_data){
 	unsigned int scancode = remote_data->cur_lsbkeycode;
 	remote_data->cur_lsbkeycode =((scancode&0x3)<<18)|((scancode&0xc)<<14)|((scancode&0x30)<<10)|\
-				     ((scancode&0xc0)<<6)|((scancode&0x300)<<2)|((scancode&0xc00)>>2)|((scancode&0x3000)>>6)|\
-				     ((scancode&0xc000)>>10)|((scancode&0x30000)>>14)|((scancode&0xc0000)>>18);
+	((scancode&0xc0)<<6)|((scancode&0x300)<<2)|((scancode&0xc00)>>2)|((scancode&0x3000)>>6)|\
+	((scancode&0xc000)>>10)|((scancode&0x30000)>>14)|((scancode&0xc0000)>>18);
 	if(remote_data->cur_lsbkeycode == 0x0003cccf)
-		remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
+			remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
 }
-void get_cur_scancode(struct remote *remote_data)
-{
-	int temp_cur_lsbkeycode =0;
-	if(remote_data->work_mode== DECODEMODE_SANYO) {
+void get_cur_scancode(struct remote *remote_data){
+	if(remote_data->work_mode== DECODEMODE_SANYO){
 		remote_data->cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
 		remote_data->cur_msbkeycode = am_remote_read_reg(FRAME_BODY1)&0x2ff;
-	} else if(remote_data->work_mode ==  DECODEMODE_NEC_RCA_2IN1) {
-		if((temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY)) != 0) { //new
-			remote_data->temp_work_mode = DECODEMODE_RCA;
-			remote_data->cur_lsbkeycode = temp_cur_lsbkeycode;
-			temp_cur_lsbkeycode = 0;
-		}
-		if((am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100)>>3&0x1) && (temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY-0x100)) != 0 ) { //old
-			remote_data->temp_work_mode = DECODEMODE_NEC;
-			remote_data->cur_lsbkeycode =  temp_cur_lsbkeycode;
-			temp_cur_lsbkeycode = 0;
-		}
-	} else if(remote_data->work_mode ==  DECODEMODE_NEC_TOSHIBA_2IN1) {
-		temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
-		if(temp_cur_lsbkeycode != 0) { //new
-			remote_data->temp_work_mode = DECODEMODE_TOSHIBA;
-			remote_data->cur_lsbkeycode = temp_cur_lsbkeycode;
-			temp_cur_lsbkeycode = 0;
-		}
-		if((am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100)>>3&0x1) && (temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY-0x100)) != 0 ) { //old
-			remote_data->temp_work_mode = DECODEMODE_NEC;
-			remote_data->cur_lsbkeycode =  temp_cur_lsbkeycode;
-			temp_cur_lsbkeycode = 0;
-		}
-	} else if(remote_data->work_mode > DECODEMODE_MAX) {
+	}
+	else if(remote_data->work_mode > DECODEMODE_MAX){
 		remote_data->cur_lsbkeycode = remote_data->cur_keycode;
 		if(remote_data->work_mode == DECODEMODE_SW_DUOKAN )
 			changeduokandecodeorder(remote_data);
-	} else {
+	}
+	else{
 		remote_data->cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
 	}
 
 }
-void get_cur_scanstatus(struct remote *remote_data)
-{
-	if(remote_data->work_mode ==  DECODEMODE_NEC_RCA_2IN1) {
-		if(remote_data->temp_work_mode == DECODEMODE_RCA) {
-			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
-		}
-		if(remote_data->temp_work_mode == DECODEMODE_NEC) {
-			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100);
-
-		}
-	} else if(remote_data->work_mode ==  DECODEMODE_NEC_TOSHIBA_2IN1) {
-		if(remote_data->temp_work_mode == DECODEMODE_TOSHIBA) {
-			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
-			if(remote_data->cur_lsbkeycode == 0x1 || remote_data->cur_lsbkeycode == 0x0) {
-				remote_data->frame_status = 0x1;
-				remote_data->cur_lsbkeycode =  0x0;
-			}
+void get_cur_scanstatus(struct remote *remote_data){
 
-		}
-		if(remote_data->temp_work_mode == DECODEMODE_NEC) {
-			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100);
-		}
-	} else
-		remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
+	remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
 
 }
 /*
@@ -224,19 +171,18 @@ void get_cur_scanstatus(struct remote *remote_data)
    DECODEMODE_SANYO,
    DECODEMODE_MAX*/
 
-unsigned int COMCAST_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int COMCAST_DOMAIN(struct remote *remote_data,int domain){
 	return (remote_data->cur_keycode &0xff);
 }
 /*SANYO frame body
   Leader + 13bit Address + 13bit (~Address) + 8bit Data + 8bit (~Data)
  */
-unsigned int SANYO_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain) {
+unsigned int SANYO_DOMAIN(struct remote *remote_data,int domain){
+	if(domain){
 		remote_data->frame_mode = 0;
 		return ((remote_data->cur_lsbkeycode >>8) &0xff);
-	} else {
+	}
+	else{
 		remote_data->frame_mode = 0;
 		return (((remote_data->cur_lsbkeycode >>29) &0x7) | ((remote_data->cur_msbkeycode<<3)&0x1fff));
 	}
@@ -245,11 +191,10 @@ unsigned int SANYO_DOMAIN(struct remote *remote_data,int domain)
 
 
  */
-unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain) {
-		if(((remote_data->cur_lsbkeycode>>12)&0xfff)) {
-			switch((remote_data->cur_lsbkeycode>>20)&0xf) {
+unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain){
+	if(domain){
+		if(((remote_data->cur_lsbkeycode>>12)&0xfff)){
+			switch((remote_data->cur_lsbkeycode>>20)&0xf){
 				case 0x0://OEM mode
 					remote_data->frame_mode = 0;
 					return (remote_data->cur_lsbkeycode &0xff);
@@ -264,8 +209,9 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
 					break;
 			}
 			return (remote_data->cur_lsbkeycode &0xfffff);
-		} else {
-			switch((remote_data->cur_lsbkeycode>>10)&0x3) {
+		}
+		else{
+			switch((remote_data->cur_lsbkeycode>>10)&0x3){
 				case 0x0://OEM mode
 					remote_data->frame_mode = 0;
 					return (remote_data->cur_lsbkeycode &0xff);
@@ -281,9 +227,10 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
 			}
 			return (remote_data->cur_lsbkeycode &0xff);
 		}
-	} else {
-		if(((remote_data->cur_lsbkeycode>>12)&0xfff)) {
-			switch((remote_data->cur_lsbkeycode>>20)&0xf) {
+	}
+	else{
+		if(((remote_data->cur_lsbkeycode>>12)&0xfff)){
+			switch((remote_data->cur_lsbkeycode>>20)&0xf){
 				case 0x0://OEM mode
 					remote_data->frame_mode = 0;
 					return ((remote_data->cur_lsbkeycode>>12) &0x3f);
@@ -298,8 +245,9 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
 					break;
 			}
 			return 0;
-		} else {
-			switch((remote_data->cur_lsbkeycode>>20)&0xf) {
+		}
+		else{
+			switch((remote_data->cur_lsbkeycode>>20)&0xf){
 				case 0x0://Extended mode
 					remote_data->frame_mode = 0;
 				case 0x1://Extended Mouse mode
@@ -324,16 +272,14 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
    Carrier frequency of 38kHz
    Bit time of 1.125ms or 2.25ms
    NEC frame body
-   C15 ~ C8      C7 ~ C0    D15~D8      D7~D0
-   Header    ~Custom code   Custom code    Data Code ~Data Code
+	C15 ~ C8      C7 ~ C0    D15~D8      D7~D0
+	Header    ~Custom code   Custom code    Data Code ~Data Code
  */
-unsigned int NEC_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain) {
+unsigned int NEC_DOMAIN(struct remote *remote_data,int domain){
+	if(domain)
 		return ((remote_data->cur_lsbkeycode >>16) &0xff);//D15 ~ D8
-	} else {
+	else
 		return ((remote_data->cur_lsbkeycode) &0xffff);// C7 ~ C0
-	}
 }
 /*
    8 bit address and 8 bit command length
@@ -341,19 +287,17 @@ unsigned int NEC_DOMAIN(struct remote *remote_data,int domain)
    Carrier frequency of 38kHz
    Bit time of 1ms or 2ms
  */
-unsigned int MITSUBISHI_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int MITSUBISHI_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
 		return (remote_data->cur_keycode & 0xff);
 	else
 		return ((remote_data->cur_lsbkeycode>>8) & 0xff);
 }
-unsigned int TOSHIBA_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int TOSHIBA_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
-		return ((remote_data->cur_lsbkeycode >>16) &0xff);
+		return ((remote_data->cur_keycode >>8) &0xff);
 	else
-		return ((remote_data->cur_lsbkeycode) &0xffff);
+		return ((remote_data->cur_keycode >>16) &0xffff);
 }
 /*
    Pulse width modulation
@@ -362,15 +306,13 @@ unsigned int TOSHIBA_DOMAIN(struct remote *remote_data,int domain)
    5-bit address and 7-bit command length (12-bit protocol)
  */
 
-unsigned int SONYSIRC_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int SONYSIRC_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
 		return ((remote_data->cur_lsbkeycode>>5) &0x7f);
 	else
 		return (remote_data->cur_lsbkeycode&0x1f);
 }
-unsigned int RC5_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int RC5_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
 		return ((remote_data->cur_lsbkeycode>>5) &0x7f);
 	else
@@ -378,8 +320,7 @@ unsigned int RC5_DOMAIN(struct remote *remote_data,int domain)
 
 }
 
-unsigned int RC6_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int RC6_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
 		return ((remote_data->cur_lsbkeycode>>5) &0x7f);
 	else
@@ -387,80 +328,50 @@ unsigned int RC6_DOMAIN(struct remote *remote_data,int domain)
 
 }
 
-unsigned int RCA_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain) {
-		return ((remote_data->cur_lsbkeycode) &0xff);
-	} else {
-		return ((remote_data->cur_lsbkeycode>>8)&0xf);
-	}
-
-}
-/*DUOKAN frame body                                                         eOPERATION_CTRL_REG2dd,0x0}, // hard decode mode
-  C7 ~ C4    C3~C0      D7 ~ D4    D3~D0      P3~P0
-  Header          Custom code              Data Code      Parity Code Stop Bit  */
+/*DUOKAN frame body																　　　　　　　　　
+ C7 ~ C4    C3~C0      D7 ~ D4    D3~D0      P3~P0
+ Header          Custom code              Data Code      Parity Code Stop Bit  */
 
-unsigned int DUOKAN_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int DUOKAN_DOMAIN(struct remote *remote_data,int domain){
 	if(remote_data->cur_lsbkeycode == 0x0003cccf)// power key
-		remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
+			remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
 	if(domain)
 		return ((remote_data->cur_lsbkeycode >>4) &0xff);
 	else
 		return ((remote_data->cur_lsbkeycode >>12) &0xff);
 }
-unsigned int KDB_NEC_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int KDB_NEC_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
 		return ((remote_data->cur_lsbkeycode >>4) &0xff);
 	else
 		return ((remote_data->cur_lsbkeycode >>12) &0xff);
 }
-unsigned int KDB_DUOKAN_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int KDB_DUOKAN_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
 		return ((remote_data->cur_lsbkeycode >>4) &0xff);
 	else
 		return ((remote_data->cur_lsbkeycode >>12) &0xff);
 }
-unsigned int NULL_DUOKAN_DOMAIN(struct remote *remote_data,int domain)
-{
-	return 0;
-}
-unsigned int (*get_cur_key_domian[])(struct remote *remote_data,int domain)= {
+unsigned int (*get_cur_key_domian[])(struct remote *remote_data,int domain)={
 	NEC_DOMAIN,
 	DUOKAN_DOMAIN,
 	KDB_NEC_DOMAIN,
 	RCMM_DOMAIN,
 	COMCAST_DOMAIN,
 	MITSUBISHI_DOMAIN,
-	SONYSIRC_DOMAIN,
 	TOSHIBA_DOMAIN,
+	SONYSIRC_DOMAIN,
 	RC5_DOMAIN,
 	RC6_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	RCA_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
 	KDB_DUOKAN_DOMAIN
 };
 
-int remote_hw_reprot_null_key(struct remote *remote_data)
-{
-	input_dbg("%s,it is a null key\n",__func__);
-	get_cur_scancode(remote_data);
-	get_cur_scanstatus(remote_data);
-	return 0;
-}
-irqreturn_t remote_null_bridge_isr(int irq, void *dev_id)
-{
-	return IRQ_HANDLED;
-}
-
 int remote_hw_reprot_key(struct remote *remote_data)
 {
 	static int last_scan_code;
@@ -469,17 +380,20 @@ int remote_hw_reprot_key(struct remote *remote_data)
 	get_cur_scanstatus(remote_data);
 	if(remote_data->status)// repeat enable & come in S timer is open
 		return 0;
-	if (remote_data->cur_lsbkeycode) {  //key first press
-		if(remote_data->ig_custom_enable) {
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+	if (remote_data->cur_lsbkeycode) {	//key first press
+		if(remote_data->ig_custom_enable)
+		{
+			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);){
 				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->work_mode](remote_data,CUSTOMDOMAIN)) {
 					//return -1;
 					i++;
-				} else {
+				}
+				else{
 					remote_data->map_num = i;
 					break;
 				}
-				if(i == ARRAY_SIZE(remote_data->custom_code)) {
+				if(i == ARRAY_SIZE(remote_data->custom_code))
+				{
 					input_dbg("Wrong custom code is 0x%08x\n", remote_data->cur_lsbkeycode);
 					return -1;
 				}
@@ -493,220 +407,49 @@ int remote_hw_reprot_key(struct remote *remote_data)
 		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN), 1,0);
 		remote_data->repeat_release_code = get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN);
 		remote_data->enable_repeat_falg = 1;
-		if((remote_data->work_mode > DECODEMODE_NEC) && remote_data->enable_repeat_falg) {
+		if((remote_data->work_mode > DECODEMODE_NEC) && remote_data->enable_repeat_falg){
 			if (remote_data->repeat_enable) {
 				remote_data->repeat_timer.data = (unsigned long)remote_data;
 				//here repeat  delay is time interval from the first frame end to first repeat end.
 				remote_data->repeat_tick = jiffies;
-				mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num]));
+				mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_delay));
 				remote_data->status = TIMER;
-			} else {
-				setup_timer(&remote_data->rel_timer, remote_rel_timer_sr, 0);
-				mod_timer(&remote_data->timer,  jiffies );
-				remote_data->rel_timer.data = (unsigned long)remote_data;
-				mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay[remote_data->map_num]));
-				remote_data->status = TIMER;
-			}
-		}
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
-			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
-				remote_data->want_repeat_enable = 1;
-			} else {
-				remote_data->want_repeat_enable = 0;
-			}
-		}
-
-		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
-			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num]);
-		}
-		if(remote_data->repeat_enable)
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-		else
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
-#ifdef CONFIG_AML_HDMI_TX
-		extern int rc_long_press_pwr_key;
-		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
-			rc_long_press_pwr_key = 1;
-			cec_repeat = 10;
-		}
-		if(remote_data->repeat_release_code == 0x1a)
-			cec_repeat--;
-
-#endif
-		if (remote_data->repeat_enable) {
-			repeat_count++;
-			if (remote_data->repeat_tick < jiffies) {
-				if(repeat_count > 1)
-					remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-				remote_data->repeat_tick += msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num]);
 			}
-		} else {
-			if (remote_data->timer.expires > jiffies) {
-				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]));
-			}
-			return -1;
-		}
-		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]) + msecs_to_jiffies(110));
-	}
-	last_scan_code = remote_data->cur_lsbkeycode;
-	remote_data->cur_keycode = last_scan_code;
-	remote_data->cur_lsbkeycode = 0;
-	remote_data->timer.data = (unsigned long)remote_data;
-	return 0;
-}
-int remote_hw_nec_rca_2in1_reprot_key(struct remote *remote_data)
-{
-	static int last_scan_code;
-	int i;
-	get_cur_scancode(remote_data);
-	get_cur_scanstatus(remote_data);
-	if(remote_data->status)// repeat enable & come in S timer is open
-		return 0;
-	if (remote_data->cur_lsbkeycode) {      //key first press
-		if(remote_data->ig_custom_enable) {
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
-				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->temp_work_mode](remote_data,CUSTOMDOMAIN)) {
-					//return -1;
-					i++;
-				} else {
-					remote_data->map_num = i;
-					break;
-				}
-				if(i == ARRAY_SIZE(remote_data->custom_code)) {
-					input_dbg("Wrong custom code is 0x%08x,temp_work_mode is %d\n", remote_data->cur_lsbkeycode,remote_data->temp_work_mode);
-					return -1;
-				}
-			}
-		}
-		repeat_count = 0;
-		if (remote_data->timer.expires > jiffies) {
-			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code , 0,0);
-		}
-		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN), 1,0);
-		remote_data->repeat_release_code = get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN);
-		remote_data->enable_repeat_falg = 1;
-		if((remote_data->temp_work_mode  == DECODEMODE_RCA) && (remote_data->enable_repeat_falg)) {
-			if (remote_data->repeat_enable) {
-				remote_data->repeat_timer.data = (unsigned long)remote_data;
-				//here repeat  delay is time interval from the first frame end to first repeat end.
-				remote_data->repeat_tick = jiffies;
-				mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num]));
-				remote_data->status = TIMER;
-			} else {
+			else{
 				setup_timer(&remote_data->rel_timer, remote_rel_timer_sr, 0);
 				mod_timer(&remote_data->timer,  jiffies );
 				remote_data->rel_timer.data = (unsigned long)remote_data;
-				mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay[remote_data->map_num]));
+				mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay));
 				remote_data->status = TIMER;
 			}
 		}
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
+		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++){
 			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
 				remote_data->want_repeat_enable = 1;
-			} else {
-				remote_data->want_repeat_enable = 0;
-			}
-		}
-
-		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
-			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num] );
-		}
-		if(remote_data->repeat_enable)
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-		else
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
-#ifdef CONFIG_AML_HDMI_TX
-		extern int rc_long_press_pwr_key;
-		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
-			rc_long_press_pwr_key = 1;
-			cec_repeat = 10;
-		}
-		if(remote_data->repeat_release_code == 0x1a)
-			cec_repeat--;
-
-#endif
-		if (remote_data->repeat_enable) {
-			repeat_count++;
-			if (remote_data->repeat_tick < jiffies) {
-				if(repeat_count > 1)
-					remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-				remote_data->repeat_tick += msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num] );
-			}
-		} else {
-			if (remote_data->timer.expires > jiffies) {
-				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]));
-			}
-			return -1;
-		}
-		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]) + msecs_to_jiffies(110));
-	}
-	last_scan_code = remote_data->cur_lsbkeycode;
-	remote_data->cur_keycode = last_scan_code;
-	remote_data->cur_lsbkeycode = 0;
-	remote_data->timer.data = (unsigned long)remote_data;
-	return 0;
-}
-
-int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data)
-{
-	static int last_scan_code;
-	int i;
-	get_cur_scancode(remote_data);
-	get_cur_scanstatus(remote_data);
-	if (remote_data->cur_lsbkeycode) {      //key first press
-		if(remote_data->ig_custom_enable) {
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
-				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->temp_work_mode](remote_data,CUSTOMDOMAIN)) {
-					//return -1;
-					i++;
-				} else {
-					remote_data->map_num = i;
-					break;
-				}
-
-				if(i == ARRAY_SIZE(remote_data->custom_code)) {
-					input_dbg("Wrong custom code is 0x%08x,temp_work_mode is %d\n", remote_data->cur_lsbkeycode,remote_data->temp_work_mode);
-					return -1;
-				}
 			}
-		}
-		repeat_count = 0;
-		if (remote_data->timer.expires > jiffies) {
-			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code , 0,0);
-		}
-		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN), 1,0);
-		remote_data->repeat_release_code = get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN);
-		remote_data->enable_repeat_falg = 1;
-		if(remote_data->temp_work_mode  == DECODEMODE_TOSHIBA) {
-			// setting frame bit = 1;
-			am_remote_write_reg(OPERATION_CTRL_REG1,0x8000);
-		}
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
-			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
-				remote_data->want_repeat_enable = 1;
-			} else {
+			else{
 				remote_data->want_repeat_enable = 0;
 			}
 		}
 
 		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
-			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num] );
+			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->input->rep[REP_DELAY]);
 		}
 		if(remote_data->repeat_enable)
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_delay));
 		else
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_delay));
+	}
+	else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg){	//repeate key
 #ifdef CONFIG_AML_HDMI_TX
-		extern int rc_long_press_pwr_key;
+       extern int rc_long_press_pwr_key;
 		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
-			rc_long_press_pwr_key = 1;
-			cec_repeat = 10;
+            rc_long_press_pwr_key = 1;
+		    cec_repeat = 10;
+		    mdelay(20);
 		}
 		if(remote_data->repeat_release_code == 0x1a)
-			cec_repeat--;
+		    cec_repeat--;
 
 #endif
 		if (remote_data->repeat_enable) {
@@ -714,15 +457,15 @@ int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data)
 			if (remote_data->repeat_tick < jiffies) {
 				if(repeat_count > 1)
 					remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-				remote_data->repeat_tick += msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num] );
+				remote_data->repeat_tick += msecs_to_jiffies(remote_data->input->rep[REP_PERIOD]);
 			}
 		} else {
 			if (remote_data->timer.expires > jiffies) {
-				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]));
+				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay));
 			}
 			return -1;
 		}
-		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]) + msecs_to_jiffies(110));
+		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay) + msecs_to_jiffies(110));
 	}
 	last_scan_code = remote_data->cur_lsbkeycode;
 	remote_data->cur_keycode = last_scan_code;
@@ -743,16 +486,19 @@ static inline void kbd_software_mode_remote_send_key(unsigned long data)
 				msecs_to_jiffies(remote_data->input->rep[REP_PERIOD]);
 		}
 	} else {
-		if(remote_data->ig_custom_enable) {
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+		if(remote_data->ig_custom_enable)
+		{
+			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);){
 				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->work_mode](remote_data,CUSTOMDOMAIN)) {
 					//return -1;
 					i++;
-				} else {
+				}
+				else{
 					remote_data->map_num = i;
 					break;
 				}
-				if(i == ARRAY_SIZE(remote_data->custom_code)) {
+				if(i == ARRAY_SIZE(remote_data->custom_code))
+				{
 					input_dbg("Wrong custom code is 0x%08x\n", remote_data->cur_lsbkeycode);
 					return;
 				}
@@ -761,10 +507,11 @@ static inline void kbd_software_mode_remote_send_key(unsigned long data)
 		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN), 1,0);
 		remote_data->repeat_release_code = get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN);
 		remote_data->enable_repeat_falg = 1;
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
+		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++){
 			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
 				remote_data->want_repeat_enable = 1;
-			} else {
+			}
+			else{
 				remote_data->want_repeat_enable = 0;
 			}
 		}
@@ -773,52 +520,35 @@ static inline void kbd_software_mode_remote_send_key(unsigned long data)
 		}
 	}
 }
-static void remote_rca_repeat_sr(unsigned long data)
-{
-	struct remote *remote_data = (struct remote *)data;
-	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode ) {
-		repeat_count++;
-		if(repeat_count > 2)
-			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-		remote_data->cur_lsbkeycode = 0;
-		remote_data->repeat_timer.data = (unsigned long)remote_data;
-		remote_data->timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_peroid[remote_data->map_num]));
-		mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num]));
-		remote_data->status = TIMER;
-	} else {
-		remote_data->status = NORMAL;
-		remote_data->timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->timer, jiffies+msecs_to_jiffies(1));
-	}
-}
 static void remote_repeat_sr(unsigned long data)
 {
 	struct remote *remote_data = (struct remote *)data;
-	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode) {
-		auto_repeat_count++;
-		if(auto_repeat_count > 1)
-			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-		remote_data->cur_lsbkeycode = 0;
-		remote_data->repeat_timer.data = (unsigned long)remote_data;
-		remote_data->timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num]));
-		remote_data->status = TIMER;
-	} else {
-		remote_data->status = NORMAL;
-		remote_data->timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->timer, jiffies+msecs_to_jiffies(1));
+	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode){
+			auto_repeat_count++;
+			if(auto_repeat_count > 1)
+				remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
+			remote_data->cur_lsbkeycode = 0;
+			remote_data->repeat_timer.data = (unsigned long)remote_data;
+			remote_data->timer.data = (unsigned long)remote_data;
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_peroid));
+			mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_peroid));
+			remote_data->status = TIMER;
+	}else{
+			remote_data->status = NORMAL;
+			remote_data->timer.data = (unsigned long)remote_data;
+			mod_timer(&remote_data->timer, jiffies+msecs_to_jiffies(1));
 	}
 }
 static void remote_rel_timer_sr(unsigned long data)
 {
 	struct remote *remote_data = (struct remote *)data;
-	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode) {
-		remote_data->cur_lsbkeycode = 0;
-		remote_data->rel_timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay[remote_data->map_num]));
-		remote_data->status = TIMER;
-	} else
+		if(remote_data->cur_keycode == remote_data->cur_lsbkeycode){
+			remote_data->cur_lsbkeycode = 0;
+			remote_data->rel_timer.data = (unsigned long)remote_data;
+			mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay));
+			remote_data->status = TIMER;
+		}
+		else
 		remote_data->status = NORMAL;
 
 
@@ -879,51 +609,51 @@ static inline void kbd_software_mode_remote_data(struct remote *remote_data)
 	pulse_width = get_pulse_width(remote_data);
 	remote_data->step = REMOTE_STATUS_DATA;
 	switch (remote_data->work_mode) {
-		case DECODEMODE_SW_NEC:
-			if ((pulse_width > remote_data->time_window[2])
-					&& (pulse_width < remote_data->time_window[3])) {
-				remote_data->bit_num--;
-			} else if ((pulse_width > remote_data->time_window[4])
-					&& (pulse_width < remote_data->time_window[5])) {
-				remote_data->bit_num--;
-				remote_data->cur_keycode |= 1 << (remote_data->bit_count - remote_data->bit_num);
-			} else {
-				remote_data->step = REMOTE_STATUS_WAIT;
-			}
-			if (remote_data->bit_num == 0) {
-				remote_data->repeate_flag = 0;
-				remote_data->send_data = 1;
-				fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
-			}
-			break;
-		case DECODEMODE_SW_DUOKAN:
-			if ((pulse_width > remote_data->time_window[2])
-					&& (pulse_width < remote_data->time_window[3])) {
-				remote_data->bit_num -= 2;
-			} else if ((pulse_width > remote_data->time_window[4])
-					&& (pulse_width < remote_data->time_window[5])) {
-				remote_data->cur_keycode |=
-					1 << (remote_data->bit_count - remote_data->bit_num);
-				remote_data->bit_num -= 2;
-			} else if ((pulse_width > remote_data->time_window[8])
-					&& (pulse_width < remote_data->time_window[9])) {
-				remote_data->cur_keycode |=
-					2 << (remote_data->bit_count - remote_data->bit_num);
-				remote_data->bit_num -= 2;
-			} else if ((pulse_width > remote_data->time_window[10])
-					&& (pulse_width < remote_data->time_window[11])) {
-				remote_data->cur_keycode |=
-					3 << (remote_data->bit_count - remote_data->bit_num);
-				remote_data->bit_num -= 2;
-			} else {
-				remote_data->step = REMOTE_STATUS_WAIT;
-			}
-			if (remote_data->bit_num == 0) {
-				remote_data->repeate_flag = 0;
-				remote_data->send_data = 1;
-				fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
-			}
-			break;
+	case DECODEMODE_SW_NEC:
+	if ((pulse_width > remote_data->time_window[2])
+			&& (pulse_width < remote_data->time_window[3])) {
+		remote_data->bit_num--;
+	} else if ((pulse_width > remote_data->time_window[4])
+			&& (pulse_width < remote_data->time_window[5])) {
+			remote_data->bit_num--;
+			remote_data->cur_keycode |= 1 << (remote_data->bit_count - remote_data->bit_num);
+	} else {
+		remote_data->step = REMOTE_STATUS_WAIT;
+	}
+	if (remote_data->bit_num == 0) {
+		remote_data->repeate_flag = 0;
+		remote_data->send_data = 1;
+		fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
+	}
+	break;
+	case DECODEMODE_SW_DUOKAN:
+		if ((pulse_width > remote_data->time_window[2])
+		    && (pulse_width < remote_data->time_window[3])) {
+			remote_data->bit_num -= 2;
+		} else if ((pulse_width > remote_data->time_window[4])
+		           && (pulse_width < remote_data->time_window[5])) {
+			remote_data->cur_keycode |=
+			    1 << (remote_data->bit_count - remote_data->bit_num);
+			remote_data->bit_num -= 2;
+		} else if ((pulse_width > remote_data->time_window[8])
+		           && (pulse_width < remote_data->time_window[9])) {
+			remote_data->cur_keycode |=
+			    2 << (remote_data->bit_count - remote_data->bit_num);
+			remote_data->bit_num -= 2;
+		} else if ((pulse_width > remote_data->time_window[10])
+		           && (pulse_width < remote_data->time_window[11])) {
+			remote_data->cur_keycode |=
+			    3 << (remote_data->bit_count - remote_data->bit_num);
+			remote_data->bit_num -= 2;
+		} else {
+			remote_data->step = REMOTE_STATUS_WAIT;
+		}
+		if (remote_data->bit_num == 0) {
+			remote_data->repeate_flag = 0;
+			remote_data->send_data = 1;
+			fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
+		}
+		break;
 	}
 }
 
@@ -956,7 +686,7 @@ int remote_sw_reprot_key(struct remote *remote_data)
 			&& (remote_data->step <= REMOTE_STATUS_SYNC)) {
 		remote_data->step = REMOTE_STATUS_WAIT;
 	}
-	remote_data->last_jiffies = current_jiffies;    //ignore a little msecs
+	remote_data->last_jiffies = current_jiffies;	//ignore a little msecs
 	switch (remote_data->step) {
 		case REMOTE_STATUS_WAIT:
 			kbd_software_mode_remote_wait(remote_data);
@@ -980,60 +710,36 @@ irqreturn_t remote_bridge_isr(int irq, void *dev_id)
 {
 	struct remote *remote_data = (struct remote *)dev_id;
 
-	if (remote_data->send_data) {   //report key
+	if (remote_data->send_data) {	//report key
 		kbd_software_mode_remote_send_key((unsigned long)remote_data);
 		remote_data->send_data = 0;
 	}
 	remote_data->timer.data = (unsigned long)remote_data;
 	mod_timer(&remote_data->timer,
-			jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num] ));
+			jiffies + msecs_to_jiffies(remote_data->release_delay));
 	return IRQ_HANDLED;
 }
-void kdb_send_key(struct input_dev *dev, unsigned int scancode,unsigned int type,int event)
-{
+void kdb_send_key(struct input_dev *dev, unsigned int scancode,unsigned int type,int event){
 	return;
 }
-void remote_nec_report_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
+void remote_nec_report_release_key(struct remote *remote_data){
+	if(remote_data->enable_repeat_falg){
 		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
 		remote_data->enable_repeat_falg = 0;
 	}
 }
-void remote_duokan_report_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
+void remote_duokan_report_release_key(struct remote *remote_data){
+	if(remote_data->enable_repeat_falg){
 		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
 		remote_data->enable_repeat_falg = 0;
 		auto_repeat_count = 0;
 	}
 }
-void remote_sw_reprot_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
+void remote_sw_reprot_release_key(struct remote *remote_data){
+	if(remote_data->enable_repeat_falg){
 		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
 		remote_data->enable_repeat_falg = 0;
 	}
 }
-void remote_nec_rca_2in1_report_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
-		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
-		remote_data->enable_repeat_falg = 0;
-	}
-}
-void remote_nec_toshiba_2in1_report_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
-		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
-		remote_data->enable_repeat_falg = 0;
-		am_remote_write_reg(OPERATION_CTRL_REG1,0x9f40);
-
-	}
-}
 
-void remote_null_reprot_release_key(struct remote *remote_data)
-{
-
-}
 
diff --git a/drivers/amlogic/input/new_remote/remote_main.c b/drivers/amlogic/input/new_remote/remote_main.c
index e7e8495..a9b08d6 100755
--- a/drivers/amlogic/input/new_remote/remote_main.c
+++ b/drivers/amlogic/input/new_remote/remote_main.c
@@ -39,12 +39,17 @@
 #include <mach/pinmux.h>
 #include <linux/major.h>
 #include <linux/slab.h>
+#include <mach/gpio.h>
 #include <asm/uaccess.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/of_platform.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
 #include "remote_main.h"
 
+
 #undef NEW_BOARD_LEARNING_MODE
+
+//#define IR_CONTROL_HOLD_LAST_KEY    (1<<6)
 #define IR_CONTROL_DECODER_MODE     (3<<7)
 #define IR_CONTROL_SKIP_HEADER      (1<<7)
 #define IR_CONTROL_RESET            (1<<0)
@@ -71,66 +76,70 @@ static struct remote *gp_remote = NULL;
 char *remote_log_buf;
 // use 20 map for this driver
 static __u16 key_map[20][512];
-static  irqreturn_t (*remote_bridge_sw_isr[])(int irq, void *dev_id)= {
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
+static  irqreturn_t (*remote_bridge_sw_isr[])(int irq, void *dev_id)={
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
 	remote_bridge_isr,
 	remote_bridge_isr,
 };
 
-static  int (*remote_report_key[])(struct remote *remote_data)= {
+static  int (*remote_report_key[])(struct remote *remote_data)={
 	remote_hw_reprot_key,
 	remote_hw_reprot_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_nec_rca_2in1_reprot_key,
-	remote_hw_nec_toshiba_2in1_reprot_key,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
 	remote_sw_reprot_key
 };
 
-static  void (*remote_report_release_key[])(struct remote *remote_data)= {
+static  void (*remote_report_release_key[])(struct remote *remote_data)={
 	remote_nec_report_release_key,
 	remote_duokan_report_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_nec_rca_2in1_report_release_key,
-	remote_nec_toshiba_2in1_report_release_key,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
 	remote_sw_reprot_release_key
 };
 static __u16 mouse_map[20][6];
+
+static unsigned int power_led_sys;
+static unsigned int power_led_wake;
+
 int remote_printk(const char *fmt, ...)
 {
 	va_list args;
@@ -165,10 +174,10 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsi
 		return -1;
 	}
 	switch (type) {
-		case 1:     //press
+		case 1:		//press
 			repeat_count = 0;
 			break;
-		case 2:     //repeat
+		case 2:		//repeat
 			if (repeat_count >= ARRAY_SIZE(move_accelerate) - 1) {
 				repeat_count = ARRAY_SIZE(move_accelerate) - 1;
 			} else {
@@ -192,7 +201,7 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsi
 			mouse_code = REL_Y;
 			mouse_value = 1 + move_accelerate[repeat_count];
 			break;
-		case 4:     //up
+		case 4:		//up
 			mouse_code = REL_WHEEL;
 			mouse_value = 0x1;
 			break;
@@ -220,32 +229,54 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsi
 	return 0;
 }
 
-void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int type,int event)
+void led_on(void)
 {
-	printk("remote_send_key\n");
-	if(scancode == FN_KEY_SCANCODE && type == 1) {
-		// switch from key to pointer
-		if(key_pointer_switch) {
-			key_pointer_switch = false;
-			gp_remote->repeat_enable = 1;
-			gp_remote->input->rep[REP_DELAY] = gp_remote->repeat_delay[gp_remote->map_num];
-			gp_remote->input->rep[REP_PERIOD] = gp_remote->repeat_peroid[gp_remote->map_num];
-		}
-		// switch from pointer to key
-		else {
-			key_pointer_switch = true;
-			gp_remote->repeat_enable = 0;
-			gp_remote->input->rep[REP_DELAY] = 0xffffffff;
-			gp_remote->input->rep[REP_PERIOD] = 0xffffffff;
-		}
-	}
-
-	if(scancode == OK_KEY_SCANCODE && key_pointer_switch == false) {
-		input_event(dev, EV_KEY, BTN_MOUSE, type);
-		input_sync(dev);
+//	input_dbg("wml led_on\n");
+//	CLEAR_CBUS_REG_MASK(PREG_PAD_GPIO0_EN_N, (1 << 16));
+//	SET_CBUS_REG_MASK(PREG_PAD_GPIO0_O, (1 << 16));
+	amlogic_gpio_direction_output(power_led_sys, 0, "POWER_LED_SYS");
+	amlogic_gpio_direction_output(power_led_wake, 0, "POWER_LED_WAKE");
+}
 
-		return;
-	}
+void led_off(void)
+{
+//	input_dbg("wml led_off\n");
+//	CLEAR_CBUS_REG_MASK(PREG_PAD_GPIO0_EN_N, (1 << 16));
+//	CLEAR_CBUS_REG_MASK(PREG_PAD_GPIO0_O, (1 << 16));
+	amlogic_gpio_direction_output(power_led_sys, 1, "POWER_LED_SYS");
+	amlogic_gpio_direction_output(power_led_wake, 1, "POWER_LED_WAKE");
+}
+void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int type,int event)
+{
+	static int swith_led =1;
+	printk("remote_send_key \n");
+	if(scancode == FN_KEY_SCANCODE && type == 1)
+    {
+	// switch from key to pointer
+        if(key_pointer_switch)
+        {
+            key_pointer_switch = false;
+            gp_remote->repeat_enable = 1;
+            gp_remote->input->rep[REP_DELAY] = gp_remote->repeat_delay;
+            gp_remote->input->rep[REP_PERIOD] = gp_remote->repeat_peroid;
+        }
+        // switch from pointer to key
+        else
+        {
+            key_pointer_switch = true;
+            gp_remote->repeat_enable = 0;
+            gp_remote->input->rep[REP_DELAY] = 0xffffffff;
+            gp_remote->input->rep[REP_PERIOD] = 0xffffffff;
+        }
+    }
+
+    if(scancode == OK_KEY_SCANCODE && key_pointer_switch == false)
+    {
+	 input_event(dev, EV_KEY, BTN_MOUSE, type);
+		 input_sync(dev);
+
+	 return;
+     }
 
 	if (remote_mouse_event(dev, scancode, type,key_pointer_switch)) {
 		if (scancode > ARRAY_SIZE(key_map[gp_remote->map_num])) {
@@ -257,27 +288,41 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int
 			input_dbg("scancode is 0x%04x, invalid key is 0x%04x.\n", scancode, key_map[gp_remote->map_num][scancode]);
 			return;
 		}
-
-		if(type == 2 && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074) {
-			return;
-		} else {
-			input_event(dev, EV_KEY, key_map[gp_remote->map_num][scancode], type);
-			input_sync(dev);
-		}
-
+		if(type == 1 && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074){
+		    disable_irq(NEC_REMOTE_IRQ_NO);
+                }
+		if(type == 0 && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074){
+		    enable_irq(NEC_REMOTE_IRQ_NO);
+                }
+		input_event(dev, EV_KEY, key_map[gp_remote->map_num][scancode], type);
+		input_sync(dev);
 		switch (type) {
 			case 0:
 				input_dbg("release ircode = 0x%02x, scancode = 0x%04x, maptable = %d \n", scancode, key_map[gp_remote->map_num][scancode],gp_remote->map_num);
+				led_on();
+				swith_led =1;
 				break;
 			case 1:
 				input_dbg("press ircode = 0x%02x, scancode = 0x%04x, maptable = %d \n", scancode, key_map[gp_remote->map_num][scancode],gp_remote->map_num);
+				led_off();
+				swith_led =0;
 				break;
 			case 2:
 				input_dbg("repeat ircode = 0x%02x, scancode = 0x%04x, maptable = %d \n", scancode, key_map[gp_remote->map_num][scancode],gp_remote->map_num);
+				if(swith_led ==1)
+				{
+					swith_led =0;
+					led_off();
+				}
+				else
+				{
+					swith_led =1;
+					led_on();
+				}
 				break;
 		}
-		input_dbg("%s sleep:%d\n", __func__, gp_remote->sleep);
-		if(gp_remote->sleep && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074) {
+		printk("%s sleep:%d\n", __func__, gp_remote->sleep);
+		if(gp_remote->sleep && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074){
 			printk(" set AO_RTI_STATUS_REG2 0x4853ffff \n");
 			WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0x4853ffff); // tell uboot don't suspend
 		}
@@ -286,7 +331,7 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int
 
 static void disable_remote_irq(void)
 {
-	if (gp_remote->work_mode >= DECODEMODE_MAX) {
+	if (gp_remote->work_mode >= DECODEMODE_MAX){
 		disable_irq(NEC_REMOTE_IRQ_NO);
 	}
 }
@@ -299,8 +344,7 @@ static void enable_remote_irq(void)
 
 }
 
-void remote_reprot_key( struct remote * remote_data)
-{
+void remote_reprot_key( struct remote * remote_data){
 	remote_report_key[remote_data->work_mode](remote_data);
 }
 static void remote_release_timer_sr(unsigned long data)
@@ -311,14 +355,14 @@ static void remote_release_timer_sr(unsigned long data)
 	remote_data->key_release_report(remote_data);
 }
 
-static irqreturn_t remote_interrupt(int irq, void *dev_id)
-{
+static irqreturn_t remote_interrupt(int irq, void *dev_id){
 	tasklet_schedule(&tasklet);
 	return IRQ_HANDLED;
 }
 
 static void remote_fiq_interrupt(void)
 {
+	//struct remote *remote_data = (struct remote *)data;
 	remote_reprot_key(gp_remote);
 }
 
@@ -376,7 +420,7 @@ static int hardware_init(struct platform_device *pdev)
 	p=devm_pinctrl_get_select_default(&pdev->dev);
 	if (IS_ERR(p))
 		return -1;
-	set_remote_mode(DECODEMODE_NEC_RCA_2IN1);
+	set_remote_mode(DECODEMODE_NEC);
 	return request_irq(NEC_REMOTE_IRQ_NO, remote_interrupt, IRQF_SHARED, "keypad", (void *)remote_interrupt);
 }
 static int work_mode_config(unsigned int cur_mode)
@@ -390,7 +434,7 @@ static int work_mode_config(unsigned int cur_mode)
 	set_remote_init(gp_remote);
 	if(cur_mode == gp_remote->save_mode)
 		return 0;
-	if((cur_mode <= DECODEMODE_MAX)  && (gp_remote->save_mode > DECODEMODE_MAX) ) {
+	if((cur_mode <= DECODEMODE_MAX)  && (gp_remote->save_mode > DECODEMODE_MAX) ){
 		unregister_fiq_bridge_handle(&gp_remote->fiq_handle_item);
 		free_fiq(NEC_REMOTE_IRQ_NO, &remote_fiq_interrupt);
 		ret = request_irq(NEC_REMOTE_IRQ_NO, remote_interrupt, IRQF_SHARED, "keypad", (void *)remote_interrupt);
@@ -398,7 +442,8 @@ static int work_mode_config(unsigned int cur_mode)
 			printk(KERN_ERR "Remote: request_irq failed, ret=%d.\n", ret);
 			return ret;
 		}
-	} else if((cur_mode > DECODEMODE_MAX)  && (gp_remote->save_mode < DECODEMODE_MAX)) {
+	}
+	else if((cur_mode > DECODEMODE_MAX)  && (gp_remote->save_mode < DECODEMODE_MAX)){
 		free_irq(NEC_REMOTE_IRQ_NO, remote_interrupt);
 		gp_remote->fiq_handle_item.handle = remote_bridge_sw_isr[gp_remote->work_mode];
 		gp_remote->fiq_handle_item.key = (u32) gp_remote;
@@ -406,7 +451,8 @@ static int work_mode_config(unsigned int cur_mode)
 		register_fiq_bridge_handle(&gp_remote->fiq_handle_item);
 		desc->depth++;
 		request_fiq(NEC_REMOTE_IRQ_NO, remote_fiq_interrupt);
-	} else {
+	}
+	else{
 		printk("do nothing\n");
 	}
 	gp_remote->save_mode = cur_mode;
@@ -464,13 +510,13 @@ static long remote_config_ioctl(struct file *filp, unsigned int cmd, unsigned lo
 			mouse_map[remote->map_num][val >> 16] = val & 0xff;
 			break;
 		case REMOTE_IOC_SET_RELT_DELAY:
-			ret = copy_from_user(&remote->relt_delay[remote->map_num], argp, sizeof(long));
+			ret = copy_from_user(&remote->relt_delay, argp, sizeof(long));
 			break;
 		case REMOTE_IOC_SET_REPEAT_DELAY:
-			ret = copy_from_user(&remote->repeat_delay[remote->map_num], argp, sizeof(long));
+			ret = copy_from_user(&remote->repeat_delay, argp, sizeof(long));
 			break;
 		case REMOTE_IOC_SET_REPEAT_PERIOD:
-			ret = copy_from_user(&remote->repeat_peroid[remote->map_num], argp, sizeof(long));
+			ret = copy_from_user(&remote->repeat_peroid, argp, sizeof(long));
 			break;
 		case REMOTE_IOC_SET_REPEAT_ENABLE:
 			ret = copy_from_user(&remote->repeat_enable, argp, sizeof(long));
@@ -506,7 +552,7 @@ static long remote_config_ioctl(struct file *filp, unsigned int cmd, unsigned lo
 			am_remote_write_reg(DURATION_REG0, val);
 			break;
 		case REMOTE_IOC_SET_RELEASE_DELAY:
-			ret = copy_from_user(&remote->release_delay[remote->map_num], argp, sizeof(long));
+			ret = copy_from_user(&remote->release_delay, argp, sizeof(long));
 			break;
 			//SW
 		case REMOTE_IOC_SET_TW_LEADER_ACT:
@@ -544,8 +590,8 @@ static long remote_config_ioctl(struct file *filp, unsigned int cmd, unsigned lo
 	switch (cmd) {
 		case REMOTE_IOC_SET_REPEAT_ENABLE:
 			if (remote->repeat_enable) {
-				remote->input->rep[REP_DELAY] = remote->repeat_delay[remote->map_num] ;
-				remote->input->rep[REP_PERIOD] = remote->repeat_peroid[remote->map_num] ;
+				remote->input->rep[REP_DELAY] = remote->repeat_delay;
+				remote->input->rep[REP_PERIOD] = remote->repeat_peroid;
 			} else {
 				remote->input->rep[REP_DELAY] = 0xffffffff;
 				remote->input->rep[REP_PERIOD] = 0xffffffff;
@@ -605,15 +651,14 @@ static int register_remote_dev(struct remote *remote)
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static void remote_early_suspend(struct early_suspend *handler)
 {
-	printk("remote_early_suspend, set sleep 1 \n");
-	gp_remote->sleep = 1;
-	return;
+	 printk("remote_early_suspend, set sleep 1 \n");
+	 gp_remote->sleep = 1;
+	 return;
 }
 #endif
 
-static const struct of_device_id remote_dt_match[]= {
-	{
-		.compatible     = "amlogic,aml_remote",
+static const struct of_device_id remote_dt_match[]={
+	{	.compatible 	= "amlogic,aml_remote",
 	},
 	{},
 };
@@ -631,7 +676,7 @@ static int remote_probe(struct platform_device *pdev)
 		return -1;
 	}
 	ret = of_property_read_u32(pdev->dev.of_node,"ao_baseaddr",&ao_baseaddr);
-	if(ret) {
+	if(ret){
 		printk("don't find  match ao_baseaddr\n");
 		return -1;
 	}
@@ -658,38 +703,38 @@ static int remote_probe(struct platform_device *pdev)
 	remote->input = input_dev;
 	remote->release_fdelay = KEY_RELEASE_DELAY;
 	remote->custom_code[remote->map_num] = 0xfb04;
-	for(i=1; i<20; i++)
-		remote->custom_code[i] = 0xffff;
 	remote->bit_count = 32;
 	remote->last_jiffies = 0xffffffff;
 	remote->last_pulse_width = 0;
 	remote->step = REMOTE_STATUS_WAIT;
 	remote->sleep = 0;
 	//init logic0 logic1  time window
-	for(i = 0; i < 18; i++)
+	for(i = 0;i < 18;i++)
 		remote->time_window[i] = 0x1;
-	/* Disable the interrupt for the MPUIO keyboard
-	init the default key map table ,and mouse map table.
-	note KEY_RESERVED==0*/
-	memset(key_map, 0x0, sizeof(key_map));
-	memset(mouse_map, 0xff, sizeof(mouse_map));
-	remote->repeat_delay[remote->map_num]  = 250;
-	remote->repeat_peroid[remote->map_num]  = 33;
+	/* Disable the interrupt for the MPUIO keyboard */
+	for (i = 0; i < ARRAY_SIZE(key_map[remote->map_num]); i++) {
+		key_map[remote->map_num][i] = KEY_RESERVED;
+	}
+	for (i = 0; i < ARRAY_SIZE(mouse_map); i++) {
+		mouse_map[remote->map_num][i] = 0xffff;
+	}
+	remote->repeat_delay = 250;
+	remote->repeat_peroid = 33;
 	/* get the irq and init timer */
 	input_dbg("set drvdata completed\r\n");
 	tasklet_enable(&tasklet);
 	tasklet.data = (unsigned long)remote;
 	setup_timer(&remote->timer, remote_release_timer_sr, 0);
-	/*read status & frame register to abandon last key from uboot*/
+        /*read status & frame register to abandon last key from uboot*/
 	am_remote_read_reg(DURATION_REG1_AND_STATUS);
 	am_remote_read_reg(FRAME_BODY);
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING + 1;
-	early_suspend.suspend = remote_early_suspend;
-	early_suspend.resume = NULL;
-	early_suspend.param = gp_remote;
-	register_early_suspend(&early_suspend);
-#endif
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+    early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING + 1;
+    early_suspend.suspend = remote_early_suspend;
+    early_suspend.resume = NULL;
+    early_suspend.param = gp_remote;
+    register_early_suspend(&early_suspend);
+    #endif
 
 	ret = device_create_file(&pdev->dev, &dev_attr_enable);
 	if (ret < 0) {
@@ -733,6 +778,14 @@ static int remote_probe(struct platform_device *pdev)
 	remote_log_buf = (char *)__get_free_pages(GFP_KERNEL, REMOTE_LOG_BUF_ORDER);
 	remote_log_buf[0] = '\0';
 	printk("physical address:0x%x\n", (unsigned int)virt_to_phys(remote_log_buf));
+
+	//set gpioy_10 as gpio
+	power_led_sys= amlogic_gpio_name_map_num("GPIOAO_2");
+	amlogic_gpio_request(power_led_sys, "POWER_LED_SYS");
+	//set gpioy_11 as gpio
+	power_led_wake= amlogic_gpio_name_map_num("GPIOAO_13");
+	amlogic_gpio_request(power_led_wake, "POWER_LED_WAKE");
+
 	return 0;
 err3:
 	input_unregister_device(remote->input);
@@ -757,7 +810,7 @@ static int remote_remove(struct platform_device *pdev)
 	free_pages((unsigned long)remote_log_buf, REMOTE_LOG_BUF_ORDER);
 	device_remove_file(&pdev->dev, &dev_attr_enable);
 	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
-	if(gp_remote->work_mode >= DECODEMODE_MAX) {
+	if(gp_remote->work_mode >= DECODEMODE_MAX){
 		free_fiq(NEC_REMOTE_IRQ_NO, remote_fiq_interrupt);
 		free_irq(BRIDGE_IRQ, gp_remote);
 	} else {
@@ -794,9 +847,9 @@ static int remote_resume(struct platform_device * pdev)
 		WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0);
 	}
 	gp_remote->sleep = 0;
-	printk("to clear irq ...\n");
+        printk("to clear irq ...\n");
 	disable_irq(NEC_REMOTE_IRQ_NO);
-	udelay(1000);
+        udelay(1000);
 	enable_irq(NEC_REMOTE_IRQ_NO);
 
 	return 0;
diff --git a/drivers/amlogic/input/new_remote/remote_main.h b/drivers/amlogic/input/new_remote/remote_main.h
index b3da3cb..791a455 100755
--- a/drivers/amlogic/input/new_remote/remote_main.h
+++ b/drivers/amlogic/input/new_remote/remote_main.h
@@ -23,10 +23,10 @@ typedef struct reg_s {
 	int reg;
 	unsigned int val;
 } remotereg_t;
-typedef enum {
+typedef enum{
 	NORMAL = 0,
 	TIMER = 1 ,
-} repeat_status;
+}repeat_status;
 
 /*
    Decode_mode.(format selection)
@@ -47,29 +47,26 @@ typedef enum {
    0xE=Comcast
    0xF=Sanyo
  */
-typedef enum {
+typedef enum{
 	DECODEMODE_NEC = 0,
 	DECODEMODE_DUOKAN = 1 ,
 	DECODEMODE_RCMM ,
 	DECODEMODE_SONYSIRC,
 	DECODEMODE_SKIPLEADER ,
+	DECODEMODE_SW,
 	DECODEMODE_MITSUBISHI,
 	DECODEMODE_THOMSON,
 	DECODEMODE_TOSHIBA,
 	DECODEMODE_RC5,
 	DECODEMODE_RESERVED,
 	DECODEMODE_RC6,
-	DECODEMODE_RCA,
 	DECODEMODE_COMCAST,
 	DECODEMODE_SANYO,
-	DECODEMODE_NEC_RCA_2IN1 = 14,
-	DECODEMODE_NEC_TOSHIBA_2IN1 = 15,
-	DECODEMODE_SW,
 	DECODEMODE_MAX ,
 	DECODEMODE_SW_NEC,
 	DECODEMODE_SW_DUOKAN
 
-} ddmode_t;
+}ddmode_t;
 
 /*remote config val*/
 /****************************************************************/
@@ -179,7 +176,7 @@ static const remotereg_t RDECODEMODE_THOMSON[] = {
 static const remotereg_t RDECODEMODE_COMCAST[] = {
 	{LDR_ACTIVE, 0   },
 	{LDR_IDLE,0  },
-	{LDR_REPEAT,0   },
+	{LDR_REPEAT,0	},
 	{DURATION_REG0, 0},
 	{OPERATION_CTRL_REG0,0},
 	{DURATION_REG1_AND_STATUS,},
@@ -192,7 +189,7 @@ static const remotereg_t RDECODEMODE_COMCAST[] = {
 static const remotereg_t RDECODEMODE_SKIPLEADER[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
+	{LDR_REPEAT,	},
 	{DURATION_REG0, },
 	{OPERATION_CTRL_REG0,},
 	{DURATION_REG1_AND_STATUS,},
@@ -205,7 +202,7 @@ static const remotereg_t RDECODEMODE_SKIPLEADER[] = {
 static const remotereg_t RDECODEMODE_SW[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
+	{LDR_REPEAT,	},
 	{DURATION_REG0, },
 	{OPERATION_CTRL_REG0,},
 	{DURATION_REG1_AND_STATUS,},
@@ -241,55 +238,10 @@ static const remotereg_t RDECODEMODE_SW_DUOKAN[] = {
 	{DURATION_REG3,0},
 	{CONFIG_END,            0      }
 };
-static const remotereg_t RDECODEMODE_NEC_RCA_2IN1[] = {
-	// used old decode
-	{LDR_ACTIVE-0x100,((unsigned)477<<16) | ((unsigned)400<<0)},// NEC leader 9500us,max 477: (477* timebase = 20) = 9540 ;min 400 = 8000us
-	{LDR_IDLE-0x100, 248<<16 | 202<<0},// leader idle
-	{LDR_REPEAT-0x100,130<<16|110<<0}, // leader repeat
-	{DURATION_REG0-0x100,60<<16|48<<0 },// logic '0' or '00'
-	{OPERATION_CTRL_REG0-0x100,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
-	{DURATION_REG1_AND_STATUS-0x100,(111<<20)|(100<<10)}, // logic '1' or '01'
-	{OPERATION_CTRL_REG1-0x100,0xbe40},// boby long decode (9-13)
-	// used new decode
-	{LDR_ACTIVE,((unsigned)250<<16) | ((unsigned)160<<0)},//rca leader 4000us,200* timebase
-	{LDR_IDLE, 250<<16 | 160<<0},// leader idle 400
-	{LDR_REPEAT,250<<16|160<<0}, // leader repeat
-	{DURATION_REG0,100<<16|48<<0 },// logic '0' or '00' 1500us
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame
-	{DURATION_REG1_AND_STATUS,(150<<20)|(110<<10)}, // logic '1' or '01'     2500us
-	{OPERATION_CTRL_REG1,0x9740},// boby long decode (8-13) //framn len = 24bit
-	/*it may get the wrong customer value and key value from register if the value is set to 0x4,so the register value must set to 0x104*/
-	{OPERATION_CTRL_REG2,0x104},
-	{DURATION_REG2,0},
-	{DURATION_REG3,0},
-	{CONFIG_END,            0      }
-};
-static const remotereg_t RDECODEMODE_NEC_TOSHIBA_2IN1[] = {
-	// used old decode
-	{LDR_ACTIVE-0x100,((unsigned)477<<16) | ((unsigned)400<<0)},// NEC leader 9500us,max 477: (477* timebase = 20) = 9540 ;min 400 = 8000us
-	{LDR_IDLE-0x100, 248<<16 | 202<<0},// leader idle
-	{LDR_REPEAT-0x100,130<<16|110<<0}, // leader repeat
-	{DURATION_REG0-0x100,60<<16|48<<0 },// logic '0' or '00'
-	{OPERATION_CTRL_REG0-0x100,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
-	{DURATION_REG1_AND_STATUS-0x100,(111<<20)|(100<<10)}, // logic '1' or '01'
-	{OPERATION_CTRL_REG1-0x100,0xbe00},// boby long decode (9-13)
-	// used new decode
-	{LDR_ACTIVE,((unsigned)300<<16) | ((unsigned)160<<0)},//toshiba leader 4500us,20* timebase
-	{LDR_IDLE, 300<<16 | 160<<0},// leader idle 4500
-	{LDR_REPEAT,300<<16|160<<0}, // leader repeat
-	{DURATION_REG0,90<<16|48<<0 },// logic '0' or '00' 1200us
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame
-	{DURATION_REG1_AND_STATUS,(150<<20)|(100<<10)}, // logic '1' or '01'     2400us
-	{OPERATION_CTRL_REG1,0x9f40},// boby long decode (8-13) //framn len = 24bit
-	{OPERATION_CTRL_REG2,0x5},
-	{DURATION_REG2,0},
-	{DURATION_REG3,0},
-	{CONFIG_END,            0      }
-};
 static const remotereg_t RDECODEMODE_RC5[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
+	{LDR_REPEAT,	},
 	{DURATION_REG0, },
 	{OPERATION_CTRL_REG0,},
 	{DURATION_REG1_AND_STATUS,},
@@ -302,7 +254,7 @@ static const remotereg_t RDECODEMODE_RC5[] = {
 static const remotereg_t RDECODEMODE_RESERVED[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
+	{LDR_REPEAT,	},
 	{DURATION_REG0, },
 	{OPERATION_CTRL_REG0,},
 	{DURATION_REG1_AND_STATUS,},
@@ -315,7 +267,7 @@ static const remotereg_t RDECODEMODE_RESERVED[] = {
 static const remotereg_t RDECODEMODE_RC6[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
+	{LDR_REPEAT,	},
 	{DURATION_REG0, },
 	{OPERATION_CTRL_REG0,},
 	{DURATION_REG1_AND_STATUS,},
@@ -331,7 +283,7 @@ static const remotereg_t RDECODEMODE_RC6[] = {
 static const remotereg_t RDECODEMODE_SANYO[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
+	{LDR_REPEAT,	},
 	{DURATION_REG0, },
 	{OPERATION_CTRL_REG0,},
 	{DURATION_REG1_AND_STATUS,},
@@ -357,52 +309,51 @@ void setremotereg(const remotereg_t *r);
 
 
 //remote config  ioctl  cmd
-#define REMOTE_IOC_INFCODE_CONFIG       _IOW_BAD('I',13,sizeof(short))
-#define REMOTE_IOC_RESET_KEY_MAPPING        _IOW_BAD('I',3,sizeof(short))
-#define REMOTE_IOC_SET_KEY_MAPPING          _IOW_BAD('I',4,sizeof(short))
+#define REMOTE_IOC_INFCODE_CONFIG	    _IOW_BAD('I',13,sizeof(short))
+#define REMOTE_IOC_RESET_KEY_MAPPING	    _IOW_BAD('I',3,sizeof(short))
+#define REMOTE_IOC_SET_KEY_MAPPING		    _IOW_BAD('I',4,sizeof(short))
 #define REMOTE_IOC_SET_REPEAT_KEY_MAPPING   _IOW_BAD('I',20,sizeof(short))
-#define REMOTE_IOC_SET_MOUSE_MAPPING        _IOW_BAD('I',5,sizeof(short))
-#define REMOTE_IOC_SET_REPEAT_DELAY         _IOW_BAD('I',6,sizeof(short))
-#define REMOTE_IOC_SET_REPEAT_PERIOD        _IOW_BAD('I',7,sizeof(short))
+#define REMOTE_IOC_SET_MOUSE_MAPPING	    _IOW_BAD('I',5,sizeof(short))
+#define REMOTE_IOC_SET_REPEAT_DELAY		    _IOW_BAD('I',6,sizeof(short))
+#define REMOTE_IOC_SET_REPEAT_PERIOD	    _IOW_BAD('I',7,sizeof(short))
 
-#define REMOTE_IOC_SET_REPEAT_ENABLE        _IOW_BAD('I',8,sizeof(short))
-#define REMOTE_IOC_SET_DEBUG_ENABLE         _IOW_BAD('I',9,sizeof(short))
-#define REMOTE_IOC_SET_MODE                 _IOW_BAD('I',10,sizeof(short))
-
-#define REMOTE_IOC_SET_CUSTOMCODE       _IOW_BAD('I',100,sizeof(short))
-#define REMOTE_IOC_SET_RELEASE_DELAY        _IOW_BAD('I',99,sizeof(short))
+#define REMOTE_IOC_SET_REPEAT_ENABLE		_IOW_BAD('I',8,sizeof(short))
+#define	REMOTE_IOC_SET_DEBUG_ENABLE			_IOW_BAD('I',9,sizeof(short))
+#define	REMOTE_IOC_SET_MODE					_IOW_BAD('I',10,sizeof(short))
 
+#define REMOTE_IOC_SET_RELEASE_DELAY		_IOW_BAD('I',99,sizeof(short))
+#define REMOTE_IOC_SET_CUSTOMCODE   		_IOW_BAD('I',100,sizeof(short))
 //reg
-#define REMOTE_IOC_SET_REG_BASE_GEN         _IOW_BAD('I',101,sizeof(short))
-#define REMOTE_IOC_SET_REG_CONTROL          _IOW_BAD('I',102,sizeof(short))
-#define REMOTE_IOC_SET_REG_LEADER_ACT       _IOW_BAD('I',103,sizeof(short))
-#define REMOTE_IOC_SET_REG_LEADER_IDLE      _IOW_BAD('I',104,sizeof(short))
-#define REMOTE_IOC_SET_REG_REPEAT_LEADER    _IOW_BAD('I',105,sizeof(short))
-#define REMOTE_IOC_SET_REG_BIT0_TIME         _IOW_BAD('I',106,sizeof(short))
+#define REMOTE_IOC_SET_REG_BASE_GEN			_IOW_BAD('I',101,sizeof(short))
+#define REMOTE_IOC_SET_REG_CONTROL			_IOW_BAD('I',102,sizeof(short))
+#define REMOTE_IOC_SET_REG_LEADER_ACT 		_IOW_BAD('I',103,sizeof(short))
+#define REMOTE_IOC_SET_REG_LEADER_IDLE 		_IOW_BAD('I',104,sizeof(short))
+#define REMOTE_IOC_SET_REG_REPEAT_LEADER 	_IOW_BAD('I',105,sizeof(short))
+#define REMOTE_IOC_SET_REG_BIT0_TIME		 _IOW_BAD('I',106,sizeof(short))
 
 //sw
-#define REMOTE_IOC_SET_BIT_COUNT            _IOW_BAD('I',107,sizeof(short))
-#define REMOTE_IOC_SET_TW_LEADER_ACT        _IOW_BAD('I',108,sizeof(short))
-#define REMOTE_IOC_SET_TW_BIT0_TIME         _IOW_BAD('I',109,sizeof(short))
-#define REMOTE_IOC_SET_TW_BIT1_TIME         _IOW_BAD('I',110,sizeof(short))
-#define REMOTE_IOC_SET_TW_REPEATE_LEADER    _IOW_BAD('I',111,sizeof(short))
-
-#define REMOTE_IOC_GET_TW_LEADER_ACT        _IOR_BAD('I',112,sizeof(short))
-#define REMOTE_IOC_GET_TW_BIT0_TIME         _IOR_BAD('I',113,sizeof(short))
-#define REMOTE_IOC_GET_TW_BIT1_TIME         _IOR_BAD('I',114,sizeof(short))
-#define REMOTE_IOC_GET_TW_REPEATE_LEADER    _IOR_BAD('I',115,sizeof(short))
-
-#define REMOTE_IOC_GET_REG_BASE_GEN         _IOR_BAD('I',121,sizeof(short))
-#define REMOTE_IOC_GET_REG_CONTROL          _IOR_BAD('I',122,sizeof(short))
-#define REMOTE_IOC_GET_REG_LEADER_ACT       _IOR_BAD('I',123,sizeof(short))
-#define REMOTE_IOC_GET_REG_LEADER_IDLE      _IOR_BAD('I',124,sizeof(short))
-#define REMOTE_IOC_GET_REG_REPEAT_LEADER    _IOR_BAD('I',125,sizeof(short))
-#define REMOTE_IOC_GET_REG_BIT0_TIME        _IOR_BAD('I',126,sizeof(short))
-#define REMOTE_IOC_GET_REG_FRAME_DATA       _IOR_BAD('I',127,sizeof(short))
-#define REMOTE_IOC_GET_REG_FRAME_STATUS     _IOR_BAD('I',128,sizeof(short))
-
-#define REMOTE_IOC_SET_TW_BIT2_TIME         _IOW_BAD('I',129,sizeof(short))
-#define REMOTE_IOC_SET_TW_BIT3_TIME         _IOW_BAD('I',130,sizeof(short))
+#define REMOTE_IOC_SET_BIT_COUNT		 	_IOW_BAD('I',107,sizeof(short))
+#define REMOTE_IOC_SET_TW_LEADER_ACT		_IOW_BAD('I',108,sizeof(short))
+#define REMOTE_IOC_SET_TW_BIT0_TIME			_IOW_BAD('I',109,sizeof(short))
+#define REMOTE_IOC_SET_TW_BIT1_TIME			_IOW_BAD('I',110,sizeof(short))
+#define REMOTE_IOC_SET_TW_REPEATE_LEADER	_IOW_BAD('I',111,sizeof(short))
+
+#define REMOTE_IOC_GET_TW_LEADER_ACT		_IOR_BAD('I',112,sizeof(short))
+#define REMOTE_IOC_GET_TW_BIT0_TIME			_IOR_BAD('I',113,sizeof(short))
+#define REMOTE_IOC_GET_TW_BIT1_TIME			_IOR_BAD('I',114,sizeof(short))
+#define REMOTE_IOC_GET_TW_REPEATE_LEADER	_IOR_BAD('I',115,sizeof(short))
+
+#define REMOTE_IOC_GET_REG_BASE_GEN			_IOR_BAD('I',121,sizeof(short))
+#define REMOTE_IOC_GET_REG_CONTROL			_IOR_BAD('I',122,sizeof(short))
+#define REMOTE_IOC_GET_REG_LEADER_ACT 		_IOR_BAD('I',123,sizeof(short))
+#define REMOTE_IOC_GET_REG_LEADER_IDLE 		_IOR_BAD('I',124,sizeof(short))
+#define REMOTE_IOC_GET_REG_REPEAT_LEADER 	_IOR_BAD('I',125,sizeof(short))
+#define REMOTE_IOC_GET_REG_BIT0_TIME	 	_IOR_BAD('I',126,sizeof(short))
+#define REMOTE_IOC_GET_REG_FRAME_DATA		_IOR_BAD('I',127,sizeof(short))
+#define REMOTE_IOC_GET_REG_FRAME_STATUS		_IOR_BAD('I',128,sizeof(short))
+
+#define REMOTE_IOC_SET_TW_BIT2_TIME			_IOW_BAD('I',129,sizeof(short))
+#define REMOTE_IOC_SET_TW_BIT3_TIME			_IOW_BAD('I',130,sizeof(short))
 
 #define   REMOTE_IOC_SET_FN_KEY_SCANCODE     _IOW_BAD('I', 131, sizeof(short))
 #define   REMOTE_IOC_SET_LEFT_KEY_SCANCODE   _IOW_BAD('I', 132, sizeof(short))
@@ -412,13 +363,13 @@ void setremotereg(const remotereg_t *r);
 #define   REMOTE_IOC_SET_OK_KEY_SCANCODE     _IOW_BAD('I', 136, sizeof(short))
 #define   REMOTE_IOC_SET_PAGEUP_KEY_SCANCODE _IOW_BAD('I', 137, sizeof(short))
 #define   REMOTE_IOC_SET_PAGEDOWN_KEY_SCANCODE _IOW_BAD('I', 138, sizeof(short))
-#define   REMOTE_IOC_SET_RELT_DELAY     _IOW_BAD('I',140,sizeof(short))
+#define   REMOTE_IOC_SET_RELT_DELAY	    _IOW_BAD('I',140,sizeof(short))
 
-#define REMOTE_HW_DECODER_STATUS_MASK       (0xf<<4)
-#define REMOTE_HW_DECODER_STATUS_OK         (0<<4)
-#define REMOTE_HW_DECODER_STATUS_TIMEOUT    (1<<4)
-#define REMOTE_HW_DECODER_STATUS_LEADERERR  (2<<4)
-#define REMOTE_HW_DECODER_STATUS_REPEATERR  (3<<4)
+#define	REMOTE_HW_DECODER_STATUS_MASK		(0xf<<4)
+#define	REMOTE_HW_DECODER_STATUS_OK			(0<<4)
+#define	REMOTE_HW_DECODER_STATUS_TIMEOUT	(1<<4)
+#define	REMOTE_HW_DECODER_STATUS_LEADERERR	(2<<4)
+#define	REMOTE_HW_DECODER_STATUS_REPEATERR	(3<<4)
 
 /* software  decode status*/
 #define REMOTE_STATUS_WAIT       0
@@ -430,8 +381,8 @@ void setremotereg(const remotereg_t *r);
 #define KEYDOMIAN 1 // find key val vail data domain
 #define CUSTOMDOMAIN 0 // find key val vail custom domain
 /*phy page user debug*/
-#define REMOTE_LOG_BUF_LEN       4098
-#define REMOTE_LOG_BUF_ORDER        1
+#define REMOTE_LOG_BUF_LEN		 8192
+#define REMOTE_LOG_BUF_ORDER		1
 
 
 typedef int (*type_printk)(const char *fmt, ...);
@@ -447,7 +398,6 @@ struct remote {
 	int irq;
 	int save_mode;
 	int work_mode; // use ioctl config decode mode
-	int temp_work_mode; // use ioctl config decode mode
 	int frame_mode;// same protocol frame have diffrent mode
 	unsigned int register_data;
 	unsigned int frame_status;
@@ -468,7 +418,7 @@ struct remote {
 	//use duble protocol release time
 	unsigned int release_fdelay; //frist protocol
 	unsigned int release_sdelay;// second protocol
-	unsigned int release_delay[20];
+	unsigned int release_delay;
 	// debug swtich
 	unsigned int debug_enable;
 	//sw
@@ -490,9 +440,9 @@ struct remote {
 	char config_name[20];
 	struct class *config_class;
 	struct device *config_dev;
-	unsigned int repeat_delay[20];
-	unsigned int relt_delay[20];
-	unsigned int repeat_peroid[20];
+	unsigned int repeat_delay;
+	unsigned int relt_delay;
+	unsigned int repeat_peroid;
 	//
 	int (*remote_reprot_press_key)(struct remote *);
 	int (*key_report)(struct remote *);
@@ -508,18 +458,15 @@ void kdb_send_key(struct input_dev *dev, unsigned int scancode,unsigned int type
 void remote_send_key(struct input_dev *dev, unsigned int scancode,
 		unsigned int type,int event);
 extern irqreturn_t remote_bridge_isr(int irq, void *dev_id);
-extern irqreturn_t remote_null_bridge_isr(int irq, void *dev_id);
-extern int remote_hw_reprot_null_key(struct remote *remote_data);
 extern int remote_hw_reprot_key(struct remote *remote_data);
-extern int remote_hw_nec_rca_2in1_reprot_key(struct remote *remote_data);
-extern int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data);
 extern int remote_sw_reprot_key(struct remote *remote_data);
 extern void remote_nec_report_release_key(struct remote *remote_data);
-extern void remote_nec_rca_2in1_report_release_key(struct remote *remote_data);
-extern void remote_nec_toshiba_2in1_report_release_key(struct remote *remote_data);
 extern void remote_duokan_report_release_key(struct remote *remote_data);
 extern void remote_sw_reprot_release_key(struct remote *remote_data);
-extern void remote_null_reprot_release_key(struct remote *remote_data);
+
+
+
+
 extern int register_fiq_bridge_handle(bridge_item_t * c_item);
 extern int unregister_fiq_bridge_handle(bridge_item_t * c_item);
 extern int fiq_bridge_pulse_trigger(bridge_item_t * c_item);
diff --git a/drivers/amlogic/rtc/Kconfig b/drivers/amlogic/rtc/Kconfig
index 7c335d2..e877e26 100755
--- a/drivers/amlogic/rtc/Kconfig
+++ b/drivers/amlogic/rtc/Kconfig
@@ -7,3 +7,5 @@ config AML_RTC
     select RTC_CLASS
     help
       This is the Amlogic internal RTC driver
+
+
diff --git a/drivers/amlogic/rtc/aml_rtc.c b/drivers/amlogic/rtc/aml_rtc.c
index 3031fe0..b65cb43 100755
--- a/drivers/amlogic/rtc/aml_rtc.c
+++ b/drivers/amlogic/rtc/aml_rtc.c
@@ -15,104 +15,104 @@
  #include <linux/of.h>
 
 int c_dbg_lvl = 0;
-#define RTC_DBG(lvl, x...) do{ if (c_dbg_lvl & lvl) printk(x);} while (0)
+#define RTC_DBG(lvl, x...) do{ if(c_dbg_lvl & lvl) printk(x);} while(0)
 #define RTC_DBG_VAL 1 << 0
 #define RTC_DBG_WR 1 << 1
 
 // Define register AO_RTC_ADDR0 bit map
-#define RTC_REG0_BIT_sclk_static	20
-#define RTC_REG0_BIT_ildo_ctrl_1	7
-#define RTC_REG0_BIT_ildo_ctrl_0	6
-#define RTC_REG0_BIT_test_mode		5
-#define RTC_REG0_BIT_test_clk		4
-#define RTC_REG0_BIT_test_bypass	3
-#define RTC_REG0_BIT_sdi		2
-#define RTC_REG0_BIT_sen		1
-#define RTC_REG0_BIT_sclk		0
+#define RTC_REG0_BIT_sclk_static     20
+#define RTC_REG0_BIT_ildo_ctrl_1      7
+#define RTC_REG0_BIT_ildo_ctrl_0      6
+#define RTC_REG0_BIT_test_mode      	5
+#define RTC_REG0_BIT_test_clk         4
+#define RTC_REG0_BIT_test_bypass    	3
+#define RTC_REG0_BIT_sdi              2
+#define RTC_REG0_BIT_sen              1
+#define RTC_REG0_BIT_sclk             0
 
 // Define register AO_RTC_ADDR1 bit map
-#define RTC_REG1_BIT_gpo_to_dig		3
-#define RTC_REG1_BIT_gpi_to_dig		2
-#define RTC_REG1_BIT_s_ready		1
-#define RTC_REG1_BIT_sdo		0
+#define RTC_REG1_BIT_gpo_to_dig     	3
+#define RTC_REG1_BIT_gpi_to_dig      	2
+#define RTC_REG1_BIT_s_ready          1
+#define RTC_REG1_BIT_sdo              0
 
 // Define register AO_RTC_ADDR3 bit map
-#define RTC_REG3_BIT_count_always	17
+#define RTC_REG3_BIT_count_always   	17
 
 // Define RTC serial protocal
-#define RTC_SER_DATA_BITS		32
-#define RTC_SER_ADDR_BITS		3
+#define RTC_SER_DATA_BITS           	32
+#define RTC_SER_ADDR_BITS           	3
 
 
-#define s_ready				1 << RTC_REG1_BIT_s_ready
-#define s_do				1 << RTC_REG1_BIT_sdo
-#define RESET_RETRY_TIMES		3
+#define s_ready                  			1 << RTC_REG1_BIT_s_ready
+#define s_do                       		1 << RTC_REG1_BIT_sdo
+#define RESET_RETRY_TIMES           	3
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 #if (defined(CONFIG_MESON_TRUSTZONE) && defined(CONFIG_ARCH_MESON6))
 #include <mach/meson-secure.h>
-#define WR_RTC(addr, data)		meson_secure_reg_write(P_##addr, data)
-#define RD_RTC(addr)			meson_secure_reg_read(P_##addr)
+#define WR_RTC(addr, data)         meson_secure_reg_write(P_##addr, data)
+#define RD_RTC(addr)               meson_secure_reg_read(P_##addr)
 #else
-#define WR_RTC(addr, data)		aml_write_reg32(P_##addr, data)
-#define RD_RTC(addr)			aml_read_reg32(P_##addr)
+#define WR_RTC(addr, data)         aml_write_reg32(P_##addr, data)
+#define RD_RTC(addr)               aml_read_reg32(P_##addr)
 #endif
 #else
-#define WR_RTC(addr, data)		WRITE_AOBUS_REG(addr, data)
-#define RD_RTC(addr)			READ_AOBUS_REG(addr)
+#define WR_RTC(addr, data)         WRITE_AOBUS_REG(addr, data)
+#define RD_RTC(addr)                   READ_AOBUS_REG(addr)
 #endif
 
-#define RTC_sbus_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & \
-					~((1<<RTC_REG0_BIT_sen)|(1<<RTC_REG0_BIT_sclk)|(1<<RTC_REG0_BIT_sdi))))
+#define RTC_sbus_LOW(x)             WR_RTC(AO_RTC_ADDR0, \
+                                                                      (RD_RTC(AO_RTC_ADDR0) & \
+                                                                      ~((1<<RTC_REG0_BIT_sen)|(1<<RTC_REG0_BIT_sclk)|(1<<RTC_REG0_BIT_sdi))))
 
-#define RTC_sdi_HIGH(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sdi) ))
+#define RTC_sdi_HIGH(x)             WR_RTC(AO_RTC_ADDR0, \
+                                                                  (RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sdi) ))
 
-#define RTC_sdi_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sdi) ))
+#define RTC_sdi_LOW(x)               WR_RTC(AO_RTC_ADDR0, \
+                                                                   (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sdi) ))
 
-#define RTC_sen_HIGH(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sen) ))
+#define RTC_sen_HIGH(x)             WR_RTC(AO_RTC_ADDR0, \
+                                                                   (RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sen) ))
 
-#define RTC_sen_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sen) ))
+#define RTC_sen_LOW(x)               WR_RTC(AO_RTC_ADDR0, \
+                                                                    (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sen) ))
 
-#define RTC_sclk_HIGH(x)		WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk)))
+#define RTC_sclk_HIGH(x)             WR_RTC(AO_RTC_ADDR0, \
+                                                                    (RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk)))
 
-#define RTC_sclk_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk)))
+#define RTC_sclk_LOW(x)               WR_RTC(AO_RTC_ADDR0, \
+                                                                      (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk)))
 
-#define RTC_sdo_READBIT			(RD_RTC(AO_RTC_ADDR1)&(1<<RTC_REG1_BIT_sdo))
+#define RTC_sdo_READBIT             (RD_RTC(AO_RTC_ADDR1)&(1<<RTC_REG1_BIT_sdo))
 
-#define RTC_sclk_static_HIGH(x)		WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk_static)))
+#define RTC_sclk_static_HIGH(x)   WR_RTC(AO_RTC_ADDR0, \
+                                                                      (RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk_static)))
 
-#define RTC_sclk_static_LOW(x)		WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk_static)))
+#define RTC_sclk_static_LOW(x)      WR_RTC(AO_RTC_ADDR0, \
+                                                                        (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk_static)))
 
-#define RTC_count_always_HIGH(x)	WR_RTC(AO_RTC_ADDR3, \
-					(RD_RTC(AO_RTC_ADDR3) |(1<<RTC_REG3_BIT_count_always)))
-#define RTC_count_always_LOW(x)		WR_RTC(AO_RTC_ADDR3, \
-					(RD_RTC(AO_RTC_ADDR3) & ~(1<<RTC_REG3_BIT_count_always)))
+#define RTC_count_always_HIGH(x)     WR_RTC(AO_RTC_ADDR3, \
+                                                                       (RD_RTC(AO_RTC_ADDR3) |(1<<RTC_REG3_BIT_count_always)))
+#define RTC_count_always_LOW(x)      WR_RTC(AO_RTC_ADDR3, \
+                                                                              (RD_RTC(AO_RTC_ADDR3) & ~(1<<RTC_REG3_BIT_count_always)))
 
-#define RTC_Sdo_READBIT			RD_RTC(AO_RTC_ADDR1)&s_do`
+#define RTC_Sdo_READBIT                       RD_RTC(AO_RTC_ADDR1)&s_do`
 
 
 //#define RTC_SER_REG_DATA_NOTIFIER   0xb41b// Define RTC register address mapping
 
-//#define P_ISA_TIMERE			(volatile unsigned long *)0xc1109954
+//#define P_ISA_TIMERE                (volatile unsigned long *)0xc1109954
 
 // Define RTC register address mapping
-#define RTC_COUNTER_ADDR		0
-#define RTC_GPO_COUNTER_ADDR		1
-#define RTC_SEC_ADJUST_ADDR		2
-#define RTC_UNUSED_ADDR_0		3
-#define RTC_REGMEM_ADDR_0		4
-#define RTC_REGMEM_ADDR_1		5
-#define RTC_REGMEM_ADDR_2		6
-#define RTC_REGMEM_ADDR_3		7
+#define RTC_COUNTER_ADDR            0
+#define RTC_GPO_COUNTER_ADDR        1
+#define RTC_SEC_ADJUST_ADDR         2
+#define RTC_UNUSED_ADDR_0           3
+#define RTC_REGMEM_ADDR_0           4
+#define RTC_REGMEM_ADDR_1           5
+#define RTC_REGMEM_ADDR_2           6
+#define RTC_REGMEM_ADDR_3           7
 
 static int  check_osc_clk(void);
 
@@ -191,7 +191,7 @@ static int  check_osc_clk(void)
 	// disable count always
 	WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3) & ~(1 << 17));
 
-	if ( osc_clk_count1 == osc_clk_count2 ) {
+	if( osc_clk_count1 == osc_clk_count2 ) {
 		RTC_DBG(RTC_DBG_VAL, "The osc_clk is not running now!"
 				" need to invcrease the power!\n");
 		return(-1);
@@ -205,24 +205,24 @@ static int  check_osc_clk(void)
 #endif
 void rtc_ser_static_write_auto (unsigned long static_reg_data_in)
 {
-	unsigned long data32;
+    unsigned long data32;
 
-	// Program MSB 15-8
-	data32  = (static_reg_data_in >> 8) & 0xff;
-	//WRITE_AOBUS_REG(AO_RTC_ADDR4,data32);
+    // Program MSB 15-8
+    data32  = (static_reg_data_in >> 8) & 0xff;
+    //WRITE_AOBUS_REG(AO_RTC_ADDR4,data32);
 	WR_RTC(AO_RTC_ADDR4, data32);
 
-	// Program LSB 7-0, and start serializing
-	//data32  = READ_AOBUS_REG(AO_RTC_ADDR0);
-	data32  = RD_RTC(AO_RTC_ADDR0);
-	data32 |= 1 << 17; // auto_serialize_start
-	data32 &= ~(0xff << 24);
-	data32 |= (static_reg_data_in & 0xff) << 24; // auto_static_reg
-	//WRITE_AOBUS_REG(AO_RTC_ADDR0,data32);
-	WR_RTC(AO_RTC_ADDR0,data32);
-	// Poll auto_serializer_busy bit until it's low (IDLE)
-	//while ((READ_AOBUS_REG(AO_RTC_ADDR0)) & 1<<22) {}
-	while ((RD_RTC(AO_RTC_ADDR0)) & 1<<22) {}
+    // Program LSB 7-0, and start serializing
+    //data32  = READ_AOBUS_REG(AO_RTC_ADDR0);
+    data32  = RD_RTC(AO_RTC_ADDR0);
+    data32 |= 1                           << 17; // auto_serialize_start
+    data32 &= ~(0xff << 24);
+    data32 |= (static_reg_data_in & 0xff) << 24; // auto_static_reg
+    //WRITE_AOBUS_REG(AO_RTC_ADDR0,data32);
+    WR_RTC(AO_RTC_ADDR0,data32);
+    // Poll auto_serializer_busy bit until it's low (IDLE)
+    //while ((READ_AOBUS_REG(AO_RTC_ADDR0)) & 1<<22) {}
+    while ((RD_RTC(AO_RTC_ADDR0)) & 1<<22) {}
 }
 
 
@@ -240,16 +240,16 @@ static int rtc_wait_s_ready(void)
 	if (get_rtc_status())
 		return i;
 	/*
-	while (i--) {
-		if ((*(volatile unsigned *)AO_RTC_ADDR1)&s_ready)
+	while (i--){
+		if((*(volatile unsigned *)AO_RTC_ADDR1)&s_ready)
 			break;
 		}
 	return i;
 	*/
 	while (!(RD_RTC(AO_RTC_ADDR1)&s_ready)) {
 		i--;
-		if (i == 0) {
-			if (try_cnt > RESET_RETRY_TIMES) {
+		if(i == 0){
+			if(try_cnt > RESET_RETRY_TIMES){
 				break;
 			}
 			rtc_reset_s_ready();
@@ -265,7 +265,7 @@ static int rtc_wait_s_ready(void)
 static int rtc_comm_init(void)
 {
 	RTC_sbus_LOW(0);
-	if (rtc_wait_s_ready()>0) {
+	if(rtc_wait_s_ready()>0){
 		RTC_sen_HIGH(1);
 		return 0;
 	}
@@ -285,9 +285,9 @@ static void rtc_send_bit(unsigned val)
 static void rtc_send_addr_data(unsigned type, unsigned val)
 {
 	unsigned cursor = (type? (1<<(RTC_SER_ADDR_BITS-1))
-				: (1<<(RTC_SER_DATA_BITS-1)));
+					 : (1<<(RTC_SER_DATA_BITS-1)));
 
-	while (cursor) {
+	while(cursor) {
 		rtc_send_bit(val&cursor);
 		cursor >>= 1;
 	}
@@ -316,11 +316,11 @@ static void rtc_set_mode(unsigned mode)
 }
 
 static void static_register_write(unsigned data);
-static void _ser_access_write_locked(unsigned long addr, unsigned long data);
+static void	 _ser_access_write_locked(unsigned long addr, unsigned long data);
 static void aml_rtc_reset(void)
 {
-	if (get_rtc_status())
-		return;
+    if (get_rtc_status())
+        return;
 	printk("error, the rtc serial communication abnormal,"
 		" reset the rtc!\n");
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
@@ -337,7 +337,7 @@ static void aml_rtc_reset(void)
 }
 
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-extern int run_arc_program_rtc(void);
+extern int run_arc_program(void);
 extern int stop_ao_cpu(void);
 #endif
 
@@ -354,9 +354,9 @@ static unsigned int _ser_access_read_locked(unsigned long addr)
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
 	ret = stop_ao_cpu();
 #endif
-	while (rtc_comm_init()<0) {
+	while(rtc_comm_init()<0){
 		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- rtc_common_init fail\n");
-		if (s_nrdy_cnt>RESET_RETRY_TIMES) {
+		if(s_nrdy_cnt>RESET_RETRY_TIMES) {
 			s_nrdy_cnt = 0;
 			rst_times++;
 			if (rst_times > 3) {
@@ -376,7 +376,7 @@ static unsigned int _ser_access_read_locked(unsigned long addr)
 out:
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
 	if (ret >= 0)
-		run_arc_program_rtc();
+		run_arc_program();
 #endif
 	return val;
 }
@@ -393,9 +393,9 @@ static void _ser_access_write_locked(unsigned long addr, unsigned long data)
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
 	ret = stop_ao_cpu();
 #endif
-	while (rtc_comm_init()<0) {
+	while(rtc_comm_init()<0){
 
-		if (s_nrdy_cnt>RESET_RETRY_TIMES) {
+		if(s_nrdy_cnt>RESET_RETRY_TIMES) {
 			s_nrdy_cnt = 0;
 			rst_times++;
 			if (rst_times > 3) {
@@ -415,7 +415,7 @@ static void _ser_access_write_locked(unsigned long addr, unsigned long data)
 out:
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
 	if (ret >= 0)
-		run_arc_program_rtc();
+		run_arc_program();
 #endif
 	return;
 }
@@ -426,7 +426,7 @@ static unsigned int ser_access_read(unsigned long addr)
 	unsigned long flags;
 
 	RTC_DBG(RTC_DBG_VAL, "aml_rtc --ser_access_read_1\n");
-	/*if (check_osc_clk() < 0) {
+	/*if(check_osc_clk() < 0){
 		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- the osc clk does not work\n");
 		return val;
 	}*/
@@ -457,13 +457,13 @@ int rtc_reset_gpo(struct device *dev, unsigned level)
 	unsigned data = 0;
 	data |= 1<<20;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	if (level) {
-		data |= 1<<22;	//gpo pin level high
+	if(level){
+		data |= 1<<22;         //gpo pin level high
 		}
 #else
 	//reset mode
-	if (!level) {
-		data |= 1<<22;	//gpo pin level high
+	if(!level){
+		data |= 1<<22;         //gpo pin level high
 	}
 #endif
 
@@ -496,14 +496,14 @@ int rtc_set_alarm_aml(struct device *dev, alarm_data_t *alarm_data) {
 
 	rtc_reset_gpo(dev, !(alarm_data->level));
 
-	data |= 2 << 20;	//output defined level after time
+	data |= 2 << 20;    //output defined level after time
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	data |= (alarm_data->level & 1) << 22;	//
+	data |= (alarm_data->level & 1) << 22;    //
 #else
-	data |= (!(alarm_data->level & 1)) << 22;	//
+	data |= (!(alarm_data->level & 1)) << 22;    //
 #endif
-	if (alarm_data->alarm_sec >= 1024*1024) {
+	if(alarm_data->alarm_sec >= 1024*1024){
 		return -1;
 	}
 
@@ -526,15 +526,15 @@ int rtc_set_alarm_aml(struct device *dev, alarm_data_t *alarm_data) {
 
 
 // -----------------------------------------------------------------------------
-//					Function: rtc_ser_static_write_manual
+//                    Function: rtc_ser_static_write_manual
 // Use part of the serial bus: sclk_static, sdi and sen to shift
 // in a 16-bit static data. Manual mode.
 // -----------------------------------------------------------------------------
 //static void rtc_ser_static_write_manual (unsigned int static_reg_data_in)
 //{
 //	int i;
-//	RTC_DBG(RTC_DBG_VAL, "rtc_ser_static_write_manual: data=0x%0/x\n",
-//		static_reg_data_in);
+//       RTC_DBG(RTC_DBG_VAL, "rtc_ser_static_write_manual: data=0x%0/x\n",
+//				 static_reg_data_in);
 //
 //	// Initialize: sen low for 1 clock cycle
 //	RTC_sen_LOW(0);
@@ -543,42 +543,42 @@ int rtc_set_alarm_aml(struct device *dev, alarm_data_t *alarm_data) {
 //	RTC_sen_HIGH(1);
 //	RTC_sclk_static_LOW(0);
 //
-//		// Shift in 16-bit known sequence
-//	for (i = 15; i >= 0; i --) {
+//        // Shift in 16-bit known sequence
+//	 for (i = 15; i >= 0; i --) {
 //
-//		if ((RTC_SER_REG_DATA_NOTIFIER >> i) & 0x1) {
-//			RTC_sdi_HIGH(1);
-//		}
-//		else {
-//			RTC_sdi_LOW(0);
-//		}
+//	     if ((RTC_SER_REG_DATA_NOTIFIER >> i) & 0x1) {
+//		   RTC_sdi_HIGH(1);
+//	     }
+//		 else {
+//		   RTC_sdi_LOW(0);
+//	     }
 //
-//		RTC_sclk_static_HIGH(1);
-//		RTC_sclk_static_LOW(0);
-//	}
+//	    RTC_sclk_static_HIGH(1);
+//	    RTC_sclk_static_LOW(0);
+//	 }
 //
-//	// 1 clock cycle turn around
-//	RTC_sdi_LOW(0);
-//	RTC_sclk_static_HIGH(1);
-//	RTC_sclk_static_LOW(0);
+//	  // 1 clock cycle turn around
+//	  RTC_sdi_LOW(0);
+//	  RTC_sclk_static_HIGH(1);
+//	  RTC_sclk_static_LOW(0);
 //
-//	// Shift in 16-bit static register data
-//	for (i = 15; i >= 0; i --) {
-//		if ((static_reg_data_in >> i) & 0x1) {
-//			RTC_sdi_HIGH(1);
+//	  // Shift in 16-bit static register data
+//	  for (i = 15; i >= 0; i --) {
+//	  	if ((static_reg_data_in >> i) & 0x1) {
+//		    RTC_sdi_HIGH(1);
 //		}
 //		else {
-//			RTC_sdi_LOW(0);
+//		    RTC_sdi_LOW(0);
 //		}
 //		RTC_sclk_static_HIGH(1);
 //		RTC_sclk_static_LOW(0);
-//	}
+//	   }
 //
-//	// One more clock cycle to complete write
-//	RTC_sen_LOW(0);
-//	RTC_sdi_LOW(0);
-//	RTC_sclk_static_HIGH(1);
-//	RTC_sclk_static_LOW(0);
+//	  // One more clock cycle to complete write
+//	  RTC_sen_LOW(0);
+//	  RTC_sdi_LOW(0);
+//	  RTC_sclk_static_HIGH(1);
+//	  RTC_sclk_static_LOW(0);
 //}
 
 
@@ -607,16 +607,16 @@ static int aml_rtc_read_time(struct device *dev, struct rtc_time *tm)
 
 static int aml_rtc_write_time(struct device *dev, struct rtc_time *tm)
 {
-	unsigned long time_t;
+      unsigned long time_t;
 
-	rtc_tm_to_time(tm, &time_t);
+      rtc_tm_to_time(tm, &time_t);
 
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc : write the rtc time, "
-		"time is %ld\n", time_t);
-	ser_access_write(RTC_COUNTER_ADDR, time_t);
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc : the time has been written\n");
+      RTC_DBG(RTC_DBG_VAL, "aml_rtc : write the rtc time, "
+			"time is %ld\n", time_t);
+      ser_access_write(RTC_COUNTER_ADDR, time_t);
+      RTC_DBG(RTC_DBG_VAL, "aml_rtc : the time has been written\n");
 
-	return 0;
+      return 0;
 }
 
 static int aml_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
@@ -637,7 +637,7 @@ static int aml_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 			return ret;
 		aml_rtc_read_time(dev, &cur_time);
 		ret = rtc_tm_to_time(&cur_time, &cur_secs);
-		if (alarm_secs >= cur_secs) {
+		if(alarm_secs >= cur_secs) {
 			/*3 seconds later then we real wanted,
 			  we do not need the alarm very acurate.*/
 			alarm_data.alarm_sec = alarm_secs - cur_secs + 3;
@@ -649,7 +649,7 @@ static int aml_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
 #else
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
 #endif
 		queue_work(priv->rtc_work_queue, &priv->work);
 	}
@@ -663,7 +663,7 @@ static int aml_rtc_suspend(struct platform_device *pdev, pm_message_t state)
 	alarm_data_t alarm_data;
 	static int suspend_time = 0;
 	alarm_data.alarm_sec = AUTO_RESUME_INTERVAL;
-		alarm_data.level = 0;
+        alarm_data.level = 0;
 	rtc_set_alarm_aml(&pdev->dev, &alarm_data);
 	printk("suspend %d times, system will up %ds later!\n",
 			++suspend_time, alarm_data.alarm_sec);
@@ -683,10 +683,10 @@ int aml_rtc_resume(struct platform_device *pdev)
 }
 
 static char *rtc_reg[8]={
-	"RTC_COUNTER	",
+	"RTC_COUNTER    ",
 	"RTC_GPO_COUNTER",
 	"RTC_SEC_ADJUST ",
-	"UNUSED		 ",
+	"UNUSED         ",
 	"RTC_REGMEM_0   ",
 	"RTC_REGMEM_1   ",
 	"RTC_REGMEM_2   ",
@@ -729,11 +729,6 @@ extern int get_aml_key_kernel(const char* key_name, unsigned char* data, int asc
 extern int extenal_api_key_set_version(char *devvesion);
 #endif
 
-#define RTC_INIT_MARSK	0x13208d83
-extern unsigned int aml_read_rtc_mem_reg(unsigned char reg_id);
-extern int aml_write_rtc_mem_reg(unsigned char reg_id, unsigned int data);
-extern int board_has_battery(void);
-
 static int aml_rtc_probe(struct platform_device *pdev)
 {
 	struct aml_rtc_priv *priv;
@@ -746,9 +741,9 @@ static int aml_rtc_probe(struct platform_device *pdev)
 #endif
 #ifdef CONFIG_SECURITYKEY
 	ret = extenal_api_key_set_version("auto3");
-	if (ret >=0) {
+	if(ret >=0){
 		ret = get_aml_key_kernel("keyexample", keyexamples, 1);
-		if (ret >= 0) {
+		if(ret >= 0){
 			printk("key name:keyexample, key data:%s\n",keyexamples);
 		}
 		else{
@@ -759,7 +754,7 @@ static int aml_rtc_probe(struct platform_device *pdev)
 
 	priv = (struct aml_rtc_priv *)kzalloc(sizeof(*priv), GFP_KERNEL);
 
-	if (!priv)
+	if(!priv)
 		return -ENOMEM;
 
 	INIT_WORK(&priv->work, reset_gpo_work);
@@ -778,7 +773,7 @@ static int aml_rtc_probe(struct platform_device *pdev)
 	priv->rtc = rtc_device_register("aml_rtc", &pdev->dev, &
 						aml_rtc_ops, THIS_MODULE);
 
-	if (IS_ERR(priv->rtc)) {
+	if(IS_ERR(priv->rtc)){
 		ret = PTR_ERR(priv->rtc);
 		goto out;
 	}
@@ -799,21 +794,16 @@ static int aml_rtc_probe(struct platform_device *pdev)
 	}
 
 	//check_osc_clk();
-	if (!board_has_battery() &&
-		RTC_INIT_MARSK != aml_read_rtc_mem_reg(3)) {
-		ser_access_write(RTC_COUNTER_ADDR, 0);
-		aml_write_rtc_mem_reg(3, RTC_INIT_MARSK);
-	}
-
+	//ser_access_write(RTC_COUNTER_ADDR, 0);
 	ret = class_register(&aml_rtc_class);
-	if (ret) {
+	if(ret){
 		printk(" class register nand_class fail!\n");
 	}
 
 	return 0;
 
 out:
-	if (priv->rtc_work_queue)
+	if(priv->rtc_work_queue)
 		destroy_workqueue(priv->rtc_work_queue);
 	kfree(priv);
 	return ret;
@@ -830,7 +820,7 @@ static int get_gpo_flag(void)
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
 	ret = !(data32 & (1 << 24));
 #else
-	ret = !!(data32 & (1 << 24));
+    ret = !!(data32 & (1 << 24));
 #endif
 
 	return ret;
@@ -866,9 +856,9 @@ EXPORT_SYMBOL(aml_write_rtc_mem_reg);
 
 unsigned int aml_get_rtc_counter(void)
 {
-	unsigned int val;
-	val = ser_access_read(RTC_COUNTER_ADDR);
-	return val;
+    unsigned int val;
+    val = ser_access_read(RTC_COUNTER_ADDR);
+    return val;
 }
 EXPORT_SYMBOL(aml_get_rtc_counter);
 
@@ -883,7 +873,7 @@ static void reset_gpo_work(struct work_struct *work)
 		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
 #endif
 		count--;
-		if (count <= 0) {
+		if(count <= 0) {
 			printk("error: can not reset gpo !\n");
 			//count = 5;
 			return;
@@ -910,7 +900,7 @@ static void aml_rtc_shutdown(struct platform_device *pdev)
 #else
 	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
 #endif
-//	return 0;
+//    return 0;
 }
 
 static int aml_rtc_remove(struct platform_device *dev)
@@ -960,7 +950,7 @@ static int  __init aml_rtc_init(void)
 
 static void __init aml_rtc_exit(void)
 {
-	return platform_driver_unregister(&aml_rtc_driver);
+       return platform_driver_unregister(&aml_rtc_driver);
 }
 
 module_init(aml_rtc_init);
