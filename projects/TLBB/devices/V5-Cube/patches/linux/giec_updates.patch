diff --git a/arch/arm/mach-meson8b/pm.c b/arch/arm/mach-meson8b/pm.c
old mode 100755
new mode 100644
index 8bfa282..72583eb
--- a/arch/arm/mach-meson8b/pm.c
+++ b/arch/arm/mach-meson8b/pm.c
@@ -47,6 +47,7 @@
 static struct early_suspend early_suspend;
 static int early_suspend_flag = 0;
 #endif
+#include <linux/amlogic/aml_gpio_consumer.h>
 
 #define CONFIG_AO_TRIG_CLK 1
 #ifdef CONFIG_AO_TRIG_CLK
@@ -59,6 +60,9 @@ static int early_suspend_flag = 0;
 static unsigned int  cec_config;       // 4 bytes: use to control cec switch on/off,distinguish between Mbox and Tablet. bit[0]:1:Mbox; 0:Tablet
 static struct meson_pm_config *pdata;
 static struct device_node *cec_np = NULL;
+static unsigned int power_led_sys;
+static unsigned int power_led_wake;
+static unsigned int power_3v3_5v_en;
 
 #define CLK(addr)  \
 { \
@@ -81,12 +85,11 @@ static void uart_change_buad(unsigned reg,unsigned clk_rate){
 	aml_clr_reg32_mask(reg, 0x7FFFFF);
 	aml_set_reg32_bits(reg, (((clk_rate / (115200 * 4)) - 1) & 0x7fffff)|(1<<23), 0, 24);
 }
-
 static void wait_uart_empty(void)
 {
 	do{
 		udelay(100);
-	}while((aml_read_reg32(P_AO_UART_STATUS) & (1<<22)) == 0);
+	}while((aml_read_reg32(P_AO_UART_STATUS) & (1<<22)) == 0);	
 }
 struct clk* clk81;
 struct clk* clkxtal;
@@ -106,16 +109,15 @@ void clk_switch(int flag)
 					udelay(10);
 					aml_set_reg32_mask(clks[i].clk_addr,(1<<8));//switch to pll
 					udelay(10);
-					if(!(aml_read_reg32(P_AO_UART_REG5) & (1 << 24)))//Not from crystal pad
-						uart_change_buad(P_AO_UART_REG5,uart_rate_clk);
+					uart_change_buad(P_AO_UART_REG5,uart_rate_clk);
 					clks[i].clk_flag = 0;
 				}
-			printk(KERN_INFO "clk %s(%x) on\n", clks[i].clk_name, ((clks[i].clk_addr)&0xffff)>>2);
+                	printk(KERN_INFO "clk %s(%x) on\n", clks[i].clk_name, ((clks[i].clk_addr)&0xffff)>>2);
 			}
 		}
 	} else {
 	        for (i = 0; i < clk_count; i++) {
-			if (clks[i].clk_addr == P_HHI_MPEG_CLK_CNTL) {
+	 		if (clks[i].clk_addr == P_HHI_MPEG_CLK_CNTL) {
 				if (aml_read_reg32(clks[i].clk_addr) & (1 << 8)) {
 					uart_rate_clk = clk_get_rate(clkxtal);
 					clks[i].clk_flag  = 1;
@@ -124,11 +126,10 @@ void clk_switch(int flag)
 					udelay(10);
 					aml_clr_reg32_mask(clks[i].clk_addr, (1 << 7)); // switch to 24M
 					udelay(10);
-					if(!(aml_read_reg32(P_AO_UART_REG5) & (1 << 24)))//Not from crystal pad
-						uart_change_buad(P_AO_UART_REG5,uart_rate_clk);
+					uart_change_buad(P_AO_UART_REG5,uart_rate_clk);
 					clks[i].clk_flag=1;
 				}
-			}
+			} 
 			if (clks[i].clk_flag) {
 				printk(KERN_INFO "clk %s(%x) off\n", clks[i].clk_name, ((clks[i].clk_addr)&0xffff)>>2);
 			}
@@ -175,7 +176,7 @@ void analog_switch(int flag)
         for (i = 0; i < ANALOG_COUNT; i++) {
             if (analog_regs[i].enable && (analog_regs[i].set_bits || analog_regs[i].clear_bits)) {
                 if (analog_regs[i].enable == 1) {
-				aml_write_reg32(analog_regs[i].reg_addr, analog_regs[i].reg_value);
+                		aml_write_reg32(analog_regs[i].reg_addr, analog_regs[i].reg_value);
                 } else if (analog_regs[i].enable == 2) {
                     aml_write_reg32(analog_regs[i].reg_addr, analog_regs[i].reg_value);
                 } else if (analog_regs[i].enable == 3) {
@@ -204,11 +205,11 @@ void analog_switch(int flag)
                     analog_regs[i].reg_value = aml_read_reg32(analog_regs[i].reg_addr);
                     printk("%s(0x%x):0x%x", analog_regs[i].name, analog_regs[i].reg_addr, analog_regs[i].reg_value);
                     if (analog_regs[i].clear_bits) {
-				aml_clr_reg32_mask(analog_regs[i].reg_addr, analog_regs[i].clear_bits);
+                    		aml_clr_reg32_mask(analog_regs[i].reg_addr, analog_regs[i].clear_bits);
                         printk(" & ~0x%x", analog_regs[i].clear_bits);
                     }
                     if (analog_regs[i].set_bits) {
-				aml_set_reg32_mask(analog_regs[i].reg_addr, analog_regs[i].set_bits);
+                    		aml_set_reg32_mask(analog_regs[i].reg_addr, analog_regs[i].set_bits);
                         printk(" | 0x%x", analog_regs[i].set_bits);
                     }
                     reg_value = aml_read_reg32(analog_regs[i].reg_addr);
@@ -243,6 +244,9 @@ static void meson_system_early_suspend(struct early_suspend *h)
 	}
 		//early_clk_switch(OFF);
 		//early_power_gate_switch(OFF);
+		if (pdata->set_vccx2) {
+			pdata->set_vccx2(OFF);
+	    }
 		early_suspend_flag = 1;
 	}
 }
@@ -253,133 +257,76 @@ static void meson_system_late_resume(struct early_suspend *h)
 		//early_power_gate_switch(ON);
 		//early_clk_switch(ON);
 		early_suspend_flag = 0;
+		if (pdata->set_vccx2) {
+			pdata->set_vccx2(ON);
+	    }
 		printk(KERN_INFO "%s\n",__func__);
 	}
 }
 #endif
 
 #ifdef CONFIG_AO_TRIG_CLK
-int run_arc_program_rtc(void)
-{
-	//int i;
-	unsigned v;
-
-	if (cec_config & 0x1)// 4 bytes: use to control cec switch on/off,distinguish between Mbox and Tablet. bit[0]:1:Mbox; 0:Tablet
-	{
-		aml_write_reg32(P_AO_REMAP_REG0,0);
-		udelay(10);
-
-		v = ((IO_SRAM_PHY_BASE & 0xFFFFF)>>12);
-#ifdef CONFIG_MESON_TRUSTZONE
-		meson_secure_reg_write(P_AO_SECURE_REG0, v<<8 | meson_secure_reg_read(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
-#else
-		aml_write_reg32(P_AO_SECURE_REG0, v<<8 | aml_read_reg32(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
-#endif
-
-		aml_write_reg32(P_AO_RTI_STATUS_REG1, 0);//clean status
-
-		//    	writel(0x200,P_AO_CPU_CNTL);//halt first
-		aml_write_reg32(P_RESET2_REGISTER, aml_read_reg32(P_RESET2_REGISTER)|(1<<13));//reset AO_CPU
-
-		udelay(10);
-
-		//      enable arc
-		aml_write_reg32(P_AO_CPU_CNTL, 0x0c900101);//remap is right?
-
-		udelay(20);
-		if (aml_read_reg32(P_AO_RTI_STATUS_REG1) == 0xeeeeaaaa) {
-			printk("AO cpu runs ok.\n");
-			return 0;
-		}
-		else{
-			printk("AO cpu runs fail. 0x%x\n",aml_read_reg32(P_AO_RTI_STATUS_REG1));
-			return -1;
-		}
-	}
-	return -1;
-}
-
 int run_arc_program(void)
 {
 //	int i;
 	unsigned vaddr2,v;
-#ifndef CONFIG_MESON_TRUSTZONE
 	unsigned* pbuffer;
-#endif
-
-#ifdef CONFIG_MESON_TRUSTZONE
-	int ret_val;
-	struct sram_hal_api_arg arg;
-
-	vaddr2 = IO_SRAM_PHY_BASE;
-#else
 	vaddr2 = IO_SRAM_BASE;
-#endif
-
+	
 	if(cec_config & 0x1)// 4 bytes: use to control cec switch on/off,distinguish between Mbox and Tablet. bit[0]:1:Mbox; 0:Tablet
-	{
-		aml_write_reg32(P_AO_REMAP_REG0,0);
-		udelay(10);
-
-
-#ifdef CONFIG_MESON_TRUSTZONE
-		arg.cmd = (unsigned int)TRUSTZONE_HAL_API_SRAM_WR_ADDR;
-		arg.req_len = sizeof(arc_code);
-		arg.res_len = sizeof(arc_code);
-		arg.req_phy_addr = vaddr2;
-		arg.res_phy_addr = virt_to_phys(arc_code);
-		arg.ret_phy_addr = virt_to_phys(&ret_val);
-		meson_secure_sram_copy(&arg);
-#else
-		pbuffer = (unsigned*)vaddr2;
-		memcpy(pbuffer,arc_code,sizeof(arc_code));//need not flush cache for sram. Sram locates at io mapping.
-#endif
-
-		//    	for(i = 0; i<sizeof(arc_code)/4; i+=4,pbuffer+=4)
-		//    		printk(" 0x%x	0x%x	0x%x	0x%x \n",*(pbuffer),*(pbuffer+1),*(pbuffer+2),*(pbuffer+3));
-		v = ((IO_SRAM_PHY_BASE & 0xFFFFF)>>12);
-#ifdef CONFIG_MESON_TRUSTZONE
-		meson_secure_reg_write(P_AO_SECURE_REG0, v<<8 | meson_secure_reg_read(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
-#else
-		aml_write_reg32(P_AO_SECURE_REG0, v<<8 | aml_read_reg32(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
-#endif
-
-		aml_write_reg32(P_AO_RTI_STATUS_REG1, 0);//clean status
-
-		//    	writel(0x200,P_AO_CPU_CNTL);//halt first
-		aml_write_reg32(P_RESET2_REGISTER, aml_read_reg32(P_RESET2_REGISTER)|(1<<13));//reset AO_CPU
-
-		udelay(10);
-		//      enable arc
-		aml_write_reg32(P_AO_CPU_CNTL, 0x0c900101);//remap is right?
-
-		udelay(20);
-		if (aml_read_reg32(P_AO_RTI_STATUS_REG1) == 0xeeeeaaaa) {
-			printk("AO cpu runs ok.\n");
-			return 0;
-		}
-		else {
-			printk("AO cpu runs fail. 0x%x\n",aml_read_reg32(P_AO_RTI_STATUS_REG1));
-			return -1;
-		}
-	}
-	return -1;
+    {
+    	aml_write_reg32(P_AO_REMAP_REG0,0);
+    	udelay(10);
+    	pbuffer = (unsigned*)vaddr2;
+    
+    	memcpy(pbuffer,arc_code,sizeof(arc_code));//need not flush cache for sram. Sram locates at io mapping.
+    
+//    	for(i = 0; i<sizeof(arc_code)/4; i+=4,pbuffer+=4)
+//    		printk(" 0x%x	0x%x	0x%x	0x%x \n",*(pbuffer),*(pbuffer+1),*(pbuffer+2),*(pbuffer+3));
+        v = ((IO_SRAM_PHY_BASE & 0xFFFFF)>>12);
+    #ifdef CONFIG_MESON_TRUSTZONE
+	    meson_secure_reg_write(P_AO_SECURE_REG0, v<<8 | meson_secure_reg_read(P_AO_SECURE_REG0));
+    #else
+        aml_write_reg32(P_AO_SECURE_REG0, v<<8 | aml_read_reg32(P_AO_SECURE_REG0)); //TEST_N : 1->output mode; 0->input mode
+    #endif
+    
+        aml_write_reg32(P_AO_RTI_STATUS_REG1, 0);//clean status
+    
+//    	writel(0x200,P_AO_CPU_CNTL);//halt first
+    	aml_write_reg32(P_RESET2_REGISTER, aml_read_reg32(P_RESET2_REGISTER)|(1<<13));//reset AO_CPU
+    
+    	udelay(10);
+    
+//      enable arc
+        aml_write_reg32(P_AO_CPU_CNTL, 0x0c900101);//remap is right?
+    
+    	udelay(20);
+    	if(aml_read_reg32(P_AO_RTI_STATUS_REG1) == 0xeeeeaaaa){
+    		printk("AO cpu runs ok.\n");
+    		return 0;
+    	}
+    	else{
+    		printk("AO cpu runs fail. 0x%x\n",aml_read_reg32(P_AO_RTI_STATUS_REG1));
+    		return -1;
+    	}
+    }
+    return -1;
 }
 
 int stop_ao_cpu(void)
 {
 	if(cec_config & 0x1)// 4 bytes: use to control cec switch on/off,distinguish between Mbox and Tablet. bit[0]:1:Mbox; 0:Tablet
     {
-	aml_write_reg32(P_AO_RTI_STATUS_REG1, 0xddddeeee); //ask ao to halt.
+    	aml_write_reg32(P_AO_RTI_STATUS_REG1, 0xddddeeee); //ask ao to halt.
 		udelay(40);
-	if(aml_read_reg32(P_AO_RTI_STATUS_REG1) == 0x0){
-		printk("AO cpu stop ok.\n");
-		return 0;
-	}
-	else{
-		printk("AO cpu stop fail.\n");
-		return -1;
-	}
+    	if(aml_read_reg32(P_AO_RTI_STATUS_REG1) == 0x0){
+    		printk("AO cpu stop ok.\n");
+    		return 0;
+    	}
+    	else{
+    		printk("AO cpu stop fail.\n");
+    		return -1;
+    	}
     }
     return -1;
 }
@@ -387,13 +334,17 @@ int stop_ao_cpu(void)
 
 extern int det_pwr_key(void);
 extern void clr_pwr_key(void);
+#ifdef CONFIG_SCREEN_ON_EARLY
+int power_key_pressed;
+EXPORT_SYMBOL(power_key_pressed);
+#endif
 
 static void meson_pm_suspend(void)
 {
 	printk(KERN_INFO "enter meson_pm_suspend!\n");
 #ifdef CONFIG_SUSPEND_WATCHDOG
 	ENABLE_SUSPEND_WATCHDOG;
-#endif
+#endif    
 
 #ifdef CONFIG_AO_TRIG_CLK
 	stop_ao_cpu();
@@ -404,7 +355,7 @@ static void meson_pm_suspend(void)
 	}
 
 	clk_switch(OFF);
-	//power_gate_switch(OFF);
+	//power_gate_switch(OFF);	
 	//switch_mod_gate_by_type(MOD_MEDIA_CPU, 1);
 	printk(KERN_INFO "sleep ...\n");
 	//switch A9 clock to xtal 24MHz
@@ -466,6 +417,12 @@ static void meson_pm_suspend(void)
 #ifdef CONFIG_AO_TRIG_CLK
 	run_arc_program();
 #endif
+
+	#ifdef CONFIG_SCREEN_ON_EARLY
+    if (READ_AOBUS_REG(AO_RTI_STATUS_REG2) == FLAG_WAKEUP_PWRKEY) {
+        power_key_pressed = 1;
+    }
+	#endif
 }
 
 static int meson_pm_prepare(void)
@@ -504,12 +461,19 @@ static void m6ref_set_vccx2(int power_on)
 {
     if(power_on == OFF) {
         printk("m6ref_set_vccx2: OFF");
-        CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<15);
-        SET_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<31);
+        //CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<15);
+        //SET_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<31);
+		//amlogic_gpio_direction_output(power_led_sys, 1, "POWER_LED_SYS");
+		//amlogic_gpio_direction_output(power_led_wake, 1, "POWER_LED_WAKE");
+        amlogic_gpio_direction_output(power_3v3_5v_en, 1, "POWER_3V3_5V_EN");
     } else {
         printk("m6ref_set_vccx2: ON");
-        CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<15);
-        CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<31);
+        //CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<15);
+        //CLEAR_AOBUS_REG_MASK(AO_GPIO_O_EN_N, 1<<31);
+		//amlogic_gpio_direction_output(power_led_sys, 0, "POWER_LED_SYS");
+		aml_clr_reg32_mask(P_AO_RTI_PIN_MUX_REG, ((1<<31)|(1<<13)|(1<<3))); //Giec wuxutao 20151208 added for suspend led breath
+		amlogic_gpio_direction_output(power_led_wake, 0, "POWER_LED_WAKE");
+        amlogic_gpio_direction_output(power_3v3_5v_en, 0, "POWER_3V3_5V_EN");
     }
     return;
 }
@@ -541,10 +505,20 @@ static int __init meson_pm_probe(struct platform_device *pdev)
 		return -ENOENT;
 	}
 	suspend_set_ops(&meson_pm_ops);
-
+	
+	//set gpioy_10 as gpio
+	power_led_sys= amlogic_gpio_name_map_num("GPIOAO_13");
+	amlogic_gpio_request(power_led_sys, "POWER_LED_SYS");
+	//set gpioy_11 as gpio
+	power_led_wake= amlogic_gpio_name_map_num("GPIOAO_2");
+	amlogic_gpio_request(power_led_wake, "POWER_LED_WAKE");
+    //set gpiodv_29 as gpio
+    power_3v3_5v_en = amlogic_gpio_name_map_num("GPIODV_29");
+    amlogic_gpio_request(power_3v3_5v_en, "POWER_3V3_5V_EN");
+	
 	clk81 = clk_get_sys("clk81", NULL);
 	clkxtal = clk_get_sys("xtal", NULL);
-
+	
 	cec_np = of_find_node_by_name(NULL, "vend_data");
 	if(cec_np){
 	    if(of_property_read_u32(cec_np, "cec_config", &cec_config))
@@ -555,7 +529,7 @@ static int __init meson_pm_probe(struct platform_device *pdev)
 	    cec_config = 0x0;
 	}
     printk("hdmi: cec_pm: cec config:0x%x\n", cec_config);
-
+    
 	printk(KERN_INFO "meson_pm_probe done !\n");
 
 #ifdef CONFIG_AO_TRIG_CLK
@@ -596,3 +570,4 @@ static int __init meson_pm_init(void)
 	return platform_driver_probe(&meson_pm_driver, meson_pm_probe);
 }
 late_initcall(meson_pm_init);
+
diff --git a/drivers/amlogic/ethernet/am_net8218.c b/drivers/amlogic/ethernet/am_net8218.c
index cc8cf72..73a324d 100755
--- a/drivers/amlogic/ethernet/am_net8218.c
+++ b/drivers/amlogic/ethernet/am_net8218.c
@@ -1699,8 +1699,8 @@ static int __init mac_addr_set(char *line)
 	return 1;
 }
 
-__setup("mac=", mac_addr_set);
-
+//__setup("mac=", mac_addr_set);
+__setup("androidboot.mac=", mac_addr_set);//GIEC wuxutao 20151014 modified for bug 234  (usb boardtest)
 
 /* --------------------------------------------------------------------------*/
 /**
diff --git a/drivers/amlogic/input/new_remote/Kconfig b/drivers/amlogic/input/new_remote/Kconfig
old mode 100755
new mode 100644
diff --git a/drivers/amlogic/input/new_remote/Makefile b/drivers/amlogic/input/new_remote/Makefile
old mode 100755
new mode 100644
diff --git a/drivers/amlogic/input/new_remote/aml.dtd b/drivers/amlogic/input/new_remote/aml.dtd
old mode 100755
new mode 100644
diff --git a/drivers/amlogic/input/new_remote/irblaster.c b/drivers/amlogic/input/new_remote/irblaster.c
old mode 100755
new mode 100644
index 963c6e8..dc52959
--- a/drivers/amlogic/input/new_remote/irblaster.c
+++ b/drivers/amlogic/input/new_remote/irblaster.c
@@ -68,27 +68,27 @@ static void send_all_frame(struct blaster_window * creat_window){
 	// set init_high valid and enable the ir_blaster
 	irblaster_dbg("Enable the ir_blaster, and create a new format !! \n");
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR0, aml_read_reg32(P_AO_IR_BLASTER_ADDR0)| (2<<12));     //set the modulator_tb = 2'10; 1us
-	aml_write_reg32( P_AO_IR_BLASTER_ADDR1, aml_read_reg32(P_AO_IR_BLASTER_ADDR1)| (12<<16));    //set mod_high_count = 13;
+	aml_write_reg32( P_AO_IR_BLASTER_ADDR1, aml_read_reg32(P_AO_IR_BLASTER_ADDR1)| (12<<16));    //set mod_high_count = 13;  
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR1, aml_read_reg32(P_AO_IR_BLASTER_ADDR1)| (12<<0));     //set mod_low_count = 13;
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR0, aml_read_reg32(P_AO_IR_BLASTER_ADDR0)| (1<<2) | (1<<0));
 	udelay(1);
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR0, aml_read_reg32(P_AO_IR_BLASTER_ADDR0)| (1<<2) | (1<<0));
-		k = creat_window->winNum;
+		k = creat_window->winNum;	
 	if(creat_window->winNum){
 		for(i =0; i < k/2; i++){
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))    //timeleve = 0;
-					| (3<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+					| (3<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 			//		| ((((creat_window->winArray[2*i])*10-1)/26)<<0)    //[9:0] = 10'd,the timecount = N+1;
 					| (((((creat_window->winArray[2*i])*10-1)*38)/1000)<<0)    //[9:0] = 10'd,the timecount = N+1;
 				       );
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000  | (1<<12))     //timeleve = 1;
-					| (1<<10)     //[11:10] = 2'b11,then set the timebase 26.5us.
+					| (1<<10)     //[11:10] = 2'b11,then set the timebase 26.5us. 
 					| ((((creat_window->winArray[2*i+1])-1))<<0)     //[9:0] = 10'd,the timecount = N+1;
 				//	| ((((creat_window->winArray[2*i+1])-1))<<0)     //[9:0] = 10'd,the timecount = N+1;
 				       );
-		}
+		}                                        
 	}
-	irblaster_dbg("The all frame finished !!\n");
+	irblaster_dbg("The all frame finished !!\n");    
 
 }
 #if 0
@@ -102,35 +102,35 @@ static void send_nec_frame(struct blaster_window * creat_window){
 	if(creat_window->winNum){
 		irblaster_dbg("Create a 9ms low pulse\n");
 		aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))    //timeleve = 0;
-				| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+				| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 				| (899<<0)    //[9:0] = 10'd899,the timecount = N+1;
 			       );
 		irblaster_dbg("Create a 4.5ms high pulse\n");
 		aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000  | (1<<12))     //timeleve = 1;
-				| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+				| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 				| (449<<0)    //[9:0] = 10'd449,the timecount = N+1;
 			       );
-		udelay(1);
+		udelay(1);                                                    
 		for(i =0; i<creat_window->winNum;i++) {
 			if (creat_window->winArray[i] != 1) {
 				aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))    //timeleve = 0;
-						| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+						| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 						| (55<<0)     //[9:0] = 10'd55,the timecount = N+1;
 					       );
 
 				aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 | (1<<12))     //timeleve = 1;
-						| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+						| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 						| (55<<0)     //[9:0] = 10'd55,the timecount = N+1;
-					       );
+					       ); 
 			}
 			else {
 				aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))    //timeleve = 0;
-						| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+						| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 						| (55<<0)    //[9:0] = 10'd449,the timecount = N+1;
 					       );
 
 				aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 | (1<<12))     //timeleve = 1;
-						| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+						| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 						| (167<<0)    //[9:0] = 10'd449,the timecount = N+1;
 					       );
 			}
@@ -140,17 +140,17 @@ static void send_nec_frame(struct blaster_window * creat_window){
 		// if creat_window.winNum =  this is  repeat.
 		irblaster_dbg("Create a 9ms low pulse\n");
 		aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))    //timeleve = 0;
-				| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+				| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 				| (899<<0)    //[9:0] = 10'd899,the timecount = N+1;
 			       );
 		irblaster_dbg("Create a 2.5ms high pulse\n");
 		aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000  | (1<<12))     //timeleve = 1;
-				| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+				| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 				| (249<<0)    //[9:0] = 10'd449,the timecount = N+1;
 			       );
-		udelay(1);
+		udelay(1);          
 	}
-	irblaster_dbg("The NEC frame finished !!\n");
+	irblaster_dbg("The NEC frame finished !!\n");    
 
 }
 static void send_sony_frame(struct blaster_window *creat_window){
@@ -164,7 +164,7 @@ static void send_sony_frame(struct blaster_window *creat_window){
 	// -----------------------------------------------
 	irblaster_dbg("Configure the parameter of modulator !! \n");
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR0, aml_read_reg32(P_AO_IR_BLASTER_ADDR0)| (1<<12));     //set the modulator_tb = 2'01;
-	aml_write_reg32( P_AO_IR_BLASTER_ADDR1, aml_read_reg32(P_AO_IR_BLASTER_ADDR1)| (34<<16));    //set mod_high_count = 34;
+	aml_write_reg32( P_AO_IR_BLASTER_ADDR1, aml_read_reg32(P_AO_IR_BLASTER_ADDR1)| (34<<16));    //set mod_high_count = 34;  
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR1, aml_read_reg32(P_AO_IR_BLASTER_ADDR1)| (34<<0));     //set mod_low_count = 34;
 
 	// -----------------------------------------------
@@ -172,36 +172,36 @@ static void send_sony_frame(struct blaster_window *creat_window){
 	// -----------------------------------------------
 	irblaster_dbg("Create a 2.4ms pulse\n");
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))     //timeleve = 0;
-			| (3<<10)       //[11:10] = 2'b01,then set the timebase 10us.
+			| (3<<10)       //[11:10] = 2'b01,then set the timebase 10us. 
 			| (273<<0)      //[9:0] = 10'd899,the timecount = N+1;
 		       );
 
 	for(i =0; i<creat_window->winNum;i++) {
 		if (creat_window->winArray[i] != 1) {
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))     //timeleve = 0;
-					| (1<<10)       //[11:10] = 2'b01,then set the timebase 10us.
+					| (1<<10)       //[11:10] = 2'b01,then set the timebase 10us. 
 					| (59<<0)       //[9:0] = 10'd59,the timecount = N+1;
 				       );
 
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 | (1<<12))      //timeleve = 1;
-					| (3<<10)       //[11:10] = 2'b01,then set the timebase 10us.
+					| (3<<10)       //[11:10] = 2'b01,then set the timebase 10us. 
 					| (68<<0)       //[9:0] = 10'd68,the timecount = N+1;
-				       );
+				       ); 
 		}
 		else {
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))    //timeleve = 0;
-					| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+					| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 					| (59<<0)    //[9:0] = 10'd59,the timecount = N+1;
 				       );
 
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 | (1<<12))     //timeleve = 1;
-					| (3<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+					| (3<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 					| (136<<0)    //[9:0] = 10'd449,the timecount = N+1;
 				       );
 		}
 	}
 
-	irblaster_dbg("The SONY frame finished !!\n");
+	irblaster_dbg("The SONY frame finished !!\n");    
 
 }
 static void send_duokan_frame(struct blaster_window *creat_window){
@@ -215,7 +215,7 @@ static void send_duokan_frame(struct blaster_window *creat_window){
 	// -----------------------------------------------
 	irblaster_dbg("Configure the parameter of modulator !! \n");
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR0, aml_read_reg32(P_AO_IR_BLASTER_ADDR0)| (1<<12));     //set the modulator_tb = 2'01;
-	aml_write_reg32( P_AO_IR_BLASTER_ADDR1, aml_read_reg32(P_AO_IR_BLASTER_ADDR1)| (34<<16));    //set mod_high_count = 34;
+	aml_write_reg32( P_AO_IR_BLASTER_ADDR1, aml_read_reg32(P_AO_IR_BLASTER_ADDR1)| (34<<16));    //set mod_high_count = 34;  
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR1, aml_read_reg32(P_AO_IR_BLASTER_ADDR1)| (34<<0));     //set mod_low_count = 34;
 
 	// -----------------------------------------------
@@ -223,36 +223,36 @@ static void send_duokan_frame(struct blaster_window *creat_window){
 	// -----------------------------------------------
 	irblaster_dbg("Create a 2.4ms pulse\n");
 	aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))     //timeleve = 0;
-			| (3<<10)       //[11:10] = 2'b01,then set the timebase 10us.
+			| (3<<10)       //[11:10] = 2'b01,then set the timebase 10us. 
 			| (273<<0)      //[9:0] = 10'd899,the timecount = N+1;
 		       );
 
 	for(i =0; i<creat_window->winNum;i++) {
 		if (creat_window->winArray[i] != 1) {
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))     //timeleve = 0;
-					| (1<<10)       //[11:10] = 2'b01,then set the timebase 10us.
+					| (1<<10)       //[11:10] = 2'b01,then set the timebase 10us. 
 					| (59<<0)       //[9:0] = 10'd59,the timecount = N+1;
 				       );
 
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 | (1<<12))      //timeleve = 1;
-					| (3<<10)       //[11:10] = 2'b01,then set the timebase 10us.
+					| (3<<10)       //[11:10] = 2'b01,then set the timebase 10us. 
 					| (68<<0)       //[9:0] = 10'd68,the timecount = N+1;
-				       );
+				       ); 
 		}
 		else {
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 & ~(1<<12))    //timeleve = 0;
-					| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+					| (1<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 					| (59<<0)    //[9:0] = 10'd59,the timecount = N+1;
 				       );
 
 			aml_write_reg32( P_AO_IR_BLASTER_ADDR2, (0x10000 | (1<<12))     //timeleve = 1;
-					| (3<<10)     //[11:10] = 2'b01,then set the timebase 10us.
+					| (3<<10)     //[11:10] = 2'b01,then set the timebase 10us. 
 					| (136<<0)    //[9:0] = 10'd449,the timecount = N+1;
 				       );
 		}
 	}
 
-	irblaster_dbg("The SONY frame finished !!\n");
+	irblaster_dbg("The SONY frame finished !!\n");    
 
 }
 
@@ -429,7 +429,7 @@ static void ir_hardware_release(void)
 static int  aml_ir_irblaster_probe(struct platform_device *pdev)
 {
 	int r;
-	printk("ir irblaster probe\n");
+	printk("ir irblaster probe\n");	
 	r = alloc_chrdev_region(&irblaster_id, 0, DEIVE_COUNT, DEVICE_NAME);
 	if (r < 0) {
 		printk(KERN_ERR "Can't register major for ir irblaster device\n");
@@ -491,7 +491,7 @@ static struct platform_driver aml_ir_irblaster_driver = {
 	.driver = {
 		.name = "meson-irblaster",
 		.owner  = THIS_MODULE,
-		.of_match_table = irblaster_dt_match,
+		.of_match_table = irblaster_dt_match,	
 	},
 };
 
diff --git a/drivers/amlogic/input/new_remote/irblaster.h b/drivers/amlogic/input/new_remote/irblaster.h
old mode 100755
new mode 100644
index 46d0546..2fad5db
--- a/drivers/amlogic/input/new_remote/irblaster.h
+++ b/drivers/amlogic/input/new_remote/irblaster.h
@@ -1,33 +1,33 @@
-#ifndef IRBLASTER_H
-#define IRBLASTER_H
-#define MAX_PLUSE 1024
-struct blaster_window {
+#ifndef IRBLASTER_H
+#define IRBLASTER_H
+#define MAX_PLUSE 1024
+struct blaster_window {
     unsigned int winNum;
     unsigned int winArray[MAX_PLUSE];
-};
-#define MAX_PLUSE 1024
-#define AM_IR_DEC_LDR_ACTIVE 0x0
-#define AM_IR_DEC_LDR_IDLE 0x4
-#define AM_IR_DEC_LDR_REPEAT 0x8
-#define AM_IR_DEC_BIT_0     0xc
-#define AM_IR_DEC_REG0 0x10
-#define AM_IR_DEC_FRAME 0x14
-#define AM_IR_DEC_STATUS 0x18
-#define AM_IR_DEC_REG1 0x1c
-unsigned int ir_g_remote_base = P_AO_IR_DEC_LDR_ACTIVE;
-#define am_remote_write_reg(x,val) aml_write_reg32(ir_g_remote_base +x ,val)
-
-#define am_remote_read_reg(x) aml_read_reg32(ir_g_remote_base +x)
-
-#define am_remote_set_mask(x,val) aml_set_reg32_mask(ir_g_remote_base +x,val)
-
-#define am_remote_clear_mask(x,val) aml_clr_reg32_mask(ir_g_remote_base +x,val)
-
-#define IRRECEIVER_IOC_SEND     0x5500
-#define IRRECEIVER_IOC_RECV     0x5501
-#define IRRECEIVER_IOC_STUDY_S  0x5502
-#define IRRECEIVER_IOC_STUDY_E  0x5503
-#define GET_NUM_CARRIER         0x5504
-#define SET_NUM_CARRIER         0x5505
-
-#endif
+};
+#define MAX_PLUSE 1024
+#define AM_IR_DEC_LDR_ACTIVE 0x0
+#define AM_IR_DEC_LDR_IDLE 0x4
+#define AM_IR_DEC_LDR_REPEAT 0x8
+#define AM_IR_DEC_BIT_0     0xc
+#define AM_IR_DEC_REG0 0x10
+#define AM_IR_DEC_FRAME 0x14
+#define AM_IR_DEC_STATUS 0x18
+#define AM_IR_DEC_REG1 0x1c
+unsigned int ir_g_remote_base = P_AO_IR_DEC_LDR_ACTIVE;
+#define am_remote_write_reg(x,val) aml_write_reg32(ir_g_remote_base +x ,val)
+
+#define am_remote_read_reg(x) aml_read_reg32(ir_g_remote_base +x)
+
+#define am_remote_set_mask(x,val) aml_set_reg32_mask(ir_g_remote_base +x,val)
+
+#define am_remote_clear_mask(x,val) aml_clr_reg32_mask(ir_g_remote_base +x,val)
+
+#define IRRECEIVER_IOC_SEND     0x5500
+#define IRRECEIVER_IOC_RECV     0x5501
+#define IRRECEIVER_IOC_STUDY_S  0x5502
+#define IRRECEIVER_IOC_STUDY_E  0x5503
+#define GET_NUM_CARRIER         0x5504
+#define SET_NUM_CARRIER         0x5505
+
+#endif 
diff --git a/drivers/amlogic/input/new_remote/remote_func.c b/drivers/amlogic/input/new_remote/remote_func.c
old mode 100755
new mode 100644
index e36e272..98c966f
--- a/drivers/amlogic/input/new_remote/remote_func.c
+++ b/drivers/amlogic/input/new_remote/remote_func.c
@@ -35,8 +35,6 @@ static const remotereg_t *remoteregsTab[] = {
 	RDECODEMODE_SANYO,
 	RDECODEMODE_SKIPLEADER,
 	RDECODEMODE_SW,
-	RDECODEMODE_NEC_RCA_2IN1,
-	RDECODEMODE_NEC_TOSHIBA_2IN1,
 	RDECODEMODE_SW_NEC,
 	NULL,
 	RDECODEMODE_SW_DUOKAN
@@ -45,7 +43,6 @@ extern char *remote_log_buf;
 static int auto_repeat_count,repeat_count = 0;
 static void remote_rel_timer_sr(unsigned long data);
 static void remote_repeat_sr(unsigned long data);
-static void remote_rca_repeat_sr(unsigned long data);
 static int dbg_printk(const char *fmt, ...)
 {
 	char buf[100];
@@ -60,8 +57,7 @@ static int dbg_printk(const char *fmt, ...)
 	va_end(args);
 	return 0;
 }
-int set_remote_mode(int mode)
-{
+int set_remote_mode(int mode){
 	const remotereg_t *reg;
 	reg = remoteregsTab[mode];
 	while(CONFIG_END != reg->reg)
@@ -75,14 +71,13 @@ void setremotereg(const remotereg_t *r)
 	am_remote_write_reg(r->reg, r->val);
 	printk("[0x%x] = 0x%x\n", r->reg, r->val);
 }
-void config_sw_init_window(struct remote *remote_data)
-{
-	switch(remote_data->work_mode) {
+void config_sw_init_window(struct remote *remote_data){
+	switch(remote_data->work_mode){
 		case DECODEMODE_SW_NEC:
 			remote_data->bit_count = 32;
 			remote_data->debug_enable = 1;
-			remote_data->release_delay[remote_data->map_num]  = 108;
-			remote_data->repeat_enable  = 0;
+			remote_data->release_delay = 108;
+			remote_data->repeat_enable = 0;
 			remote_data->time_window[0] = 500;
 			remote_data->time_window[1] = 700;
 			remote_data->time_window[2] = 50;
@@ -120,89 +115,41 @@ void kdb_send_key(struct input_dev *dev, unsigned int scancode,
 
 void set_remote_init(struct remote *remote_data)
 {
-	if(remote_data->work_mode <= DECODEMODE_MAX) {
-		if(remote_data->work_mode > DECODEMODE_NEC) {
-			if(remote_data->work_mode == DECODEMODE_NEC_RCA_2IN1)
-				setup_timer(&remote_data->repeat_timer, remote_rca_repeat_sr, 0);
-			else
-				setup_timer(&remote_data->repeat_timer, remote_repeat_sr, 0);
+	if(remote_data->work_mode <= DECODEMODE_MAX){
+		if(remote_data->work_mode > DECODEMODE_NEC){
+			setup_timer(&remote_data->repeat_timer, remote_repeat_sr, 0);
 			printk("enter in sw repeat mode \n");
 		}
 		return ;
 	}
 	config_sw_init_window(remote_data);
 }
-void changeduokandecodeorder(struct remote *remote_data)
-{
+void changeduokandecodeorder(struct remote *remote_data){
 	unsigned int scancode = remote_data->cur_lsbkeycode;
 	remote_data->cur_lsbkeycode =((scancode&0x3)<<18)|((scancode&0xc)<<14)|((scancode&0x30)<<10)|\
-				     ((scancode&0xc0)<<6)|((scancode&0x300)<<2)|((scancode&0xc00)>>2)|((scancode&0x3000)>>6)|\
-				     ((scancode&0xc000)>>10)|((scancode&0x30000)>>14)|((scancode&0xc0000)>>18);
+	((scancode&0xc0)<<6)|((scancode&0x300)<<2)|((scancode&0xc00)>>2)|((scancode&0x3000)>>6)|\
+	((scancode&0xc000)>>10)|((scancode&0x30000)>>14)|((scancode&0xc0000)>>18);
 	if(remote_data->cur_lsbkeycode == 0x0003cccf)
-		remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
+			remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
 }
-void get_cur_scancode(struct remote *remote_data)
-{
-	int temp_cur_lsbkeycode =0;
-	if(remote_data->work_mode== DECODEMODE_SANYO) {
+void get_cur_scancode(struct remote *remote_data){
+	if(remote_data->work_mode== DECODEMODE_SANYO){
 		remote_data->cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
 		remote_data->cur_msbkeycode = am_remote_read_reg(FRAME_BODY1)&0x2ff;
-	} else if(remote_data->work_mode ==  DECODEMODE_NEC_RCA_2IN1) {
-		if((temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY)) != 0) { //new
-			remote_data->temp_work_mode = DECODEMODE_RCA;
-			remote_data->cur_lsbkeycode = temp_cur_lsbkeycode;
-			temp_cur_lsbkeycode = 0;
-		}
-		if((am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100)>>3&0x1) && (temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY-0x100)) != 0 ) { //old
-			remote_data->temp_work_mode = DECODEMODE_NEC;
-			remote_data->cur_lsbkeycode =  temp_cur_lsbkeycode;
-			temp_cur_lsbkeycode = 0;
-		}
-	} else if(remote_data->work_mode ==  DECODEMODE_NEC_TOSHIBA_2IN1) {
-		temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
-		if(temp_cur_lsbkeycode != 0) { //new
-			remote_data->temp_work_mode = DECODEMODE_TOSHIBA;
-			remote_data->cur_lsbkeycode = temp_cur_lsbkeycode;
-			temp_cur_lsbkeycode = 0;
-		}
-		if((am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100)>>3&0x1) && (temp_cur_lsbkeycode = am_remote_read_reg(FRAME_BODY-0x100)) != 0 ) { //old
-			remote_data->temp_work_mode = DECODEMODE_NEC;
-			remote_data->cur_lsbkeycode =  temp_cur_lsbkeycode;
-			temp_cur_lsbkeycode = 0;
-		}
-	} else if(remote_data->work_mode > DECODEMODE_MAX) {
+	}
+	else if(remote_data->work_mode > DECODEMODE_MAX){
 		remote_data->cur_lsbkeycode = remote_data->cur_keycode;
 		if(remote_data->work_mode == DECODEMODE_SW_DUOKAN )
 			changeduokandecodeorder(remote_data);
-	} else {
+	}
+	else{
 		remote_data->cur_lsbkeycode = am_remote_read_reg(FRAME_BODY);
 	}
 
 }
-void get_cur_scanstatus(struct remote *remote_data)
-{
-	if(remote_data->work_mode ==  DECODEMODE_NEC_RCA_2IN1) {
-		if(remote_data->temp_work_mode == DECODEMODE_RCA) {
-			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
-		}
-		if(remote_data->temp_work_mode == DECODEMODE_NEC) {
-			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100);
-
-		}
-	} else if(remote_data->work_mode ==  DECODEMODE_NEC_TOSHIBA_2IN1) {
-		if(remote_data->temp_work_mode == DECODEMODE_TOSHIBA) {
-			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
-			if(remote_data->cur_lsbkeycode == 0x1 || remote_data->cur_lsbkeycode == 0x0) {
-				remote_data->frame_status = 0x1;
-				remote_data->cur_lsbkeycode =  0x0;
-			}
+void get_cur_scanstatus(struct remote *remote_data){
 
-		}
-		if(remote_data->temp_work_mode == DECODEMODE_NEC) {
-			remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS-0x100);
-		}
-	} else
-		remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
+	remote_data->frame_status = am_remote_read_reg(DURATION_REG1_AND_STATUS);
 
 }
 /*
@@ -224,19 +171,18 @@ void get_cur_scanstatus(struct remote *remote_data)
    DECODEMODE_SANYO,
    DECODEMODE_MAX*/
 
-unsigned int COMCAST_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int COMCAST_DOMAIN(struct remote *remote_data,int domain){
 	return (remote_data->cur_keycode &0xff);
 }
 /*SANYO frame body
-  Leader + 13bit Address + 13bit (~Address) + 8bit Data + 8bit (~Data)
+  Leader + 13bit Address + 13bit (~Address) + 8bit Data + 8bit (~Data)   
  */
-unsigned int SANYO_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain) {
+unsigned int SANYO_DOMAIN(struct remote *remote_data,int domain){
+	if(domain){
 		remote_data->frame_mode = 0;
 		return ((remote_data->cur_lsbkeycode >>8) &0xff);
-	} else {
+	}
+	else{
 		remote_data->frame_mode = 0;
 		return (((remote_data->cur_lsbkeycode >>29) &0x7) | ((remote_data->cur_msbkeycode<<3)&0x1fff));
 	}
@@ -245,11 +191,10 @@ unsigned int SANYO_DOMAIN(struct remote *remote_data,int domain)
 
 
  */
-unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain) {
-		if(((remote_data->cur_lsbkeycode>>12)&0xfff)) {
-			switch((remote_data->cur_lsbkeycode>>20)&0xf) {
+unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain){
+	if(domain){
+		if(((remote_data->cur_lsbkeycode>>12)&0xfff)){
+			switch((remote_data->cur_lsbkeycode>>20)&0xf){
 				case 0x0://OEM mode
 					remote_data->frame_mode = 0;
 					return (remote_data->cur_lsbkeycode &0xff);
@@ -262,10 +207,11 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
 				case 0x3://Extended Game pad mode
 					remote_data->frame_mode = 3;
 					break;
-			}
+			}	
 			return (remote_data->cur_lsbkeycode &0xfffff);
-		} else {
-			switch((remote_data->cur_lsbkeycode>>10)&0x3) {
+		}
+		else{
+			switch((remote_data->cur_lsbkeycode>>10)&0x3){
 				case 0x0://OEM mode
 					remote_data->frame_mode = 0;
 					return (remote_data->cur_lsbkeycode &0xff);
@@ -281,9 +227,10 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
 			}
 			return (remote_data->cur_lsbkeycode &0xff);
 		}
-	} else {
-		if(((remote_data->cur_lsbkeycode>>12)&0xfff)) {
-			switch((remote_data->cur_lsbkeycode>>20)&0xf) {
+	}
+	else{
+		if(((remote_data->cur_lsbkeycode>>12)&0xfff)){
+			switch((remote_data->cur_lsbkeycode>>20)&0xf){
 				case 0x0://OEM mode
 					remote_data->frame_mode = 0;
 					return ((remote_data->cur_lsbkeycode>>12) &0x3f);
@@ -296,10 +243,11 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
 				case 0x3://Extended Game pad mode
 					remote_data->frame_mode = 3;
 					break;
-			}
+			}	
 			return 0;
-		} else {
-			switch((remote_data->cur_lsbkeycode>>20)&0xf) {
+		}
+		else{
+			switch((remote_data->cur_lsbkeycode>>20)&0xf){
 				case 0x0://Extended mode
 					remote_data->frame_mode = 0;
 				case 0x1://Extended Mouse mode
@@ -312,155 +260,118 @@ unsigned int RCMM_DOMAIN(struct remote *remote_data,int domain)
 					remote_data->frame_mode = 3;
 					break;
 			}
-			return ((remote_data->cur_lsbkeycode>>8) &0x3);
+			return ((remote_data->cur_lsbkeycode>>8) &0x3); 
 		}
 	}
 
 }
 /*
-   8 bit address and 8 bit command length
-   Address and command are transmitted twice for reliability
-   Pulse distance modulation
-   Carrier frequency of 38kHz
-   Bit time of 1.125ms or 2.25ms
+   8 bit address and 8 bit command length 
+   Address and command are transmitted twice for reliability 
+   Pulse distance modulation 
+   Carrier frequency of 38kHz 
+   Bit time of 1.125ms or 2.25ms 
    NEC frame body
-   C15 ~ C8      C7 ~ C0    D15~D8      D7~D0
-   Header    ~Custom code   Custom code    Data Code ~Data Code
+	C15 ~ C8      C7 ~ C0    D15~D8      D7~D0
+	Header    ~Custom code   Custom code    Data Code ~Data Code
  */
-unsigned int NEC_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain) {
+unsigned int NEC_DOMAIN(struct remote *remote_data,int domain){
+	if(domain) 
 		return ((remote_data->cur_lsbkeycode >>16) &0xff);//D15 ~ D8
-	} else {
+	else 
 		return ((remote_data->cur_lsbkeycode) &0xffff);// C7 ~ C0
-	}
 }
 /*
-   8 bit address and 8 bit command length
-   Pulse distance modulation
-   Carrier frequency of 38kHz
-   Bit time of 1ms or 2ms
+   8 bit address and 8 bit command length 
+   Pulse distance modulation 
+   Carrier frequency of 38kHz 
+   Bit time of 1ms or 2ms 
  */
-unsigned int MITSUBISHI_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int MITSUBISHI_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
 		return (remote_data->cur_keycode & 0xff);
 	else
 		return ((remote_data->cur_lsbkeycode>>8) & 0xff);
 }
-unsigned int TOSHIBA_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int TOSHIBA_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
-		return ((remote_data->cur_lsbkeycode >>16) &0xff);
+		return ((remote_data->cur_keycode >>8) &0xff);
 	else
-		return ((remote_data->cur_lsbkeycode) &0xffff);
+		return ((remote_data->cur_keycode >>16) &0xffff);
 }
 /*
-   Pulse width modulation
-   Carrier frequency of 40kHz
-   Bit time of 1.2ms or 0.6ms
-   5-bit address and 7-bit command length (12-bit protocol)
+   Pulse width modulation 
+   Carrier frequency of 40kHz 
+   Bit time of 1.2ms or 0.6ms 
+   5-bit address and 7-bit command length (12-bit protocol) 
  */
 
-unsigned int SONYSIRC_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain)
+unsigned int SONYSIRC_DOMAIN(struct remote *remote_data,int domain){
+	if(domain) 
 		return ((remote_data->cur_lsbkeycode>>5) &0x7f);
-	else
+	else 
 		return (remote_data->cur_lsbkeycode&0x1f);
 }
-unsigned int RC5_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain)
+unsigned int RC5_DOMAIN(struct remote *remote_data,int domain){
+	if(domain) 
 		return ((remote_data->cur_lsbkeycode>>5) &0x7f);
-	else
+	else 
 		return (remote_data->cur_lsbkeycode&0x1f);
 
 }
 
-unsigned int RC6_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain)
+unsigned int RC6_DOMAIN(struct remote *remote_data,int domain){
+	if(domain) 
 		return ((remote_data->cur_lsbkeycode>>5) &0x7f);
-	else
+	else 
 		return (remote_data->cur_lsbkeycode&0x1f);
 
 }
 
-unsigned int RCA_DOMAIN(struct remote *remote_data,int domain)
-{
-	if(domain) {
-		return ((remote_data->cur_lsbkeycode) &0xff);
-	} else {
-		return ((remote_data->cur_lsbkeycode>>8)&0xf);
-	}
-
-}
-/*DUOKAN frame body                                                         eOPERATION_CTRL_REG2dd,0x0}, // hard decode mode
-  C7 ~ C4    C3~C0      D7 ~ D4    D3~D0      P3~P0
-  Header          Custom code              Data Code      Parity Code Stop Bit  */
+/*DUOKAN frame body																　　　　　　　　　
+ C7 ~ C4    C3~C0      D7 ~ D4    D3~D0      P3~P0
+ Header          Custom code              Data Code      Parity Code Stop Bit  */
 
-unsigned int DUOKAN_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int DUOKAN_DOMAIN(struct remote *remote_data,int domain){
 	if(remote_data->cur_lsbkeycode == 0x0003cccf)// power key
-		remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
+			remote_data->cur_lsbkeycode =((remote_data->custom_code[0]&0xff)<<12)| 0xa0;
 	if(domain)
 		return ((remote_data->cur_lsbkeycode >>4) &0xff);
-	else
+	else 
 		return ((remote_data->cur_lsbkeycode >>12) &0xff);
 }
-unsigned int KDB_NEC_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int KDB_NEC_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
 		return ((remote_data->cur_lsbkeycode >>4) &0xff);
-	else
+	else 
 		return ((remote_data->cur_lsbkeycode >>12) &0xff);
 }
-unsigned int KDB_DUOKAN_DOMAIN(struct remote *remote_data,int domain)
-{
+unsigned int KDB_DUOKAN_DOMAIN(struct remote *remote_data,int domain){
 	if(domain)
 		return ((remote_data->cur_lsbkeycode >>4) &0xff);
 	else
 		return ((remote_data->cur_lsbkeycode >>12) &0xff);
 }
-unsigned int NULL_DUOKAN_DOMAIN(struct remote *remote_data,int domain)
-{
-	return 0;
-}
-unsigned int (*get_cur_key_domian[])(struct remote *remote_data,int domain)= {
+unsigned int (*get_cur_key_domian[])(struct remote *remote_data,int domain)={
 	NEC_DOMAIN,
 	DUOKAN_DOMAIN,
 	KDB_NEC_DOMAIN,
 	RCMM_DOMAIN,
 	COMCAST_DOMAIN,
 	MITSUBISHI_DOMAIN,
-	SONYSIRC_DOMAIN,
 	TOSHIBA_DOMAIN,
+	SONYSIRC_DOMAIN,
 	RC5_DOMAIN,
 	RC6_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	RCA_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
-	NULL_DUOKAN_DOMAIN,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
 	KDB_DUOKAN_DOMAIN
 };
 
-int remote_hw_reprot_null_key(struct remote *remote_data)
-{
-	input_dbg("%s,it is a null key\n",__func__);
-	get_cur_scancode(remote_data);
-	get_cur_scanstatus(remote_data);
-	return 0;
-}
-irqreturn_t remote_null_bridge_isr(int irq, void *dev_id)
-{
-	return IRQ_HANDLED;
-}
-
 int remote_hw_reprot_key(struct remote *remote_data)
 {
 	static int last_scan_code;
@@ -469,17 +380,20 @@ int remote_hw_reprot_key(struct remote *remote_data)
 	get_cur_scanstatus(remote_data);
 	if(remote_data->status)// repeat enable & come in S timer is open
 		return 0;
-	if (remote_data->cur_lsbkeycode) {  //key first press
-		if(remote_data->ig_custom_enable) {
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+	if (remote_data->cur_lsbkeycode) {	//key first press
+		if(remote_data->ig_custom_enable)
+		{
+			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);){
 				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->work_mode](remote_data,CUSTOMDOMAIN)) {
 					//return -1;
 					i++;
-				} else {
+				}
+				else{
 					remote_data->map_num = i;
 					break;
 				}
-				if(i == ARRAY_SIZE(remote_data->custom_code)) {
+				if(i == ARRAY_SIZE(remote_data->custom_code))
+				{
 					input_dbg("Wrong custom code is 0x%08x\n", remote_data->cur_lsbkeycode);
 					return -1;
 				}
@@ -493,220 +407,49 @@ int remote_hw_reprot_key(struct remote *remote_data)
 		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN), 1,0);
 		remote_data->repeat_release_code = get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN);
 		remote_data->enable_repeat_falg = 1;
-		if((remote_data->work_mode > DECODEMODE_NEC) && remote_data->enable_repeat_falg) {
+		if((remote_data->work_mode > DECODEMODE_NEC) && remote_data->enable_repeat_falg){
 			if (remote_data->repeat_enable) {
 				remote_data->repeat_timer.data = (unsigned long)remote_data;
 				//here repeat  delay is time interval from the first frame end to first repeat end.
 				remote_data->repeat_tick = jiffies;
-				mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num]));
+				mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_delay));
 				remote_data->status = TIMER;
-			} else {
-				setup_timer(&remote_data->rel_timer, remote_rel_timer_sr, 0);
-				mod_timer(&remote_data->timer,  jiffies );
-				remote_data->rel_timer.data = (unsigned long)remote_data;
-				mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay[remote_data->map_num]));
-				remote_data->status = TIMER;
-			}
-		}
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
-			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
-				remote_data->want_repeat_enable = 1;
-			} else {
-				remote_data->want_repeat_enable = 0;
-			}
-		}
-
-		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
-			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num]);
-		}
-		if(remote_data->repeat_enable)
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-		else
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
-#ifdef CONFIG_AML_HDMI_TX
-		extern int rc_long_press_pwr_key;
-		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
-			rc_long_press_pwr_key = 1;
-			cec_repeat = 10;
-		}
-		if(remote_data->repeat_release_code == 0x1a)
-			cec_repeat--;
-
-#endif
-		if (remote_data->repeat_enable) {
-			repeat_count++;
-			if (remote_data->repeat_tick < jiffies) {
-				if(repeat_count > 1)
-					remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-				remote_data->repeat_tick += msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num]);
-			}
-		} else {
-			if (remote_data->timer.expires > jiffies) {
-				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]));
-			}
-			return -1;
-		}
-		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]) + msecs_to_jiffies(110));
-	}
-	last_scan_code = remote_data->cur_lsbkeycode;
-	remote_data->cur_keycode = last_scan_code;
-	remote_data->cur_lsbkeycode = 0;
-	remote_data->timer.data = (unsigned long)remote_data;
-	return 0;
-}
-int remote_hw_nec_rca_2in1_reprot_key(struct remote *remote_data)
-{
-	static int last_scan_code;
-	int i;
-	get_cur_scancode(remote_data);
-	get_cur_scanstatus(remote_data);
-	if(remote_data->status)// repeat enable & come in S timer is open
-		return 0;
-	if (remote_data->cur_lsbkeycode) {      //key first press
-		if(remote_data->ig_custom_enable) {
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
-				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->temp_work_mode](remote_data,CUSTOMDOMAIN)) {
-					//return -1;
-					i++;
-				} else {
-					remote_data->map_num = i;
-					break;
-				}
-				if(i == ARRAY_SIZE(remote_data->custom_code)) {
-					input_dbg("Wrong custom code is 0x%08x,temp_work_mode is %d\n", remote_data->cur_lsbkeycode,remote_data->temp_work_mode);
-					return -1;
-				}
 			}
-		}
-		repeat_count = 0;
-		if (remote_data->timer.expires > jiffies) {
-			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code , 0,0);
-		}
-		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN), 1,0);
-		remote_data->repeat_release_code = get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN);
-		remote_data->enable_repeat_falg = 1;
-		if((remote_data->temp_work_mode  == DECODEMODE_RCA) && (remote_data->enable_repeat_falg)) {
-			if (remote_data->repeat_enable) {
-				remote_data->repeat_timer.data = (unsigned long)remote_data;
-				//here repeat  delay is time interval from the first frame end to first repeat end.
-				remote_data->repeat_tick = jiffies;
-				mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num]));
-				remote_data->status = TIMER;
-			} else {
+			else{
 				setup_timer(&remote_data->rel_timer, remote_rel_timer_sr, 0);
 				mod_timer(&remote_data->timer,  jiffies );
 				remote_data->rel_timer.data = (unsigned long)remote_data;
-				mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay[remote_data->map_num]));
+				mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay));
 				remote_data->status = TIMER;
 			}
 		}
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
+		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++){
 			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
 				remote_data->want_repeat_enable = 1;
-			} else {
-				remote_data->want_repeat_enable = 0;
-			}
-		}
-
-		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
-			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num] );
-		}
-		if(remote_data->repeat_enable)
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-		else
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
-#ifdef CONFIG_AML_HDMI_TX
-		extern int rc_long_press_pwr_key;
-		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
-			rc_long_press_pwr_key = 1;
-			cec_repeat = 10;
-		}
-		if(remote_data->repeat_release_code == 0x1a)
-			cec_repeat--;
-
-#endif
-		if (remote_data->repeat_enable) {
-			repeat_count++;
-			if (remote_data->repeat_tick < jiffies) {
-				if(repeat_count > 1)
-					remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-				remote_data->repeat_tick += msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num] );
-			}
-		} else {
-			if (remote_data->timer.expires > jiffies) {
-				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]));
-			}
-			return -1;
-		}
-		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]) + msecs_to_jiffies(110));
-	}
-	last_scan_code = remote_data->cur_lsbkeycode;
-	remote_data->cur_keycode = last_scan_code;
-	remote_data->cur_lsbkeycode = 0;
-	remote_data->timer.data = (unsigned long)remote_data;
-	return 0;
-}
-
-int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data)
-{
-	static int last_scan_code;
-	int i;
-	get_cur_scancode(remote_data);
-	get_cur_scanstatus(remote_data);
-	if (remote_data->cur_lsbkeycode) {      //key first press
-		if(remote_data->ig_custom_enable) {
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
-				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->temp_work_mode](remote_data,CUSTOMDOMAIN)) {
-					//return -1;
-					i++;
-				} else {
-					remote_data->map_num = i;
-					break;
-				}
-
-				if(i == ARRAY_SIZE(remote_data->custom_code)) {
-					input_dbg("Wrong custom code is 0x%08x,temp_work_mode is %d\n", remote_data->cur_lsbkeycode,remote_data->temp_work_mode);
-					return -1;
-				}
 			}
-		}
-		repeat_count = 0;
-		if (remote_data->timer.expires > jiffies) {
-			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code , 0,0);
-		}
-		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN), 1,0);
-		remote_data->repeat_release_code = get_cur_key_domian[remote_data->temp_work_mode](remote_data,KEYDOMIAN);
-		remote_data->enable_repeat_falg = 1;
-		if(remote_data->temp_work_mode  == DECODEMODE_TOSHIBA) {
-			// setting frame bit = 1;
-			am_remote_write_reg(OPERATION_CTRL_REG1,0x8000);
-		}
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
-			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
-				remote_data->want_repeat_enable = 1;
-			} else {
+			else{
 				remote_data->want_repeat_enable = 0;
 			}
 		}
 
 		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
-			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->repeat_delay[remote_data->map_num] );
+			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->input->rep[REP_DELAY]);
 		}
 		if(remote_data->repeat_enable)
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_delay));
 		else
-			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_delay[remote_data->map_num]));
-	} else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg) { //repeate key
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_delay));
+	}
+	else if((remote_data->frame_status & REPEARTFLAG) && remote_data->enable_repeat_falg){	//repeate key
 #ifdef CONFIG_AML_HDMI_TX
-		extern int rc_long_press_pwr_key;
+       extern int rc_long_press_pwr_key;
 		if((remote_data->repeat_release_code == 0x1a) && (!cec_repeat)) {
-			rc_long_press_pwr_key = 1;
-			cec_repeat = 10;
+            rc_long_press_pwr_key = 1;
+		    cec_repeat = 10;
+		    mdelay(20);
 		}
 		if(remote_data->repeat_release_code == 0x1a)
-			cec_repeat--;
+ 		    cec_repeat--;
 
 #endif
 		if (remote_data->repeat_enable) {
@@ -714,21 +457,21 @@ int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data)
 			if (remote_data->repeat_tick < jiffies) {
 				if(repeat_count > 1)
 					remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-				remote_data->repeat_tick += msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num] );
+				remote_data->repeat_tick += msecs_to_jiffies(remote_data->input->rep[REP_PERIOD]);
 			}
 		} else {
 			if (remote_data->timer.expires > jiffies) {
-				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]));
+				mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay));
 			}
 			return -1;
 		}
-		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]) + msecs_to_jiffies(110));
+		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay) + msecs_to_jiffies(110));
 	}
 	last_scan_code = remote_data->cur_lsbkeycode;
 	remote_data->cur_keycode = last_scan_code;
 	remote_data->cur_lsbkeycode = 0;
 	remote_data->timer.data = (unsigned long)remote_data;
-	return 0;
+	return 0;	
 }
 static inline void kbd_software_mode_remote_send_key(unsigned long data)
 {
@@ -743,16 +486,19 @@ static inline void kbd_software_mode_remote_send_key(unsigned long data)
 				msecs_to_jiffies(remote_data->input->rep[REP_PERIOD]);
 		}
 	} else {
-		if(remote_data->ig_custom_enable) {
-			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);) {
+		if(remote_data->ig_custom_enable)
+		{
+			for(i = 0; i < ARRAY_SIZE(remote_data->custom_code);){
 				if (remote_data->custom_code[i] != get_cur_key_domian[remote_data->work_mode](remote_data,CUSTOMDOMAIN)) {
 					//return -1;
 					i++;
-				} else {
+				}
+				else{
 					remote_data->map_num = i;
 					break;
 				}
-				if(i == ARRAY_SIZE(remote_data->custom_code)) {
+				if(i == ARRAY_SIZE(remote_data->custom_code))
+				{
 					input_dbg("Wrong custom code is 0x%08x\n", remote_data->cur_lsbkeycode);
 					return;
 				}
@@ -761,64 +507,48 @@ static inline void kbd_software_mode_remote_send_key(unsigned long data)
 		remote_data->remote_send_key(remote_data->input,get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN), 1,0);
 		remote_data->repeat_release_code = get_cur_key_domian[remote_data->work_mode](remote_data,KEYDOMIAN);
 		remote_data->enable_repeat_falg = 1;
-		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++) {
+		for (i = 0; i < ARRAY_SIZE(remote_data->key_repeat_map[remote_data->map_num]); i++){
 			if (remote_data->key_repeat_map[remote_data->map_num][i] == remote_data->repeat_release_code) {
 				remote_data->want_repeat_enable = 1;
-			} else {
+			}
+			else{
 				remote_data->want_repeat_enable = 0;
 			}
 		}
 		if (remote_data->repeat_enable && remote_data->want_repeat_enable) {
 			remote_data->repeat_tick = jiffies + msecs_to_jiffies(remote_data->input->rep[REP_DELAY]);
-		}
-	}
-}
-static void remote_rca_repeat_sr(unsigned long data)
-{
-	struct remote *remote_data = (struct remote *)data;
-	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode ) {
-		repeat_count++;
-		if(repeat_count > 2)
-			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-		remote_data->cur_lsbkeycode = 0;
-		remote_data->repeat_timer.data = (unsigned long)remote_data;
-		remote_data->timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num]+remote_data->repeat_peroid[remote_data->map_num]));
-		mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num]));
-		remote_data->status = TIMER;
-	} else {
-		remote_data->status = NORMAL;
-		remote_data->timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->timer, jiffies+msecs_to_jiffies(1));
+		}		
 	}
 }
 static void remote_repeat_sr(unsigned long data)
 {
 	struct remote *remote_data = (struct remote *)data;
-	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode) {
-		auto_repeat_count++;
-		if(auto_repeat_count > 1)
-			remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
-		remote_data->cur_lsbkeycode = 0;
-		remote_data->repeat_timer.data = (unsigned long)remote_data;
-		remote_data->timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_peroid[remote_data->map_num]));
-		remote_data->status = TIMER;
-	} else {
-		remote_data->status = NORMAL;
-		remote_data->timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->timer, jiffies+msecs_to_jiffies(1));
+	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode){
+			auto_repeat_count++;
+			if(auto_repeat_count > 1)
+				remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code, 2,0);
+			remote_data->cur_lsbkeycode = 0;
+			remote_data->repeat_timer.data = (unsigned long)remote_data;
+			remote_data->timer.data = (unsigned long)remote_data;
+			mod_timer(&remote_data->timer, jiffies + msecs_to_jiffies(remote_data->release_delay+remote_data->repeat_peroid));
+			mod_timer(&remote_data->repeat_timer,  jiffies + msecs_to_jiffies(remote_data->repeat_peroid));
+			remote_data->status = TIMER;
+	}else{
+			remote_data->status = NORMAL;
+			remote_data->timer.data = (unsigned long)remote_data;
+			mod_timer(&remote_data->timer, jiffies+msecs_to_jiffies(1));
 	}
 }
 static void remote_rel_timer_sr(unsigned long data)
 {
 	struct remote *remote_data = (struct remote *)data;
-	if(remote_data->cur_keycode == remote_data->cur_lsbkeycode) {
-		remote_data->cur_lsbkeycode = 0;
-		remote_data->rel_timer.data = (unsigned long)remote_data;
-		mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay[remote_data->map_num]));
-		remote_data->status = TIMER;
-	} else
+		if(remote_data->cur_keycode == remote_data->cur_lsbkeycode){
+			remote_data->cur_lsbkeycode = 0;
+			remote_data->rel_timer.data = (unsigned long)remote_data;
+			mod_timer(&remote_data->rel_timer,  jiffies + msecs_to_jiffies(remote_data->relt_delay));
+			remote_data->status = TIMER;
+		}
+		else
 		remote_data->status = NORMAL;
 
 
@@ -879,51 +609,51 @@ static inline void kbd_software_mode_remote_data(struct remote *remote_data)
 	pulse_width = get_pulse_width(remote_data);
 	remote_data->step = REMOTE_STATUS_DATA;
 	switch (remote_data->work_mode) {
-		case DECODEMODE_SW_NEC:
-			if ((pulse_width > remote_data->time_window[2])
-					&& (pulse_width < remote_data->time_window[3])) {
-				remote_data->bit_num--;
-			} else if ((pulse_width > remote_data->time_window[4])
-					&& (pulse_width < remote_data->time_window[5])) {
-				remote_data->bit_num--;
-				remote_data->cur_keycode |= 1 << (remote_data->bit_count - remote_data->bit_num);
-			} else {
-				remote_data->step = REMOTE_STATUS_WAIT;
-			}
-			if (remote_data->bit_num == 0) {
-				remote_data->repeate_flag = 0;
-				remote_data->send_data = 1;
-				fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
-			}
-			break;
-		case DECODEMODE_SW_DUOKAN:
-			if ((pulse_width > remote_data->time_window[2])
-					&& (pulse_width < remote_data->time_window[3])) {
-				remote_data->bit_num -= 2;
-			} else if ((pulse_width > remote_data->time_window[4])
-					&& (pulse_width < remote_data->time_window[5])) {
-				remote_data->cur_keycode |=
-					1 << (remote_data->bit_count - remote_data->bit_num);
-				remote_data->bit_num -= 2;
-			} else if ((pulse_width > remote_data->time_window[8])
-					&& (pulse_width < remote_data->time_window[9])) {
-				remote_data->cur_keycode |=
-					2 << (remote_data->bit_count - remote_data->bit_num);
-				remote_data->bit_num -= 2;
-			} else if ((pulse_width > remote_data->time_window[10])
-					&& (pulse_width < remote_data->time_window[11])) {
-				remote_data->cur_keycode |=
-					3 << (remote_data->bit_count - remote_data->bit_num);
-				remote_data->bit_num -= 2;
-			} else {
-				remote_data->step = REMOTE_STATUS_WAIT;
-			}
-			if (remote_data->bit_num == 0) {
-				remote_data->repeate_flag = 0;
-				remote_data->send_data = 1;
-				fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
-			}
-			break;
+	case DECODEMODE_SW_NEC:
+	if ((pulse_width > remote_data->time_window[2])
+			&& (pulse_width < remote_data->time_window[3])) {
+		remote_data->bit_num--;
+	} else if ((pulse_width > remote_data->time_window[4])
+			&& (pulse_width < remote_data->time_window[5])) {
+			remote_data->bit_num--;
+			remote_data->cur_keycode |= 1 << (remote_data->bit_count - remote_data->bit_num);
+	} else {
+		remote_data->step = REMOTE_STATUS_WAIT;
+	}
+	if (remote_data->bit_num == 0) {
+		remote_data->repeate_flag = 0;
+		remote_data->send_data = 1;
+		fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
+	}
+	break;
+	case DECODEMODE_SW_DUOKAN:
+		if ((pulse_width > remote_data->time_window[2])
+		    && (pulse_width < remote_data->time_window[3])) {
+			remote_data->bit_num -= 2;
+		} else if ((pulse_width > remote_data->time_window[4])
+		           && (pulse_width < remote_data->time_window[5])) {
+			remote_data->cur_keycode |=
+			    1 << (remote_data->bit_count - remote_data->bit_num);
+			remote_data->bit_num -= 2;
+		} else if ((pulse_width > remote_data->time_window[8])
+		           && (pulse_width < remote_data->time_window[9])) {
+			remote_data->cur_keycode |=
+			    2 << (remote_data->bit_count - remote_data->bit_num);
+			remote_data->bit_num -= 2;
+		} else if ((pulse_width > remote_data->time_window[10])
+		           && (pulse_width < remote_data->time_window[11])) {
+			remote_data->cur_keycode |=
+			    3 << (remote_data->bit_count - remote_data->bit_num);
+			remote_data->bit_num -= 2;
+		} else {
+			remote_data->step = REMOTE_STATUS_WAIT;
+		}
+		if (remote_data->bit_num == 0) {
+			remote_data->repeate_flag = 0;
+			remote_data->send_data = 1;
+			fiq_bridge_pulse_trigger(&remote_data->fiq_handle_item);
+		}
+		break;
 	}
 }
 
@@ -956,7 +686,7 @@ int remote_sw_reprot_key(struct remote *remote_data)
 			&& (remote_data->step <= REMOTE_STATUS_SYNC)) {
 		remote_data->step = REMOTE_STATUS_WAIT;
 	}
-	remote_data->last_jiffies = current_jiffies;    //ignore a little msecs
+	remote_data->last_jiffies = current_jiffies;	//ignore a little msecs
 	switch (remote_data->step) {
 		case REMOTE_STATUS_WAIT:
 			kbd_software_mode_remote_wait(remote_data);
@@ -980,60 +710,36 @@ irqreturn_t remote_bridge_isr(int irq, void *dev_id)
 {
 	struct remote *remote_data = (struct remote *)dev_id;
 
-	if (remote_data->send_data) {   //report key
+	if (remote_data->send_data) {	//report key
 		kbd_software_mode_remote_send_key((unsigned long)remote_data);
 		remote_data->send_data = 0;
 	}
 	remote_data->timer.data = (unsigned long)remote_data;
 	mod_timer(&remote_data->timer,
-			jiffies + msecs_to_jiffies(remote_data->release_delay[remote_data->map_num] ));
+			jiffies + msecs_to_jiffies(remote_data->release_delay));
 	return IRQ_HANDLED;
 }
-void kdb_send_key(struct input_dev *dev, unsigned int scancode,unsigned int type,int event)
-{
+void kdb_send_key(struct input_dev *dev, unsigned int scancode,unsigned int type,int event){
 	return;
 }
-void remote_nec_report_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
+void remote_nec_report_release_key(struct remote *remote_data){
+	if(remote_data->enable_repeat_falg){
 		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
 		remote_data->enable_repeat_falg = 0;
 	}
 }
-void remote_duokan_report_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
+void remote_duokan_report_release_key(struct remote *remote_data){
+	if(remote_data->enable_repeat_falg){
 		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
 		remote_data->enable_repeat_falg = 0;
 		auto_repeat_count = 0;
 	}
 }
-void remote_sw_reprot_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
+void remote_sw_reprot_release_key(struct remote *remote_data){
+	if(remote_data->enable_repeat_falg){
 		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
 		remote_data->enable_repeat_falg = 0;
-	}
-}
-void remote_nec_rca_2in1_report_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
-		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
-		remote_data->enable_repeat_falg = 0;
-	}
-}
-void remote_nec_toshiba_2in1_report_release_key(struct remote *remote_data)
-{
-	if(remote_data->enable_repeat_falg) {
-		remote_data->remote_send_key(remote_data->input,remote_data->repeat_release_code,0,0);
-		remote_data->enable_repeat_falg = 0;
-		am_remote_write_reg(OPERATION_CTRL_REG1,0x9f40);
-
-	}
+	}	
 }
 
-void remote_null_reprot_release_key(struct remote *remote_data)
-{
-
-}
 
diff --git a/drivers/amlogic/input/new_remote/remote_main.c b/drivers/amlogic/input/new_remote/remote_main.c
old mode 100755
new mode 100644
index c7f9b7a..7e3566e
--- a/drivers/amlogic/input/new_remote/remote_main.c
+++ b/drivers/amlogic/input/new_remote/remote_main.c
@@ -39,12 +39,17 @@
 #include <mach/pinmux.h>
 #include <linux/major.h>
 #include <linux/slab.h>
+#include <mach/gpio.h>
 #include <asm/uaccess.h>
 #include <linux/pinctrl/consumer.h>
 #include <linux/of_platform.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
 #include "remote_main.h"
 
+
 #undef NEW_BOARD_LEARNING_MODE
+
+//#define IR_CONTROL_HOLD_LAST_KEY    (1<<6)
 #define IR_CONTROL_DECODER_MODE     (3<<7)
 #define IR_CONTROL_SKIP_HEADER      (1<<7)
 #define IR_CONTROL_RESET            (1<<0)
@@ -71,66 +76,70 @@ static struct remote *gp_remote = NULL;
 char *remote_log_buf;
 // use 20 map for this driver
 static __u16 key_map[20][512];
-static  irqreturn_t (*remote_bridge_sw_isr[])(int irq, void *dev_id)= {
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
-	remote_null_bridge_isr,
+static  irqreturn_t (*remote_bridge_sw_isr[])(int irq, void *dev_id)={
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
 	remote_bridge_isr,
 	remote_bridge_isr,
 };
 
-static  int (*remote_report_key[])(struct remote *remote_data)= {
+static  int (*remote_report_key[])(struct remote *remote_data)={
 	remote_hw_reprot_key,
 	remote_hw_reprot_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_reprot_null_key,
-	remote_hw_nec_rca_2in1_reprot_key,
-	remote_hw_nec_toshiba_2in1_reprot_key,
-	remote_sw_reprot_key
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	remote_sw_reprot_key		
 };
 
-static  void (*remote_report_release_key[])(struct remote *remote_data)= {
+static  void (*remote_report_release_key[])(struct remote *remote_data)={
 	remote_nec_report_release_key,
 	remote_duokan_report_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_null_reprot_release_key,
-	remote_nec_rca_2in1_report_release_key,
-	remote_nec_toshiba_2in1_report_release_key,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+	NULL,
 	remote_sw_reprot_release_key
 };
 static __u16 mouse_map[20][6];
+
+static unsigned int power_led_sys;
+static unsigned int power_led_wake;
+
 int remote_printk(const char *fmt, ...)
 {
 	va_list args;
@@ -147,7 +156,7 @@ int remote_printk(const char *fmt, ...)
 
 static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsigned int type,bool flag)
 {
-
+	
 	__u16 mouse_code = REL_X;
 	__s32 mouse_value = 0;
 	static unsigned int repeat_count = 0;
@@ -165,10 +174,10 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsi
 		return -1;
 	}
 	switch (type) {
-		case 1:     //press
+		case 1:		//press
 			repeat_count = 0;
 			break;
-		case 2:     //repeat
+		case 2:		//repeat
 			if (repeat_count >= ARRAY_SIZE(move_accelerate) - 1) {
 				repeat_count = ARRAY_SIZE(move_accelerate) - 1;
 			} else {
@@ -192,7 +201,7 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsi
 			mouse_code = REL_Y;
 			mouse_value = 1 + move_accelerate[repeat_count];
 			break;
-		case 4:     //up
+		case 4:		//up
 			mouse_code = REL_WHEEL;
 			mouse_value = 0x1;
 			break;
@@ -220,33 +229,55 @@ static int remote_mouse_event(struct input_dev *dev, unsigned int scancode, unsi
 	return 0;
 }
 
-void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int type,int event)
+void led_on(void)
 {
-	printk("remote_send_key\n");
-	if(scancode == FN_KEY_SCANCODE && type == 1) {
-		// switch from key to pointer
-		if(key_pointer_switch) {
-			key_pointer_switch = false;
-			gp_remote->repeat_enable = 1;
-			gp_remote->input->rep[REP_DELAY] = gp_remote->repeat_delay[gp_remote->map_num];
-			gp_remote->input->rep[REP_PERIOD] = gp_remote->repeat_peroid[gp_remote->map_num];
-		}
-		// switch from pointer to key
-		else {
-			key_pointer_switch = true;
-			gp_remote->repeat_enable = 0;
-			gp_remote->input->rep[REP_DELAY] = 0xffffffff;
-			gp_remote->input->rep[REP_PERIOD] = 0xffffffff;
-		}
-	}
-
-	if(scancode == OK_KEY_SCANCODE && key_pointer_switch == false) {
-		input_event(dev, EV_KEY, BTN_MOUSE, type);
-		input_sync(dev);
-
-		return;
-	}
+//	input_dbg("wml led_on\n");
+//	CLEAR_CBUS_REG_MASK(PREG_PAD_GPIO0_EN_N, (1 << 16));
+//	SET_CBUS_REG_MASK(PREG_PAD_GPIO0_O, (1 << 16));	
+	amlogic_gpio_direction_output(power_led_sys, 0, "POWER_LED_SYS");
+	amlogic_gpio_direction_output(power_led_wake, 0, "POWER_LED_WAKE");
+}
 
+void led_off(void)
+{
+//	input_dbg("wml led_off\n");
+//	CLEAR_CBUS_REG_MASK(PREG_PAD_GPIO0_EN_N, (1 << 16));
+//	CLEAR_CBUS_REG_MASK(PREG_PAD_GPIO0_O, (1 << 16));
+	amlogic_gpio_direction_output(power_led_sys, 1, "POWER_LED_SYS");
+	amlogic_gpio_direction_output(power_led_wake, 1, "POWER_LED_WAKE");	
+}
+void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int type,int event)
+{
+	static int swith_led =1;
+	printk("remote_send_key \n");
+	if(scancode == FN_KEY_SCANCODE && type == 1)
+    {
+    	// switch from key to pointer
+        if(key_pointer_switch)
+        {
+            key_pointer_switch = false;
+            gp_remote->repeat_enable = 1;	
+            gp_remote->input->rep[REP_DELAY] = gp_remote->repeat_delay;
+            gp_remote->input->rep[REP_PERIOD] = gp_remote->repeat_peroid;
+        }
+        // switch from pointer to key
+        else
+        {
+            key_pointer_switch = true;
+            gp_remote->repeat_enable = 0;
+            gp_remote->input->rep[REP_DELAY] = 0xffffffff;
+            gp_remote->input->rep[REP_PERIOD] = 0xffffffff;
+        }
+    }
+
+    if(scancode == OK_KEY_SCANCODE && key_pointer_switch == false)
+    {
+       	 input_event(dev, EV_KEY, BTN_MOUSE, type);
+		 input_sync(dev);
+
+    	 return;
+     }
+	
 	if (remote_mouse_event(dev, scancode, type,key_pointer_switch)) {
 		if (scancode > ARRAY_SIZE(key_map[gp_remote->map_num])) {
 			input_dbg("scancode is 0x%04x, out of key mapping.\n", scancode);
@@ -257,27 +288,41 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int
 			input_dbg("scancode is 0x%04x, invalid key is 0x%04x.\n", scancode, key_map[gp_remote->map_num][scancode]);
 			return;
 		}
-
-		if(type == 2 && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074) {
-			return;
-		} else {
-			input_event(dev, EV_KEY, key_map[gp_remote->map_num][scancode], type);
-			input_sync(dev);
-		}
-
+		if(type == 1 && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074){
+		    disable_irq(NEC_REMOTE_IRQ_NO);
+                }
+		if(type == 0 && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074){
+		    enable_irq(NEC_REMOTE_IRQ_NO);
+                }
+		input_event(dev, EV_KEY, key_map[gp_remote->map_num][scancode], type);
+		input_sync(dev);
 		switch (type) {
 			case 0:
 				input_dbg("release ircode = 0x%02x, scancode = 0x%04x, maptable = %d \n", scancode, key_map[gp_remote->map_num][scancode],gp_remote->map_num);
+				led_on();
+				swith_led =1;
 				break;
 			case 1:
 				input_dbg("press ircode = 0x%02x, scancode = 0x%04x, maptable = %d \n", scancode, key_map[gp_remote->map_num][scancode],gp_remote->map_num);
+				led_off();
+				swith_led =0;
 				break;
 			case 2:
 				input_dbg("repeat ircode = 0x%02x, scancode = 0x%04x, maptable = %d \n", scancode, key_map[gp_remote->map_num][scancode],gp_remote->map_num);
+				if(swith_led ==1)
+				{
+					swith_led =0;
+					led_off();
+				}
+				else
+				{
+					swith_led =1;
+					led_on();
+				}
 				break;
 		}
-		input_dbg("%s sleep:%d\n", __func__, gp_remote->sleep);
-		if(gp_remote->sleep && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074) {
+		printk("%s sleep:%d\n", __func__, gp_remote->sleep);
+		if(gp_remote->sleep && scancode == 0x1a && key_map[gp_remote->map_num][scancode] == 0x0074){
 			printk(" set AO_RTI_STATUS_REG2 0x4853ffff \n");
 			WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0x4853ffff); // tell uboot don't suspend
 		}
@@ -286,7 +331,7 @@ void remote_send_key(struct input_dev *dev, unsigned int scancode, unsigned int
 
 static void disable_remote_irq(void)
 {
-	if (gp_remote->work_mode >= DECODEMODE_MAX) {
+	if (gp_remote->work_mode >= DECODEMODE_MAX){
 		disable_irq(NEC_REMOTE_IRQ_NO);
 	}
 }
@@ -299,26 +344,25 @@ static void enable_remote_irq(void)
 
 }
 
-void remote_reprot_key( struct remote * remote_data)
-{
+void remote_reprot_key( struct remote * remote_data){
 	remote_report_key[remote_data->work_mode](remote_data);
 }
 static void remote_release_timer_sr(unsigned long data)
 {
 	struct remote *remote_data = (struct remote *)data;
-	//key report release use timer interrupt
+	//key report release use timer interrupt 
 	remote_data->key_release_report = remote_report_release_key[remote_data->work_mode];
 	remote_data->key_release_report(remote_data);
 }
 
-static irqreturn_t remote_interrupt(int irq, void *dev_id)
-{
+static irqreturn_t remote_interrupt(int irq, void *dev_id){
 	tasklet_schedule(&tasklet);
 	return IRQ_HANDLED;
 }
 
 static void remote_fiq_interrupt(void)
 {
+	//struct remote *remote_data = (struct remote *)data;
 	remote_reprot_key(gp_remote);
 }
 
@@ -376,7 +420,7 @@ static int hardware_init(struct platform_device *pdev)
 	p=devm_pinctrl_get_select_default(&pdev->dev);
 	if (IS_ERR(p))
 		return -1;
-	set_remote_mode(DECODEMODE_NEC_RCA_2IN1);
+	set_remote_mode(DECODEMODE_NEC);
 	return request_irq(NEC_REMOTE_IRQ_NO, remote_interrupt, IRQF_SHARED, "keypad", (void *)remote_interrupt);
 }
 static int work_mode_config(unsigned int cur_mode)
@@ -390,7 +434,7 @@ static int work_mode_config(unsigned int cur_mode)
 	set_remote_init(gp_remote);
 	if(cur_mode == gp_remote->save_mode)
 		return 0;
-	if((cur_mode <= DECODEMODE_MAX)  && (gp_remote->save_mode > DECODEMODE_MAX) ) {
+	if((cur_mode <= DECODEMODE_MAX)  && (gp_remote->save_mode > DECODEMODE_MAX) ){
 		unregister_fiq_bridge_handle(&gp_remote->fiq_handle_item);
 		free_fiq(NEC_REMOTE_IRQ_NO, &remote_fiq_interrupt);
 		ret = request_irq(NEC_REMOTE_IRQ_NO, remote_interrupt, IRQF_SHARED, "keypad", (void *)remote_interrupt);
@@ -398,7 +442,8 @@ static int work_mode_config(unsigned int cur_mode)
 			printk(KERN_ERR "Remote: request_irq failed, ret=%d.\n", ret);
 			return ret;
 		}
-	} else if((cur_mode > DECODEMODE_MAX)  && (gp_remote->save_mode < DECODEMODE_MAX)) {
+	}
+	else if((cur_mode > DECODEMODE_MAX)  && (gp_remote->save_mode < DECODEMODE_MAX)){
 		free_irq(NEC_REMOTE_IRQ_NO, remote_interrupt);
 		gp_remote->fiq_handle_item.handle = remote_bridge_sw_isr[gp_remote->work_mode];
 		gp_remote->fiq_handle_item.key = (u32) gp_remote;
@@ -406,7 +451,8 @@ static int work_mode_config(unsigned int cur_mode)
 		register_fiq_bridge_handle(&gp_remote->fiq_handle_item);
 		desc->depth++;
 		request_fiq(NEC_REMOTE_IRQ_NO, remote_fiq_interrupt);
-	} else {
+	}
+	else{
 		printk("do nothing\n");
 	}
 	gp_remote->save_mode = cur_mode;
@@ -464,13 +510,13 @@ static long remote_config_ioctl(struct file *filp, unsigned int cmd, unsigned lo
 			mouse_map[remote->map_num][val >> 16] = val & 0xff;
 			break;
 		case REMOTE_IOC_SET_RELT_DELAY:
-			ret = copy_from_user(&remote->relt_delay[remote->map_num], argp, sizeof(long));
+			ret = copy_from_user(&remote->relt_delay, argp, sizeof(long));
 			break;
 		case REMOTE_IOC_SET_REPEAT_DELAY:
-			ret = copy_from_user(&remote->repeat_delay[remote->map_num], argp, sizeof(long));
+			ret = copy_from_user(&remote->repeat_delay, argp, sizeof(long));
 			break;
 		case REMOTE_IOC_SET_REPEAT_PERIOD:
-			ret = copy_from_user(&remote->repeat_peroid[remote->map_num], argp, sizeof(long));
+			ret = copy_from_user(&remote->repeat_peroid, argp, sizeof(long));
 			break;
 		case REMOTE_IOC_SET_REPEAT_ENABLE:
 			ret = copy_from_user(&remote->repeat_enable, argp, sizeof(long));
@@ -506,7 +552,7 @@ static long remote_config_ioctl(struct file *filp, unsigned int cmd, unsigned lo
 			am_remote_write_reg(DURATION_REG0, val);
 			break;
 		case REMOTE_IOC_SET_RELEASE_DELAY:
-			ret = copy_from_user(&remote->release_delay[remote->map_num], argp, sizeof(long));
+			ret = copy_from_user(&remote->release_delay, argp, sizeof(long));
 			break;
 			//SW
 		case REMOTE_IOC_SET_TW_LEADER_ACT:
@@ -544,8 +590,8 @@ static long remote_config_ioctl(struct file *filp, unsigned int cmd, unsigned lo
 	switch (cmd) {
 		case REMOTE_IOC_SET_REPEAT_ENABLE:
 			if (remote->repeat_enable) {
-				remote->input->rep[REP_DELAY] = remote->repeat_delay[remote->map_num] ;
-				remote->input->rep[REP_PERIOD] = remote->repeat_peroid[remote->map_num] ;
+				remote->input->rep[REP_DELAY] = remote->repeat_delay;
+				remote->input->rep[REP_PERIOD] = remote->repeat_peroid;
 			} else {
 				remote->input->rep[REP_DELAY] = 0xffffffff;
 				remote->input->rep[REP_PERIOD] = 0xffffffff;
@@ -605,15 +651,14 @@ static int register_remote_dev(struct remote *remote)
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static void remote_early_suspend(struct early_suspend *handler)
 {
-	printk("remote_early_suspend, set sleep 1 \n");
-	gp_remote->sleep = 1;
-	return;
+	 printk("remote_early_suspend, set sleep 1 \n");
+	 gp_remote->sleep = 1;
+	 return;
 }
 #endif
 
-static const struct of_device_id remote_dt_match[]= {
-	{
-		.compatible     = "amlogic,aml_remote",
+static const struct of_device_id remote_dt_match[]={
+	{	.compatible 	= "amlogic,aml_remote",
 	},
 	{},
 };
@@ -631,7 +676,7 @@ static int remote_probe(struct platform_device *pdev)
 		return -1;
 	}
 	ret = of_property_read_u32(pdev->dev.of_node,"ao_baseaddr",&ao_baseaddr);
-	if(ret) {
+	if(ret){
 		printk("don't find  match ao_baseaddr\n");
 		return -1;
 	}
@@ -658,15 +703,13 @@ static int remote_probe(struct platform_device *pdev)
 	remote->input = input_dev;
 	remote->release_fdelay = KEY_RELEASE_DELAY;
 	remote->custom_code[remote->map_num] = 0xfb04;
-	for(i=1; i<20; i++)
-		remote->custom_code[i] = 0xffff;
-	remote->bit_count = 32;
+	remote->bit_count = 32;	
 	remote->last_jiffies = 0xffffffff;
 	remote->last_pulse_width = 0;
 	remote->step = REMOTE_STATUS_WAIT;
 	remote->sleep = 0;
 	//init logic0 logic1  time window
-	for(i = 0; i < 18; i++)
+	for(i = 0;i < 18;i++)
 		remote->time_window[i] = 0x1;
 	/* Disable the interrupt for the MPUIO keyboard */
 	for (i = 0; i < ARRAY_SIZE(key_map[remote->map_num]); i++) {
@@ -675,23 +718,23 @@ static int remote_probe(struct platform_device *pdev)
 	for (i = 0; i < ARRAY_SIZE(mouse_map); i++) {
 		mouse_map[remote->map_num][i] = 0xffff;
 	}
-	remote->repeat_delay[remote->map_num]  = 250;
-	remote->repeat_peroid[remote->map_num]  = 33;
+	remote->repeat_delay = 250;
+	remote->repeat_peroid = 33;
 	/* get the irq and init timer */
 	input_dbg("set drvdata completed\r\n");
 	tasklet_enable(&tasklet);
 	tasklet.data = (unsigned long)remote;
 	setup_timer(&remote->timer, remote_release_timer_sr, 0);
-	/*read status & frame register to abandon last key from uboot*/
-	am_remote_read_reg(DURATION_REG1_AND_STATUS);
-	am_remote_read_reg(FRAME_BODY);
-#ifdef CONFIG_HAS_EARLYSUSPEND
-	early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING + 1;
-	early_suspend.suspend = remote_early_suspend;
-	early_suspend.resume = NULL;
-	early_suspend.param = gp_remote;
-	register_early_suspend(&early_suspend);
-#endif
+        /*read status & frame register to abandon last key from uboot*/
+	am_remote_read_reg(DURATION_REG1_AND_STATUS);	
+	am_remote_read_reg(FRAME_BODY);	
+	#ifdef CONFIG_HAS_EARLYSUSPEND
+    early_suspend.level = EARLY_SUSPEND_LEVEL_STOP_DRAWING + 1;
+    early_suspend.suspend = remote_early_suspend;
+    early_suspend.resume = NULL;
+    early_suspend.param = gp_remote;
+    register_early_suspend(&early_suspend);
+    #endif
 
 	ret = device_create_file(&pdev->dev, &dev_attr_enable);
 	if (ret < 0) {
@@ -735,6 +778,14 @@ static int remote_probe(struct platform_device *pdev)
 	remote_log_buf = (char *)__get_free_pages(GFP_KERNEL, REMOTE_LOG_BUF_ORDER);
 	remote_log_buf[0] = '\0';
 	printk("physical address:0x%x\n", (unsigned int)virt_to_phys(remote_log_buf));
+	
+	//set gpioy_10 as gpio
+	power_led_sys= amlogic_gpio_name_map_num("GPIOAO_2");
+	amlogic_gpio_request(power_led_sys, "POWER_LED_SYS");
+	//set gpioy_11 as gpio
+	power_led_wake= amlogic_gpio_name_map_num("GPIOAO_13");
+	amlogic_gpio_request(power_led_wake, "POWER_LED_WAKE");
+	
 	return 0;
 err3:
 	input_unregister_device(remote->input);
@@ -759,7 +810,7 @@ static int remote_remove(struct platform_device *pdev)
 	free_pages((unsigned long)remote_log_buf, REMOTE_LOG_BUF_ORDER);
 	device_remove_file(&pdev->dev, &dev_attr_enable);
 	device_remove_file(&pdev->dev, &dev_attr_log_buffer);
-	if(gp_remote->work_mode >= DECODEMODE_MAX) {
+	if(gp_remote->work_mode >= DECODEMODE_MAX){
 		free_fiq(NEC_REMOTE_IRQ_NO, remote_fiq_interrupt);
 		free_irq(BRIDGE_IRQ, gp_remote);
 	} else {
@@ -784,23 +835,23 @@ static int remote_resume(struct platform_device * pdev)
 {
 	printk("remote_resume To do remote resume\n");
 	printk("remote_resume make sure read frame enable ir interrupt\n");
-	am_remote_read_reg(DURATION_REG1_AND_STATUS);
-	am_remote_read_reg(FRAME_BODY);
+	am_remote_read_reg(DURATION_REG1_AND_STATUS);	
+	am_remote_read_reg(FRAME_BODY);	
 	if (READ_AOBUS_REG(AO_RTI_STATUS_REG2) == 0x1234abcd) {
 		input_event(gp_remote->input, EV_KEY, KEY_POWER, 1);
 		input_sync(gp_remote->input);
 		input_event(gp_remote->input, EV_KEY, KEY_POWER, 0);
 		input_sync(gp_remote->input);
-
+		
 		//aml_write_reg32(P_AO_RTC_ADDR0, (aml_read_reg32(P_AO_RTC_ADDR0) | (0x0000f000)));
 		WRITE_AOBUS_REG(AO_RTI_STATUS_REG2, 0);
 	}
 	gp_remote->sleep = 0;
-	printk("to clear irq ...\n");
+        printk("to clear irq ...\n");
 	disable_irq(NEC_REMOTE_IRQ_NO);
-	udelay(1000);
+        udelay(1000);
 	enable_irq(NEC_REMOTE_IRQ_NO);
-
+		
 	return 0;
 }
 
@@ -819,7 +870,7 @@ static struct platform_driver remote_driver = {
 	.resume = remote_resume,
 	.driver = {
 		.name = "meson-remote",
-		.of_match_table = remote_dt_match,
+		.of_match_table = remote_dt_match,	
 	},
 };
 
diff --git a/drivers/amlogic/input/new_remote/remote_main.h b/drivers/amlogic/input/new_remote/remote_main.h
old mode 100755
new mode 100644
index b3da3cb..c1864e8
--- a/drivers/amlogic/input/new_remote/remote_main.h
+++ b/drivers/amlogic/input/new_remote/remote_main.h
@@ -5,36 +5,36 @@
 #include <linux/timer.h>
 #include <plat/fiq_bridge.h>
 /*remote register*/
-#define LDR_ACTIVE 0x0
-#define LDR_IDLE 0x4
-#define LDR_REPEAT 0x8
-#define DURATION_REG0    0xc
-#define OPERATION_CTRL_REG0 0x10
-#define FRAME_BODY 0x14
-#define DURATION_REG1_AND_STATUS 0x18
-#define OPERATION_CTRL_REG1 0x1c
-#define OPERATION_CTRL_REG2 0x20
-#define DURATION_REG2    0x24
-#define DURATION_REG3    0x28
-#define FRAME_BODY1 0x2c
-#define CONFIG_END 0xff
+#define LDR_ACTIVE 0x0     
+#define LDR_IDLE 0x4        
+#define LDR_REPEAT 0x8	 
+#define DURATION_REG0    0xc             
+#define OPERATION_CTRL_REG0 0x10                  
+#define FRAME_BODY 0x14     
+#define DURATION_REG1_AND_STATUS 0x18          
+#define OPERATION_CTRL_REG1 0x1c      
+#define OPERATION_CTRL_REG2 0x20 
+#define DURATION_REG2    0x24    
+#define DURATION_REG3    0x28    
+#define FRAME_BODY1 0x2c  
+#define CONFIG_END 0xff  
 /*config remote register val*/
 typedef struct reg_s {
 	int reg;
 	unsigned int val;
 } remotereg_t;
-typedef enum {
+typedef enum{
 	NORMAL = 0,
 	TIMER = 1 ,
-} repeat_status;
+}repeat_status;
 
 /*
-   Decode_mode.(format selection)
+   Decode_mode.(format selection) 
    0x0 =NEC
    0x1= skip leader (just bits)
    0x2=measure width (software decode)
    0x3=MITSUBISHI
-   0x4=Thomson
+   0x4=Thomson   
    0x5=Toshiba
    0x6=Sony SIRC
    0x7=RC5
@@ -47,29 +47,26 @@ typedef enum {
    0xE=Comcast
    0xF=Sanyo
  */
-typedef enum {
+typedef enum{
 	DECODEMODE_NEC = 0,
 	DECODEMODE_DUOKAN = 1 ,
 	DECODEMODE_RCMM ,
 	DECODEMODE_SONYSIRC,
 	DECODEMODE_SKIPLEADER ,
+	DECODEMODE_SW,
 	DECODEMODE_MITSUBISHI,
 	DECODEMODE_THOMSON,
 	DECODEMODE_TOSHIBA,
 	DECODEMODE_RC5,
 	DECODEMODE_RESERVED,
 	DECODEMODE_RC6,
-	DECODEMODE_RCA,
 	DECODEMODE_COMCAST,
 	DECODEMODE_SANYO,
-	DECODEMODE_NEC_RCA_2IN1 = 14,
-	DECODEMODE_NEC_TOSHIBA_2IN1 = 15,
-	DECODEMODE_SW,
 	DECODEMODE_MAX ,
 	DECODEMODE_SW_NEC,
 	DECODEMODE_SW_DUOKAN
 
-} ddmode_t;
+}ddmode_t;
 
 /*remote config val*/
 /****************************************************************/
@@ -77,14 +74,14 @@ static const remotereg_t RDECODEMODE_NEC[] = {
 	{LDR_ACTIVE,((unsigned)477<<16) | ((unsigned)400<<0)},// NEC leader 9500us,max 477: (477* timebase = 20) = 9540 ;min 400 = 8000us
 	{LDR_IDLE, 248<<16 | 202<<0},// leader idle
 	{LDR_REPEAT,130<<16|110<<0}, // leader repeat
-	{DURATION_REG0,60<<16|48<<0 },// logic '0' or '00'
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
-	{DURATION_REG1_AND_STATUS,(111<<20)|(100<<10)}, // logic '1' or '01'
+	{DURATION_REG0,60<<16|48<<0 },// logic '0' or '00'      
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms         
+	{DURATION_REG1_AND_STATUS,(111<<20)|(100<<10)}, // logic '1' or '01'      
 	{OPERATION_CTRL_REG1,0x9f40},// boby long decode (8-13)
 	//{OPERATION_CTRL_REG1,0xbe40},// boby long decode (8-13)
 	{OPERATION_CTRL_REG2,0x0}, // hard decode mode
 	{DURATION_REG2,0},
-	{DURATION_REG3,0},
+	{DURATION_REG3,0},  
 	{CONFIG_END,            0      }
 };
 /****************************************************************/
@@ -92,8 +89,8 @@ static const remotereg_t RDECODEMODE_DUOKAN[] = {
 	{LDR_ACTIVE,53<<16 | 50<<0},
 	{LDR_IDLE, 31<<16 | 25<<0},
 	{LDR_REPEAT,30<<16 | 26<<0},
-	{DURATION_REG0,61<<16 | 55<<0 },
-	{OPERATION_CTRL_REG0,3<<28 |(0x5DC<<12)| 0x13}, //body frame 30ms
+	{DURATION_REG0,61<<16 | 55<<0 }, 
+	{OPERATION_CTRL_REG0,3<<28 |(0x5DC<<12)| 0x13}, //body frame 30ms         
 	{DURATION_REG1_AND_STATUS,(76<<20) | 69<<10},
 	{OPERATION_CTRL_REG1,0x9300},
 	{OPERATION_CTRL_REG2,0x10b},
@@ -106,13 +103,13 @@ static const remotereg_t RDECODEMODE_RCMM[] = {
 	{LDR_ACTIVE,25<<16 | 22<<0},
 	{LDR_IDLE, 14<<16 | 13<<0},
 	{LDR_REPEAT,14<<16 | 13<<0},
-	{DURATION_REG0,25<<16 | 21<<0 },
-	{OPERATION_CTRL_REG0,3<<28 |(0x708<<12)| 0x13}, // body frame 28 or 36 ms
-	{DURATION_REG1_AND_STATUS,33<<20 | 29<<10},
+	{DURATION_REG0,25<<16 | 21<<0 },          
+	{OPERATION_CTRL_REG0,3<<28 |(0x708<<12)| 0x13}, // body frame 28 or 36 ms        
+	{DURATION_REG1_AND_STATUS,33<<20 | 29<<10},        
 	{OPERATION_CTRL_REG1,0xbe40},
 	{OPERATION_CTRL_REG2,0xa},
 	{DURATION_REG2,39<<16 | 36<<0},
-	{DURATION_REG3,50<<16 | 46<<0},
+	{DURATION_REG3,50<<16 | 46<<0},  
 	{CONFIG_END,            0      }
 };
 /****************************************************************/
@@ -120,13 +117,13 @@ static const remotereg_t RDECODEMODE_SONYSIRC[] = {
 	{LDR_ACTIVE,130<<16 | 110<<0},
 	{LDR_IDLE, 33<<16 | 27<<0},
 	{LDR_REPEAT,33<<16 | 27<<0},
-	{DURATION_REG0,63<<16 | 56<<0 },
-	{OPERATION_CTRL_REG0,3<<28 |(0x8ca<<12)| 0x13},  // body frame 45ms
-	{DURATION_REG1_AND_STATUS,94<<20 | 82<<10},
+	{DURATION_REG0,63<<16 | 56<<0 },          
+	{OPERATION_CTRL_REG0,3<<28 |(0x8ca<<12)| 0x13},  // body frame 45ms            
+	{DURATION_REG1_AND_STATUS,94<<20 | 82<<10},        
 	{OPERATION_CTRL_REG1,0xbe40},
 	{OPERATION_CTRL_REG2,0x6},
 	{DURATION_REG2,0},
-	{DURATION_REG3,0},
+	{DURATION_REG3,0},  
 	{CONFIG_END,            0      }
 };
 
@@ -136,9 +133,9 @@ static const remotereg_t RDECODEMODE_MITSUBISHI[] = {
 	{LDR_ACTIVE,410<<16 | 390<<0},
 	{LDR_IDLE, 225<<16 | 200<<0},
 	{LDR_REPEAT,225<<16 | 200<<0},
-	{DURATION_REG0,60<<16 | 48<<0 },
-	{OPERATION_CTRL_REG0,3<<28 |(0xBB8<<12)| 0x13},  //An IR command is repeated 60ms for as long as the key on the remote is held down. body frame 60ms
-	{DURATION_REG1_AND_STATUS,110<<20 | 95<<10},
+	{DURATION_REG0,60<<16 | 48<<0 },          
+	{OPERATION_CTRL_REG0,3<<28 |(0xBB8<<12)| 0x13},  //An IR command is repeated 60ms for as long as the key on the remote is held down. body frame 60ms            
+	{DURATION_REG1_AND_STATUS,110<<20 | 95<<10},        
 	{OPERATION_CTRL_REG1,0xbe40},
 	{OPERATION_CTRL_REG2,0x3},
 	{DURATION_REG2,0},
@@ -151,9 +148,9 @@ static const remotereg_t RDECODEMODE_TOSHIBA[] = {
 	{LDR_ACTIVE,477<<16 | 389<<0},//TOSHIBA leader 9000us
 	{LDR_IDLE, 477<<16 | 389<<0},// leader idle
 	{LDR_REPEAT,460<<16|389<<0}, // leader repeat
-	{DURATION_REG0,60<<16|40<<0 },// logic '0' or '00'
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},
-	{DURATION_REG1_AND_STATUS,111<<20|100<<10},// logic '1' or '01'
+	{DURATION_REG0,60<<16|40<<0 },// logic '0' or '00'      
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},         
+	{DURATION_REG1_AND_STATUS,111<<20|100<<10},// logic '1' or '01'      
 	{OPERATION_CTRL_REG1,0xbe40},// boby long decode (8-13)
 	{OPERATION_CTRL_REG2,0x5}, // hard decode mode
 	{DURATION_REG2,0},
@@ -166,53 +163,53 @@ static const remotereg_t RDECODEMODE_THOMSON[] = {
 	{LDR_ACTIVE,477<<16 | 390<<0},// THOMSON leader 8000us,
 	{LDR_IDLE, 477<<16 | 390<<0},// leader idle
 	{LDR_REPEAT,460<<16|390<<0}, // leader repeat
-	{DURATION_REG0,80<<16|60<<0 },// logic '0' or '00'
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},
-	{DURATION_REG1_AND_STATUS,140<<20|120<<10},// logic '1' or '01'
+	{DURATION_REG0,80<<16|60<<0 },// logic '0' or '00'      
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},         
+	{DURATION_REG1_AND_STATUS,140<<20|120<<10},// logic '1' or '01'      
 	{OPERATION_CTRL_REG1,0xbe40},// boby long decode (8-13)
 	{OPERATION_CTRL_REG2,0x4}, // hard decode mode
 	{DURATION_REG2,0},
-	{DURATION_REG3,0},
+	{DURATION_REG3,0},  
 	{CONFIG_END,            0      }
 };
 /*********************************************************************/
 static const remotereg_t RDECODEMODE_COMCAST[] = {
 	{LDR_ACTIVE, 0   },
 	{LDR_IDLE,0  },
-	{LDR_REPEAT,0   },
-	{DURATION_REG0, 0},
-	{OPERATION_CTRL_REG0,0},
-	{DURATION_REG1_AND_STATUS,},
+	{LDR_REPEAT,0	},
+	{DURATION_REG0, 0},   
+	{OPERATION_CTRL_REG0,0},               
+	{DURATION_REG1_AND_STATUS,},        
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},
+	{DURATION_REG3,},  
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_SKIPLEADER[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
-	{DURATION_REG0, },
-	{OPERATION_CTRL_REG0,},
-	{DURATION_REG1_AND_STATUS,},
+	{LDR_REPEAT,	},
+	{DURATION_REG0, },          
+	{OPERATION_CTRL_REG0,},               
+	{DURATION_REG1_AND_STATUS,},        
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},
+	{DURATION_REG3,},  
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_SW[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
-	{DURATION_REG0, },
-	{OPERATION_CTRL_REG0,},
-	{DURATION_REG1_AND_STATUS,},
+	{LDR_REPEAT,	},
+	{DURATION_REG0, },          
+	{OPERATION_CTRL_REG0,},               
+	{DURATION_REG1_AND_STATUS,},        
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},
+	{DURATION_REG3,},  
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_SW_NEC[] = {
@@ -220,12 +217,12 @@ static const remotereg_t RDECODEMODE_SW_NEC[] = {
 	{LDR_IDLE, 248<<16 | 202<<0},// leader idle
 	{LDR_REPEAT,130<<16|110<<0}, // leader repeat
 	{DURATION_REG0,60<<16|48<<0 },// logic '0' or '00'
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
-	{DURATION_REG1_AND_STATUS,(111<<20)|(100<<10)}, // logic '1' or '01'
+	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms         
+	{DURATION_REG1_AND_STATUS,(111<<20)|(100<<10)}, // logic '1' or '01'      
 	{OPERATION_CTRL_REG1,0x8578},// boby long decode (8-13)
-	{OPERATION_CTRL_REG2,0x2}, //
+	{OPERATION_CTRL_REG2,0x2}, // 
 	{DURATION_REG2,0},
-	{DURATION_REG3,0},
+	{DURATION_REG3,0},  
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_SW_DUOKAN[] = {
@@ -241,88 +238,43 @@ static const remotereg_t RDECODEMODE_SW_DUOKAN[] = {
 	{DURATION_REG3,0},
 	{CONFIG_END,            0      }
 };
-static const remotereg_t RDECODEMODE_NEC_RCA_2IN1[] = {
-	// used old decode
-	{LDR_ACTIVE-0x100,((unsigned)477<<16) | ((unsigned)400<<0)},// NEC leader 9500us,max 477: (477* timebase = 20) = 9540 ;min 400 = 8000us
-	{LDR_IDLE-0x100, 248<<16 | 202<<0},// leader idle
-	{LDR_REPEAT-0x100,130<<16|110<<0}, // leader repeat
-	{DURATION_REG0-0x100,60<<16|48<<0 },// logic '0' or '00'
-	{OPERATION_CTRL_REG0-0x100,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
-	{DURATION_REG1_AND_STATUS-0x100,(111<<20)|(100<<10)}, // logic '1' or '01'
-	{OPERATION_CTRL_REG1-0x100,0xbe40},// boby long decode (9-13)
-	// used new decode
-	{LDR_ACTIVE,((unsigned)250<<16) | ((unsigned)160<<0)},//rca leader 4000us,200* timebase
-	{LDR_IDLE, 250<<16 | 160<<0},// leader idle 400
-	{LDR_REPEAT,250<<16|160<<0}, // leader repeat
-	{DURATION_REG0,100<<16|48<<0 },// logic '0' or '00' 1500us
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame
-	{DURATION_REG1_AND_STATUS,(150<<20)|(110<<10)}, // logic '1' or '01'     2500us
-	{OPERATION_CTRL_REG1,0x9740},// boby long decode (8-13) //framn len = 24bit
-	/*it may get the wrong customer value and key value from register if the value is set to 0x4,so the register value must set to 0x104*/
-	{OPERATION_CTRL_REG2,0x104},
-	{DURATION_REG2,0},
-	{DURATION_REG3,0},
-	{CONFIG_END,            0      }
-};
-static const remotereg_t RDECODEMODE_NEC_TOSHIBA_2IN1[] = {
-	// used old decode
-	{LDR_ACTIVE-0x100,((unsigned)477<<16) | ((unsigned)400<<0)},// NEC leader 9500us,max 477: (477* timebase = 20) = 9540 ;min 400 = 8000us
-	{LDR_IDLE-0x100, 248<<16 | 202<<0},// leader idle
-	{LDR_REPEAT-0x100,130<<16|110<<0}, // leader repeat
-	{DURATION_REG0-0x100,60<<16|48<<0 },// logic '0' or '00'
-	{OPERATION_CTRL_REG0-0x100,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame 108ms
-	{DURATION_REG1_AND_STATUS-0x100,(111<<20)|(100<<10)}, // logic '1' or '01'
-	{OPERATION_CTRL_REG1-0x100,0xbe00},// boby long decode (9-13)
-	// used new decode
-	{LDR_ACTIVE,((unsigned)300<<16) | ((unsigned)160<<0)},//toshiba leader 4500us,20* timebase
-	{LDR_IDLE, 300<<16 | 160<<0},// leader idle 4500
-	{LDR_REPEAT,300<<16|160<<0}, // leader repeat
-	{DURATION_REG0,90<<16|48<<0 },// logic '0' or '00' 1200us
-	{OPERATION_CTRL_REG0,3<<28|(0xFA0<<12)|0x13},  // sys clock boby time.base time = 20 body frame
-	{DURATION_REG1_AND_STATUS,(150<<20)|(100<<10)}, // logic '1' or '01'     2400us
-	{OPERATION_CTRL_REG1,0x9f40},// boby long decode (8-13) //framn len = 24bit
-	{OPERATION_CTRL_REG2,0x5},
-	{DURATION_REG2,0},
-	{DURATION_REG3,0},
-	{CONFIG_END,            0      }
-};
 static const remotereg_t RDECODEMODE_RC5[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
-	{DURATION_REG0, },
-	{OPERATION_CTRL_REG0,},
-	{DURATION_REG1_AND_STATUS,},
+	{LDR_REPEAT,	},
+	{DURATION_REG0, },          
+	{OPERATION_CTRL_REG0,},               
+	{DURATION_REG1_AND_STATUS,},        
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},
+	{DURATION_REG3,},  
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_RESERVED[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
-	{DURATION_REG0, },
-	{OPERATION_CTRL_REG0,},
-	{DURATION_REG1_AND_STATUS,},
+	{LDR_REPEAT,	},
+	{DURATION_REG0, },          
+	{OPERATION_CTRL_REG0,},               
+	{DURATION_REG1_AND_STATUS,},        
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},
+	{DURATION_REG3,},  
 	{CONFIG_END,            0      }
 };
 static const remotereg_t RDECODEMODE_RC6[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
-	{DURATION_REG0, },
-	{OPERATION_CTRL_REG0,},
-	{DURATION_REG1_AND_STATUS,},
+	{LDR_REPEAT,	},
+	{DURATION_REG0, },          
+	{OPERATION_CTRL_REG0,},               
+	{DURATION_REG1_AND_STATUS,},        
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},
+	{DURATION_REG3,},  
 	{CONFIG_END,            0      }
 };
 
@@ -331,14 +283,14 @@ static const remotereg_t RDECODEMODE_RC6[] = {
 static const remotereg_t RDECODEMODE_SANYO[] = {
 	{LDR_ACTIVE,    },
 	{LDR_IDLE,     },
-	{LDR_REPEAT,    },
-	{DURATION_REG0, },
-	{OPERATION_CTRL_REG0,},
-	{DURATION_REG1_AND_STATUS,},
+	{LDR_REPEAT,	},
+	{DURATION_REG0, },          
+	{OPERATION_CTRL_REG0,},               
+	{DURATION_REG1_AND_STATUS,},        
 	{OPERATION_CTRL_REG1,},
 	{OPERATION_CTRL_REG2,},
 	{DURATION_REG2,},
-	{DURATION_REG3,},
+	{DURATION_REG3,},  
 	{CONFIG_END,            0      }
 };
 
@@ -357,52 +309,51 @@ void setremotereg(const remotereg_t *r);
 
 
 //remote config  ioctl  cmd
-#define REMOTE_IOC_INFCODE_CONFIG       _IOW_BAD('I',13,sizeof(short))
-#define REMOTE_IOC_RESET_KEY_MAPPING        _IOW_BAD('I',3,sizeof(short))
-#define REMOTE_IOC_SET_KEY_MAPPING          _IOW_BAD('I',4,sizeof(short))
+#define REMOTE_IOC_INFCODE_CONFIG	    _IOW_BAD('I',13,sizeof(short))
+#define REMOTE_IOC_RESET_KEY_MAPPING	    _IOW_BAD('I',3,sizeof(short))
+#define REMOTE_IOC_SET_KEY_MAPPING		    _IOW_BAD('I',4,sizeof(short))
 #define REMOTE_IOC_SET_REPEAT_KEY_MAPPING   _IOW_BAD('I',20,sizeof(short))
-#define REMOTE_IOC_SET_MOUSE_MAPPING        _IOW_BAD('I',5,sizeof(short))
-#define REMOTE_IOC_SET_REPEAT_DELAY         _IOW_BAD('I',6,sizeof(short))
-#define REMOTE_IOC_SET_REPEAT_PERIOD        _IOW_BAD('I',7,sizeof(short))
+#define REMOTE_IOC_SET_MOUSE_MAPPING	    _IOW_BAD('I',5,sizeof(short))
+#define REMOTE_IOC_SET_REPEAT_DELAY		    _IOW_BAD('I',6,sizeof(short))
+#define REMOTE_IOC_SET_REPEAT_PERIOD	    _IOW_BAD('I',7,sizeof(short))
 
-#define REMOTE_IOC_SET_REPEAT_ENABLE        _IOW_BAD('I',8,sizeof(short))
-#define REMOTE_IOC_SET_DEBUG_ENABLE         _IOW_BAD('I',9,sizeof(short))
-#define REMOTE_IOC_SET_MODE                 _IOW_BAD('I',10,sizeof(short))
-
-#define REMOTE_IOC_SET_CUSTOMCODE       _IOW_BAD('I',100,sizeof(short))
-#define REMOTE_IOC_SET_RELEASE_DELAY        _IOW_BAD('I',99,sizeof(short))
+#define REMOTE_IOC_SET_REPEAT_ENABLE		_IOW_BAD('I',8,sizeof(short))
+#define	REMOTE_IOC_SET_DEBUG_ENABLE			_IOW_BAD('I',9,sizeof(short))
+#define	REMOTE_IOC_SET_MODE					_IOW_BAD('I',10,sizeof(short))
 
+#define REMOTE_IOC_SET_RELEASE_DELAY		_IOW_BAD('I',99,sizeof(short))
+#define REMOTE_IOC_SET_CUSTOMCODE   		_IOW_BAD('I',100,sizeof(short))
 //reg
-#define REMOTE_IOC_SET_REG_BASE_GEN         _IOW_BAD('I',101,sizeof(short))
-#define REMOTE_IOC_SET_REG_CONTROL          _IOW_BAD('I',102,sizeof(short))
-#define REMOTE_IOC_SET_REG_LEADER_ACT       _IOW_BAD('I',103,sizeof(short))
-#define REMOTE_IOC_SET_REG_LEADER_IDLE      _IOW_BAD('I',104,sizeof(short))
-#define REMOTE_IOC_SET_REG_REPEAT_LEADER    _IOW_BAD('I',105,sizeof(short))
-#define REMOTE_IOC_SET_REG_BIT0_TIME         _IOW_BAD('I',106,sizeof(short))
+#define REMOTE_IOC_SET_REG_BASE_GEN			_IOW_BAD('I',101,sizeof(short))
+#define REMOTE_IOC_SET_REG_CONTROL			_IOW_BAD('I',102,sizeof(short))
+#define REMOTE_IOC_SET_REG_LEADER_ACT 		_IOW_BAD('I',103,sizeof(short))
+#define REMOTE_IOC_SET_REG_LEADER_IDLE 		_IOW_BAD('I',104,sizeof(short))
+#define REMOTE_IOC_SET_REG_REPEAT_LEADER 	_IOW_BAD('I',105,sizeof(short))
+#define REMOTE_IOC_SET_REG_BIT0_TIME		 _IOW_BAD('I',106,sizeof(short))
 
 //sw
-#define REMOTE_IOC_SET_BIT_COUNT            _IOW_BAD('I',107,sizeof(short))
-#define REMOTE_IOC_SET_TW_LEADER_ACT        _IOW_BAD('I',108,sizeof(short))
-#define REMOTE_IOC_SET_TW_BIT0_TIME         _IOW_BAD('I',109,sizeof(short))
-#define REMOTE_IOC_SET_TW_BIT1_TIME         _IOW_BAD('I',110,sizeof(short))
-#define REMOTE_IOC_SET_TW_REPEATE_LEADER    _IOW_BAD('I',111,sizeof(short))
-
-#define REMOTE_IOC_GET_TW_LEADER_ACT        _IOR_BAD('I',112,sizeof(short))
-#define REMOTE_IOC_GET_TW_BIT0_TIME         _IOR_BAD('I',113,sizeof(short))
-#define REMOTE_IOC_GET_TW_BIT1_TIME         _IOR_BAD('I',114,sizeof(short))
-#define REMOTE_IOC_GET_TW_REPEATE_LEADER    _IOR_BAD('I',115,sizeof(short))
-
-#define REMOTE_IOC_GET_REG_BASE_GEN         _IOR_BAD('I',121,sizeof(short))
-#define REMOTE_IOC_GET_REG_CONTROL          _IOR_BAD('I',122,sizeof(short))
-#define REMOTE_IOC_GET_REG_LEADER_ACT       _IOR_BAD('I',123,sizeof(short))
-#define REMOTE_IOC_GET_REG_LEADER_IDLE      _IOR_BAD('I',124,sizeof(short))
-#define REMOTE_IOC_GET_REG_REPEAT_LEADER    _IOR_BAD('I',125,sizeof(short))
-#define REMOTE_IOC_GET_REG_BIT0_TIME        _IOR_BAD('I',126,sizeof(short))
-#define REMOTE_IOC_GET_REG_FRAME_DATA       _IOR_BAD('I',127,sizeof(short))
-#define REMOTE_IOC_GET_REG_FRAME_STATUS     _IOR_BAD('I',128,sizeof(short))
-
-#define REMOTE_IOC_SET_TW_BIT2_TIME         _IOW_BAD('I',129,sizeof(short))
-#define REMOTE_IOC_SET_TW_BIT3_TIME         _IOW_BAD('I',130,sizeof(short))
+#define REMOTE_IOC_SET_BIT_COUNT		 	_IOW_BAD('I',107,sizeof(short))
+#define REMOTE_IOC_SET_TW_LEADER_ACT		_IOW_BAD('I',108,sizeof(short))
+#define REMOTE_IOC_SET_TW_BIT0_TIME			_IOW_BAD('I',109,sizeof(short))
+#define REMOTE_IOC_SET_TW_BIT1_TIME			_IOW_BAD('I',110,sizeof(short))
+#define REMOTE_IOC_SET_TW_REPEATE_LEADER	_IOW_BAD('I',111,sizeof(short))
+
+#define REMOTE_IOC_GET_TW_LEADER_ACT		_IOR_BAD('I',112,sizeof(short))
+#define REMOTE_IOC_GET_TW_BIT0_TIME			_IOR_BAD('I',113,sizeof(short))
+#define REMOTE_IOC_GET_TW_BIT1_TIME			_IOR_BAD('I',114,sizeof(short))
+#define REMOTE_IOC_GET_TW_REPEATE_LEADER	_IOR_BAD('I',115,sizeof(short))
+
+#define REMOTE_IOC_GET_REG_BASE_GEN			_IOR_BAD('I',121,sizeof(short))
+#define REMOTE_IOC_GET_REG_CONTROL			_IOR_BAD('I',122,sizeof(short))
+#define REMOTE_IOC_GET_REG_LEADER_ACT 		_IOR_BAD('I',123,sizeof(short))
+#define REMOTE_IOC_GET_REG_LEADER_IDLE 		_IOR_BAD('I',124,sizeof(short))
+#define REMOTE_IOC_GET_REG_REPEAT_LEADER 	_IOR_BAD('I',125,sizeof(short))
+#define REMOTE_IOC_GET_REG_BIT0_TIME	 	_IOR_BAD('I',126,sizeof(short))
+#define REMOTE_IOC_GET_REG_FRAME_DATA		_IOR_BAD('I',127,sizeof(short))
+#define REMOTE_IOC_GET_REG_FRAME_STATUS		_IOR_BAD('I',128,sizeof(short))
+
+#define REMOTE_IOC_SET_TW_BIT2_TIME			_IOW_BAD('I',129,sizeof(short))
+#define REMOTE_IOC_SET_TW_BIT3_TIME			_IOW_BAD('I',130,sizeof(short))
 
 #define   REMOTE_IOC_SET_FN_KEY_SCANCODE     _IOW_BAD('I', 131, sizeof(short))
 #define   REMOTE_IOC_SET_LEFT_KEY_SCANCODE   _IOW_BAD('I', 132, sizeof(short))
@@ -412,13 +363,13 @@ void setremotereg(const remotereg_t *r);
 #define   REMOTE_IOC_SET_OK_KEY_SCANCODE     _IOW_BAD('I', 136, sizeof(short))
 #define   REMOTE_IOC_SET_PAGEUP_KEY_SCANCODE _IOW_BAD('I', 137, sizeof(short))
 #define   REMOTE_IOC_SET_PAGEDOWN_KEY_SCANCODE _IOW_BAD('I', 138, sizeof(short))
-#define   REMOTE_IOC_SET_RELT_DELAY     _IOW_BAD('I',140,sizeof(short))
+#define   REMOTE_IOC_SET_RELT_DELAY	    _IOW_BAD('I',140,sizeof(short))
 
-#define REMOTE_HW_DECODER_STATUS_MASK       (0xf<<4)
-#define REMOTE_HW_DECODER_STATUS_OK         (0<<4)
-#define REMOTE_HW_DECODER_STATUS_TIMEOUT    (1<<4)
-#define REMOTE_HW_DECODER_STATUS_LEADERERR  (2<<4)
-#define REMOTE_HW_DECODER_STATUS_REPEATERR  (3<<4)
+#define	REMOTE_HW_DECODER_STATUS_MASK		(0xf<<4)
+#define	REMOTE_HW_DECODER_STATUS_OK			(0<<4)
+#define	REMOTE_HW_DECODER_STATUS_TIMEOUT	(1<<4)
+#define	REMOTE_HW_DECODER_STATUS_LEADERERR	(2<<4)
+#define	REMOTE_HW_DECODER_STATUS_REPEATERR	(3<<4)
 
 /* software  decode status*/
 #define REMOTE_STATUS_WAIT       0
@@ -430,8 +381,8 @@ void setremotereg(const remotereg_t *r);
 #define KEYDOMIAN 1 // find key val vail data domain
 #define CUSTOMDOMAIN 0 // find key val vail custom domain
 /*phy page user debug*/
-#define REMOTE_LOG_BUF_LEN       4098
-#define REMOTE_LOG_BUF_ORDER        1
+#define REMOTE_LOG_BUF_LEN		 8192
+#define REMOTE_LOG_BUF_ORDER		1
 
 
 typedef int (*type_printk)(const char *fmt, ...);
@@ -447,14 +398,13 @@ struct remote {
 	int irq;
 	int save_mode;
 	int work_mode; // use ioctl config decode mode
-	int temp_work_mode; // use ioctl config decode mode
 	int frame_mode;// same protocol frame have diffrent mode
 	unsigned int register_data;
 	unsigned int frame_status;
 	unsigned int cur_keycode;
 	unsigned int cur_lsbkeycode; // rcv low 32bit save
 	unsigned int cur_msbkeycode; // rcv high 10bit save
-	unsigned int repeat_release_code;// save
+	unsigned int repeat_release_code;// save 
 	unsigned int last_keycode;
 	unsigned int repeate_flag;
 	unsigned int repeat_enable;
@@ -468,7 +418,7 @@ struct remote {
 	//use duble protocol release time
 	unsigned int release_fdelay; //frist protocol
 	unsigned int release_sdelay;// second protocol
-	unsigned int release_delay[20];
+	unsigned int release_delay;
 	// debug swtich
 	unsigned int debug_enable;
 	//sw
@@ -490,9 +440,9 @@ struct remote {
 	char config_name[20];
 	struct class *config_class;
 	struct device *config_dev;
-	unsigned int repeat_delay[20];
-	unsigned int relt_delay[20];
-	unsigned int repeat_peroid[20];
+	unsigned int repeat_delay;
+	unsigned int relt_delay;
+	unsigned int repeat_peroid;
 	//
 	int (*remote_reprot_press_key)(struct remote *);
 	int (*key_report)(struct remote *);
@@ -508,18 +458,15 @@ void kdb_send_key(struct input_dev *dev, unsigned int scancode,unsigned int type
 void remote_send_key(struct input_dev *dev, unsigned int scancode,
 		unsigned int type,int event);
 extern irqreturn_t remote_bridge_isr(int irq, void *dev_id);
-extern irqreturn_t remote_null_bridge_isr(int irq, void *dev_id);
-extern int remote_hw_reprot_null_key(struct remote *remote_data);
 extern int remote_hw_reprot_key(struct remote *remote_data);
-extern int remote_hw_nec_rca_2in1_reprot_key(struct remote *remote_data);
-extern int remote_hw_nec_toshiba_2in1_reprot_key(struct remote *remote_data);
 extern int remote_sw_reprot_key(struct remote *remote_data);
 extern void remote_nec_report_release_key(struct remote *remote_data);
-extern void remote_nec_rca_2in1_report_release_key(struct remote *remote_data);
-extern void remote_nec_toshiba_2in1_report_release_key(struct remote *remote_data);
 extern void remote_duokan_report_release_key(struct remote *remote_data);
 extern void remote_sw_reprot_release_key(struct remote *remote_data);
-extern void remote_null_reprot_release_key(struct remote *remote_data);
+
+
+
+
 extern int register_fiq_bridge_handle(bridge_item_t * c_item);
 extern int unregister_fiq_bridge_handle(bridge_item_t * c_item);
 extern int fiq_bridge_pulse_trigger(bridge_item_t * c_item);
diff --git a/drivers/amlogic/rtc/Kconfig b/drivers/amlogic/rtc/Kconfig
old mode 100755
new mode 100644
index 7c335d2..9522399
--- a/drivers/amlogic/rtc/Kconfig
+++ b/drivers/amlogic/rtc/Kconfig
@@ -1,9 +1,11 @@
-# Amlogic RTC
-
-
-config AML_RTC
-    bool "RTC support"
-    default y
-    select RTC_CLASS
-    help
-      This is the Amlogic internal RTC driver
+# Amlogic RTC
+
+
+config AML_RTC
+    bool "RTC support"
+    default y
+    select RTC_CLASS
+    help
+      This is the Amlogic internal RTC driver
+      
+
diff --git a/drivers/amlogic/rtc/Makefile b/drivers/amlogic/rtc/Makefile
old mode 100755
new mode 100644
index 91d9a79..4135450
--- a/drivers/amlogic/rtc/Makefile
+++ b/drivers/amlogic/rtc/Makefile
@@ -1,4 +1,4 @@
-#
-#Makefile for the rtc dirver
-#
+#
+#Makefile for the rtc dirver
+#
 obj-$(CONFIG_AML_RTC)+= aml_rtc.o
\ No newline at end of file
diff --git a/drivers/amlogic/rtc/aml.dtd b/drivers/amlogic/rtc/aml.dtd
old mode 100755
new mode 100644
diff --git a/drivers/amlogic/rtc/aml_rtc.c b/drivers/amlogic/rtc/aml_rtc.c
old mode 100755
new mode 100644
index 3031fe0..baf5f09
--- a/drivers/amlogic/rtc/aml_rtc.c
+++ b/drivers/amlogic/rtc/aml_rtc.c
@@ -1,970 +1,960 @@
-/*
-* this driver is written for the internal rtc for M1
-*/
-
-#include<linux/module.h>
-#include<linux/platform_device.h>
-#include<linux/rtc.h>
-#include<linux/slab.h>
-#include<asm/delay.h>
-#include<mach/am_regs.h>
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-#include <plat/io.h>
-#endif
-
- #include <linux/of.h>
-
-int c_dbg_lvl = 0;
-#define RTC_DBG(lvl, x...) do{ if (c_dbg_lvl & lvl) printk(x);} while (0)
-#define RTC_DBG_VAL 1 << 0
-#define RTC_DBG_WR 1 << 1
-
-// Define register AO_RTC_ADDR0 bit map
-#define RTC_REG0_BIT_sclk_static	20
-#define RTC_REG0_BIT_ildo_ctrl_1	7
-#define RTC_REG0_BIT_ildo_ctrl_0	6
-#define RTC_REG0_BIT_test_mode		5
-#define RTC_REG0_BIT_test_clk		4
-#define RTC_REG0_BIT_test_bypass	3
-#define RTC_REG0_BIT_sdi		2
-#define RTC_REG0_BIT_sen		1
-#define RTC_REG0_BIT_sclk		0
-
-// Define register AO_RTC_ADDR1 bit map
-#define RTC_REG1_BIT_gpo_to_dig		3
-#define RTC_REG1_BIT_gpi_to_dig		2
-#define RTC_REG1_BIT_s_ready		1
-#define RTC_REG1_BIT_sdo		0
-
-// Define register AO_RTC_ADDR3 bit map
-#define RTC_REG3_BIT_count_always	17
-
-// Define RTC serial protocal
-#define RTC_SER_DATA_BITS		32
-#define RTC_SER_ADDR_BITS		3
-
-
-#define s_ready				1 << RTC_REG1_BIT_s_ready
-#define s_do				1 << RTC_REG1_BIT_sdo
-#define RESET_RETRY_TIMES		3
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-#if (defined(CONFIG_MESON_TRUSTZONE) && defined(CONFIG_ARCH_MESON6))
-#include <mach/meson-secure.h>
-#define WR_RTC(addr, data)		meson_secure_reg_write(P_##addr, data)
-#define RD_RTC(addr)			meson_secure_reg_read(P_##addr)
-#else
-#define WR_RTC(addr, data)		aml_write_reg32(P_##addr, data)
-#define RD_RTC(addr)			aml_read_reg32(P_##addr)
-#endif
-#else
-#define WR_RTC(addr, data)		WRITE_AOBUS_REG(addr, data)
-#define RD_RTC(addr)			READ_AOBUS_REG(addr)
-#endif
-
-#define RTC_sbus_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & \
-					~((1<<RTC_REG0_BIT_sen)|(1<<RTC_REG0_BIT_sclk)|(1<<RTC_REG0_BIT_sdi))))
-
-#define RTC_sdi_HIGH(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sdi) ))
-
-#define RTC_sdi_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sdi) ))
-
-#define RTC_sen_HIGH(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sen) ))
-
-#define RTC_sen_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sen) ))
-
-#define RTC_sclk_HIGH(x)		WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk)))
-
-#define RTC_sclk_LOW(x)			WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk)))
-
-#define RTC_sdo_READBIT			(RD_RTC(AO_RTC_ADDR1)&(1<<RTC_REG1_BIT_sdo))
-
-#define RTC_sclk_static_HIGH(x)		WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk_static)))
-
-#define RTC_sclk_static_LOW(x)		WR_RTC(AO_RTC_ADDR0, \
-					(RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk_static)))
-
-#define RTC_count_always_HIGH(x)	WR_RTC(AO_RTC_ADDR3, \
-					(RD_RTC(AO_RTC_ADDR3) |(1<<RTC_REG3_BIT_count_always)))
-#define RTC_count_always_LOW(x)		WR_RTC(AO_RTC_ADDR3, \
-					(RD_RTC(AO_RTC_ADDR3) & ~(1<<RTC_REG3_BIT_count_always)))
-
-#define RTC_Sdo_READBIT			RD_RTC(AO_RTC_ADDR1)&s_do`
-
-
-//#define RTC_SER_REG_DATA_NOTIFIER   0xb41b// Define RTC register address mapping
-
-//#define P_ISA_TIMERE			(volatile unsigned long *)0xc1109954
-
-// Define RTC register address mapping
-#define RTC_COUNTER_ADDR		0
-#define RTC_GPO_COUNTER_ADDR		1
-#define RTC_SEC_ADJUST_ADDR		2
-#define RTC_UNUSED_ADDR_0		3
-#define RTC_REGMEM_ADDR_0		4
-#define RTC_REGMEM_ADDR_1		5
-#define RTC_REGMEM_ADDR_2		6
-#define RTC_REGMEM_ADDR_3		7
-
-static int  check_osc_clk(void);
-
-int get_rtc_status(void)
-{
-	static int rtc_fail = -1;
-	//if (rtc_fail < 0) {
-		if (check_osc_clk() < 0) {
-			printk("rtc clock error\n");
-			rtc_fail = 1;
-		} else
-			rtc_fail = 0;
-	//}
-	return rtc_fail;
-}
-static DEFINE_SPINLOCK(com_lock);
-
-struct aml_rtc_priv{
-	struct 				rtc_device *rtc;
-  unsigned long base_addr;
-	struct timer_list timer;
-	struct work_struct work;
-	struct workqueue_struct *rtc_work_queue;
-};
-
-static void reset_gpo_work(struct work_struct *work);
-static int get_gpo_flag(void);
-
-static void delay_us(int us)
-{
-	udelay(us);
-}
-
-static void rtc_comm_delay(void)
-{
-	delay_us(5);
-}
-
-static void rtc_sclk_pulse(void)
-{
-	//unsigned flags;
-
-	//local_irq_save(flags);
-
-	rtc_comm_delay();
-	RTC_sclk_HIGH(1);
-	rtc_comm_delay();
-	RTC_sclk_LOW(0);
-
-	//local_irq_restore(flags);
-}
-
-#if 1
-static int  check_osc_clk(void)
-{
-	unsigned long   osc_clk_count1;
-	unsigned long   osc_clk_count2;
-
-	// Enable count always
-	WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3) | (1 << 17));
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- check os clk_1\n");
-	/* Wait for 50uS.  32.768khz is 30.5uS.  This should be long
-	   enough for one full cycle of 32.768 khz
-	*/
-	osc_clk_count1 = RD_RTC(AO_RTC_ADDR2);
-
-	RTC_DBG(RTC_DBG_VAL, "the aml_rtc os clk 1 is %d\n",
-				(unsigned int)osc_clk_count1);
-	delay_us( 50 );
-	osc_clk_count2 = RD_RTC(AO_RTC_ADDR2);
-	RTC_DBG(RTC_DBG_VAL, "the aml_rtc os clk 2 is %d\n",
-				(unsigned int)osc_clk_count2);
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- check os clk_2\n");
-	// disable count always
-	WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3) & ~(1 << 17));
-
-	if ( osc_clk_count1 == osc_clk_count2 ) {
-		RTC_DBG(RTC_DBG_VAL, "The osc_clk is not running now!"
-				" need to invcrease the power!\n");
-		return(-1);
-	}
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc : check_os_clk\n");
-
-	return(0);
-
-}
-#endif
-void rtc_ser_static_write_auto (unsigned long static_reg_data_in)
-{
-	unsigned long data32;
-
-	// Program MSB 15-8
-	data32  = (static_reg_data_in >> 8) & 0xff;
-	//WRITE_AOBUS_REG(AO_RTC_ADDR4,data32);
-	WR_RTC(AO_RTC_ADDR4, data32);
-
-	// Program LSB 7-0, and start serializing
-	//data32  = READ_AOBUS_REG(AO_RTC_ADDR0);
-	data32  = RD_RTC(AO_RTC_ADDR0);
-	data32 |= 1 << 17; // auto_serialize_start
-	data32 &= ~(0xff << 24);
-	data32 |= (static_reg_data_in & 0xff) << 24; // auto_static_reg
-	//WRITE_AOBUS_REG(AO_RTC_ADDR0,data32);
-	WR_RTC(AO_RTC_ADDR0,data32);
-	// Poll auto_serializer_busy bit until it's low (IDLE)
-	//while ((READ_AOBUS_REG(AO_RTC_ADDR0)) & 1<<22) {}
-	while ((RD_RTC(AO_RTC_ADDR0)) & 1<<22) {}
-}
-
-
-static void rtc_reset_s_ready(void)
-{
-	//RTC_RESET_BIT_HIGH(1);
-	delay_us(100);
-	return;
-}
-
-static int rtc_wait_s_ready(void)
-{
-	int i = 40000;
-	int try_cnt = 0;
-	if (get_rtc_status())
-		return i;
-	/*
-	while (i--) {
-		if ((*(volatile unsigned *)AO_RTC_ADDR1)&s_ready)
-			break;
-		}
-	return i;
-	*/
-	while (!(RD_RTC(AO_RTC_ADDR1)&s_ready)) {
-		i--;
-		if (i == 0) {
-			if (try_cnt > RESET_RETRY_TIMES) {
-				break;
-			}
-			rtc_reset_s_ready();
-			try_cnt++;
-			i = 40000;
-		}
-	}
-
-	return i;
-}
-
-
-static int rtc_comm_init(void)
-{
-	RTC_sbus_LOW(0);
-	if (rtc_wait_s_ready()>0) {
-		RTC_sen_HIGH(1);
-		return 0;
-	}
-	return -1;
-}
-
-
-static void rtc_send_bit(unsigned val)
-{
-	if (val)
-		RTC_sdi_HIGH(1);
-	else
-		RTC_sdi_LOW(0);
-	rtc_sclk_pulse();
-}
-
-static void rtc_send_addr_data(unsigned type, unsigned val)
-{
-	unsigned cursor = (type? (1<<(RTC_SER_ADDR_BITS-1))
-				: (1<<(RTC_SER_DATA_BITS-1)));
-
-	while (cursor) {
-		rtc_send_bit(val&cursor);
-		cursor >>= 1;
-	}
-}
-
-static void rtc_get_data(unsigned *val)
-{
-	int i;
-	RTC_DBG(RTC_DBG_VAL, "rtc-aml -- rtc get data \n");
-	for (i=0; i<RTC_SER_DATA_BITS; i++) {
-		rtc_sclk_pulse();
-		*val <<= 1;
-		*val  |= RTC_sdo_READBIT;
-	}
-}
-
-static void rtc_set_mode(unsigned mode)
-{
-	RTC_sen_LOW(0);
-	if (mode)
-		RTC_sdi_HIGH (1);//WRITE
-	else
-		RTC_sdi_LOW(0);  //READ
-		rtc_sclk_pulse();
-		RTC_sdi_LOW(0);
-}
-
-static void static_register_write(unsigned data);
-static void _ser_access_write_locked(unsigned long addr, unsigned long data);
-static void aml_rtc_reset(void)
-{
-	if (get_rtc_status())
-		return;
-	printk("error, the rtc serial communication abnormal,"
-		" reset the rtc!\n");
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	WRITE_AOBUS_REG(AO_RTI_GEN_CNTL_REG0,
-			READ_AOBUS_REG(AO_RTI_GEN_CNTL_REG0)|1<<21);
-	udelay(5);
-	WRITE_AOBUS_REG(AO_RTI_GEN_CNTL_REG0,
-			READ_AOBUS_REG(AO_RTI_GEN_CNTL_REG0)&(~(1<<21)));
-	static_register_write(0x180a);
-	_ser_access_write_locked(RTC_GPO_COUNTER_ADDR,0x500000);
-#else
-	WRITE_CBUS_REG(RESET3_REGISTER, 0x1<<3);
-#endif
-}
-
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-extern int run_arc_program_rtc(void);
-extern int stop_ao_cpu(void);
-#endif
-
-static unsigned int _ser_access_read_locked(unsigned long addr)
-{
-	unsigned val = 0;
-	int s_nrdy_cnt = 0;
-	int rst_times = 0;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	int ret = 0;
-#endif
-	if (get_rtc_status())
-		return 0;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	ret = stop_ao_cpu();
-#endif
-	while (rtc_comm_init()<0) {
-		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- rtc_common_init fail\n");
-		if (s_nrdy_cnt>RESET_RETRY_TIMES) {
-			s_nrdy_cnt = 0;
-			rst_times++;
-			if (rst_times > 3) {
-				printk("_ser_access_read_locked error\n");
-				goto out;
-			}
-			aml_rtc_reset();
-		}
-		rtc_reset_s_ready( );
-		s_nrdy_cnt++;
-	}
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- ser_access_read_3\n");
-	rtc_send_addr_data(1,addr);
-	rtc_set_mode(0); //Read
-	rtc_get_data(&val);
-out:
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	if (ret >= 0)
-		run_arc_program_rtc();
-#endif
-	return val;
-}
-
-static void _ser_access_write_locked(unsigned long addr, unsigned long data)
-{
-	int s_nrdy_cnt = 0;
-	int rst_times = 0;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	int ret = 0;
-#endif
-	if (get_rtc_status())
-		return;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	ret = stop_ao_cpu();
-#endif
-	while (rtc_comm_init()<0) {
-
-		if (s_nrdy_cnt>RESET_RETRY_TIMES) {
-			s_nrdy_cnt = 0;
-			rst_times++;
-			if (rst_times > 3) {
-				printk("_ser_access_write_locked error\n");
-				goto out;
-			}
-			aml_rtc_reset();
-			printk("error: rtc serial communication abnormal!\n");
-			//return -1;
-		}
-		rtc_reset_s_ready( );
-		s_nrdy_cnt++;
-	}
-	rtc_send_addr_data(0,data);
-	rtc_send_addr_data(1,addr);
-	rtc_set_mode(1); //Write
-out:
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-	if (ret >= 0)
-		run_arc_program_rtc();
-#endif
-	return;
-}
-
-static unsigned int ser_access_read(unsigned long addr)
-{
-	unsigned val = 0;
-	unsigned long flags;
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc --ser_access_read_1\n");
-	/*if (check_osc_clk() < 0) {
-		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- the osc clk does not work\n");
-		return val;
-	}*/
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- ser_access_read_2\n");
-	spin_lock_irqsave(&com_lock, flags);
-	val = _ser_access_read_locked(addr);
-	spin_unlock_irqrestore(&com_lock, flags);
-
-	return val;
-}
-
-static int ser_access_write(unsigned long addr, unsigned long data)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&com_lock, flags);
-	_ser_access_write_locked(addr, data);
-	spin_unlock_irqrestore(&com_lock, flags);
-	rtc_wait_s_ready();
-
-	return 0;
-}
-
-/***************************************************************************/
-int rtc_reset_gpo(struct device *dev, unsigned level)
-{
-	unsigned data = 0;
-	data |= 1<<20;
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	if (level) {
-		data |= 1<<22;	//gpo pin level high
-		}
-#else
-	//reset mode
-	if (!level) {
-		data |= 1<<22;	//gpo pin level high
-	}
-#endif
-
-	ser_access_write(RTC_GPO_COUNTER_ADDR, data);
-	rtc_wait_s_ready();
-
-	return 0;
-}
-
-typedef struct alarm_data_s {
-	int level;
-	unsigned alarm_sec;   //in s
-} alarm_data_t;
-
-/*
- * Return RTC_GPO_COUNTER bit-24 value.
- */
-int aml_rtc_alarm_status(void)
-{
-	u32 data32 = ser_access_read(RTC_GPO_COUNTER_ADDR);
-	RTC_DBG(RTC_DBG_VAL, "%s() RTC_GPO_COUNTER=%x\n", __func__, data32);
-	return (data32 & (1 << 24));
-}
-
-//set the rtc alarm
-//after alarm_data->alarm_sec, the gpo lvl will be //alarm_data->level
-int rtc_set_alarm_aml(struct device *dev, alarm_data_t *alarm_data) {
-	unsigned data = 0;
-	//reset the gpo level
-
-	rtc_reset_gpo(dev, !(alarm_data->level));
-
-	data |= 2 << 20;	//output defined level after time
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	data |= (alarm_data->level & 1) << 22;	//
-#else
-	data |= (!(alarm_data->level & 1)) << 22;	//
-#endif
-	if (alarm_data->alarm_sec >= 1024*1024) {
-		return -1;
-	}
-
-	data |= alarm_data->alarm_sec - 1;
-
-	printk("write alarm data: %u\n", data);
-	ser_access_write(RTC_GPO_COUNTER_ADDR, data);
-	rtc_wait_s_ready();
-	rtc_comm_delay();
-
-	data = ser_access_read(RTC_GPO_COUNTER_ADDR);
-
-	printk("read alarm data: %u\n", data);
-	printk("read alarm count: %u\n", ser_access_read(RTC_COUNTER_ADDR));
-
-	return 0;
-}
-
-/*************************************************************************/
-
-
-// -----------------------------------------------------------------------------
-//					Function: rtc_ser_static_write_manual
-// Use part of the serial bus: sclk_static, sdi and sen to shift
-// in a 16-bit static data. Manual mode.
-// -----------------------------------------------------------------------------
-//static void rtc_ser_static_write_manual (unsigned int static_reg_data_in)
-//{
-//	int i;
-//	RTC_DBG(RTC_DBG_VAL, "rtc_ser_static_write_manual: data=0x%0/x\n",
-//		static_reg_data_in);
-//
-//	// Initialize: sen low for 1 clock cycle
-//	RTC_sen_LOW(0);
-//	RTC_sclk_static_LOW(0);
-//	RTC_sclk_static_HIGH(1);
-//	RTC_sen_HIGH(1);
-//	RTC_sclk_static_LOW(0);
-//
-//		// Shift in 16-bit known sequence
-//	for (i = 15; i >= 0; i --) {
-//
-//		if ((RTC_SER_REG_DATA_NOTIFIER >> i) & 0x1) {
-//			RTC_sdi_HIGH(1);
-//		}
-//		else {
-//			RTC_sdi_LOW(0);
-//		}
-//
-//		RTC_sclk_static_HIGH(1);
-//		RTC_sclk_static_LOW(0);
-//	}
-//
-//	// 1 clock cycle turn around
-//	RTC_sdi_LOW(0);
-//	RTC_sclk_static_HIGH(1);
-//	RTC_sclk_static_LOW(0);
-//
-//	// Shift in 16-bit static register data
-//	for (i = 15; i >= 0; i --) {
-//		if ((static_reg_data_in >> i) & 0x1) {
-//			RTC_sdi_HIGH(1);
-//		}
-//		else {
-//			RTC_sdi_LOW(0);
-//		}
-//		RTC_sclk_static_HIGH(1);
-//		RTC_sclk_static_LOW(0);
-//	}
-//
-//	// One more clock cycle to complete write
-//	RTC_sen_LOW(0);
-//	RTC_sdi_LOW(0);
-//	RTC_sclk_static_HIGH(1);
-//	RTC_sclk_static_LOW(0);
-//}
-
-
-static void static_register_write(unsigned data)
-{
-	rtc_ser_static_write_auto(data);
-}
-
-static int aml_rtc_read_time(struct device *dev, struct rtc_time *tm)
-{
-	unsigned int time_t;
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc: read rtc time\n");
-	time_t = ser_access_read(RTC_COUNTER_ADDR);
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc: have read the rtc time,"
-			" time is %d\n", time_t);
-	if ((int)time_t < 0) {
-		RTC_DBG(RTC_DBG_VAL, "aml_rtc: time(%d) < 0,"
-				" reset to 0", time_t);
-		time_t = 0;
-	}
-	rtc_time_to_tm(time_t, tm);
-
-	return 0;
-}
-
-static int aml_rtc_write_time(struct device *dev, struct rtc_time *tm)
-{
-	unsigned long time_t;
-
-	rtc_tm_to_time(tm, &time_t);
-
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc : write the rtc time, "
-		"time is %ld\n", time_t);
-	ser_access_write(RTC_COUNTER_ADDR, time_t);
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc : the time has been written\n");
-
-	return 0;
-}
-
-static int aml_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
-{
-	alarm_data_t alarm_data;
-	unsigned long alarm_secs, cur_secs;
-	struct rtc_time cur_time;
-	int ret;
-	struct aml_rtc_priv *priv;
-
-	priv = dev_get_drvdata(dev);
-	//rtc_tm_to_time(&alarm->time, &secs);
-
-	if (alarm->enabled) {
-		alarm_data.level = 0;
-		ret = rtc_tm_to_time(&alarm->time, &alarm_secs);
-		if (ret)
-			return ret;
-		aml_rtc_read_time(dev, &cur_time);
-		ret = rtc_tm_to_time(&cur_time, &cur_secs);
-		if (alarm_secs >= cur_secs) {
-			/*3 seconds later then we real wanted,
-			  we do not need the alarm very acurate.*/
-			alarm_data.alarm_sec = alarm_secs - cur_secs + 3;
-		} else
-			alarm_data.alarm_sec =  0;
-
-		rtc_set_alarm_aml(dev, &alarm_data);
-	} else {
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif
-		queue_work(priv->rtc_work_queue, &priv->work);
-	}
-	return 0;
-}
-
-#define AUTO_RESUME_INTERVAL 8
-static int aml_rtc_suspend(struct platform_device *pdev, pm_message_t state)
-{
-#ifdef CONFIG_MESON_SUSPEND_TEST
-	alarm_data_t alarm_data;
-	static int suspend_time = 0;
-	alarm_data.alarm_sec = AUTO_RESUME_INTERVAL;
-		alarm_data.level = 0;
-	rtc_set_alarm_aml(&pdev->dev, &alarm_data);
-	printk("suspend %d times, system will up %ds later!\n",
-			++suspend_time, alarm_data.alarm_sec);
-#endif /* CONFIG_MESON_SUSPEND_TEST */
-	return 0;
-}
-int aml_rtc_resume(struct platform_device *pdev)
-{
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif
-
-	printk("resume reset gpo !\n");
-	return 0;
-}
-
-static char *rtc_reg[8]={
-	"RTC_COUNTER	",
-	"RTC_GPO_COUNTER",
-	"RTC_SEC_ADJUST ",
-	"UNUSED		 ",
-	"RTC_REGMEM_0   ",
-	"RTC_REGMEM_1   ",
-	"RTC_REGMEM_2   ",
-	"RTC_REGMEM_3   "
-};
-
-static ssize_t show_rtc_reg(struct class *class,
-			struct class_attribute *attr,	char *buf)
-{
-	int i;
-
-	printk("enter function: %s \n",__FUNCTION__);
-
-	for (i = 0; i < 8; i++) {
-		printk(" %20s : 0x%x \n",rtc_reg[i],ser_access_read(i));
-	}
-
-	return 0;
-}
-
-static const struct rtc_class_ops aml_rtc_ops ={
-	.read_time = aml_rtc_read_time,
-	.set_time = aml_rtc_write_time,
-	.set_alarm = aml_rtc_set_alarm,
-};
-
-static struct class_attribute rtc_class_attrs[] = {
-	__ATTR(rtc_reg_log, S_IRUGO | S_IWUSR, show_rtc_reg, NULL),
-	__ATTR_NULL
-};
-
-static struct class aml_rtc_class = {
-	.name = "aml_rtc",
-	.class_attrs = rtc_class_attrs,
-};
-
-
-#ifdef CONFIG_SECURITYKEY
-extern int get_aml_key_kernel(const char* key_name, unsigned char* data, int ascii_flag);
-extern int extenal_api_key_set_version(char *devvesion);
-#endif
-
-#define RTC_INIT_MARSK	0x13208d83
-extern unsigned int aml_read_rtc_mem_reg(unsigned char reg_id);
-extern int aml_write_rtc_mem_reg(unsigned char reg_id, unsigned int data);
-extern int board_has_battery(void);
-
-static int aml_rtc_probe(struct platform_device *pdev)
-{
-	struct aml_rtc_priv *priv;
-	struct device_node* aml_rtc_node = pdev->dev.of_node;
-	int ret;
-	int sec_adjust = 0;
-
-#ifdef CONFIG_SECURITYKEY
-	static char keyexamples[4096];
-#endif
-#ifdef CONFIG_SECURITYKEY
-	ret = extenal_api_key_set_version("auto3");
-	if (ret >=0) {
-		ret = get_aml_key_kernel("keyexample", keyexamples, 1);
-		if (ret >= 0) {
-			printk("key name:keyexample, key data:%s\n",keyexamples);
-		}
-		else{
-			printk("get keyexample fail, %s:%d\n",__func__,__LINE__);
-		}
-	}
-#endif
-
-	priv = (struct aml_rtc_priv *)kzalloc(sizeof(*priv), GFP_KERNEL);
-
-	if (!priv)
-		return -ENOMEM;
-
-	INIT_WORK(&priv->work, reset_gpo_work);
-	platform_set_drvdata(pdev, priv);
-
-	priv->rtc_work_queue = create_singlethread_workqueue("rtc");
-	if (priv->rtc_work_queue == NULL) {
-		ret = -ENOMEM;
-		goto out;
-	}
-
-	/* platform setup code should have handled this; sigh */
-	if (!device_can_wakeup(&pdev->dev))
-		device_init_wakeup(&pdev->dev, 1);
-
-	priv->rtc = rtc_device_register("aml_rtc", &pdev->dev, &
-						aml_rtc_ops, THIS_MODULE);
-
-	if (IS_ERR(priv->rtc)) {
-		ret = PTR_ERR(priv->rtc);
-		goto out;
-	}
-
-	//ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-	//static_register_write(0x0004);
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else
-	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif
-	rtc_wait_s_ready();
-
-	ret = of_property_read_u32(aml_rtc_node, "sec_adjust", &sec_adjust);
-	if (!ret) {
-		ser_access_write(RTC_SEC_ADJUST_ADDR, 1<<23 | 10<<19 | 1735 );
-		rtc_wait_s_ready();
-	}
-
-	//check_osc_clk();
-	if (!board_has_battery() &&
-		RTC_INIT_MARSK != aml_read_rtc_mem_reg(3)) {
-		ser_access_write(RTC_COUNTER_ADDR, 0);
-		aml_write_rtc_mem_reg(3, RTC_INIT_MARSK);
-	}
-
-	ret = class_register(&aml_rtc_class);
-	if (ret) {
-		printk(" class register nand_class fail!\n");
-	}
-
-	return 0;
-
-out:
-	if (priv->rtc_work_queue)
-		destroy_workqueue(priv->rtc_work_queue);
-	kfree(priv);
-	return ret;
-}
-
-static int get_gpo_flag(void)
-{
-	u32 data32 = 0;
-	int ret = 0;
-
-	data32 = ser_access_read(RTC_GPO_COUNTER_ADDR);
-
-	RTC_DBG(RTC_DBG_VAL, "%s() RTC_GPO_COUNTER=%x\n", __func__, data32);
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	ret = !(data32 & (1 << 24));
-#else
-	ret = !!(data32 & (1 << 24));
-#endif
-
-	return ret;
-}
-
-unsigned int aml_read_rtc_mem_reg(unsigned char reg_id)
-{
-	unsigned char reg_array[] = {
-		RTC_REGMEM_ADDR_0,
-		RTC_REGMEM_ADDR_1,
-		RTC_REGMEM_ADDR_2,
-		RTC_REGMEM_ADDR_3,
-	};
-	if (reg_id > 4)
-		return 0;
-	return  ser_access_read(reg_array[reg_id]);
-}
-EXPORT_SYMBOL(aml_read_rtc_mem_reg);
-
-int aml_write_rtc_mem_reg(unsigned char reg_id, unsigned int data)
-{
-	unsigned char reg_array[] = {
-		RTC_REGMEM_ADDR_0,
-		RTC_REGMEM_ADDR_1,
-		RTC_REGMEM_ADDR_2,
-		RTC_REGMEM_ADDR_3,
-	};
-	if (reg_id > 4)
-		return 0;
-	return  ser_access_write(reg_array[reg_id], data);
-}
-EXPORT_SYMBOL(aml_write_rtc_mem_reg);
-
-unsigned int aml_get_rtc_counter(void)
-{
-	unsigned int val;
-	val = ser_access_read(RTC_COUNTER_ADDR);
-	return val;
-}
-EXPORT_SYMBOL(aml_get_rtc_counter);
-
-static void reset_gpo_work(struct work_struct *work)
-{
-	int count = 5;
-
-	while (get_gpo_flag()) {
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else
-		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif
-		count--;
-		if (count <= 0) {
-			printk("error: can not reset gpo !\n");
-			//count = 5;
-			return;
-			//panic("gpo can not be reset");
-		}
-	}
-
-	printk("reset gpo !\n");
-
-}
-#if 0
-static int power_down_gpo(unsigned long data)
-{
-	struct aml_rtc_priv *priv = (struct aml_rtc_priv *)data;
-	queue_work(priv->rtc_work_queue, &priv->work);
-
-	return 0;
-}
-#endif
-static void aml_rtc_shutdown(struct platform_device *pdev)
-{
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
-#else
-	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
-#endif
-//	return 0;
-}
-
-static int aml_rtc_remove(struct platform_device *dev)
-{
-	struct aml_rtc_priv *priv = platform_get_drvdata(dev);
-	rtc_device_unregister(priv->rtc);
-	if (priv->rtc_work_queue)
-		destroy_workqueue(priv->rtc_work_queue);
-	del_timer(&priv->timer);
-	kfree(priv);
-	return 0;
-}
-
-//#ifdef CONFIG_OF
-static const struct of_device_id meson6_rtc_dt_match[]={
-	{ .compatible = "amlogic,aml_rtc"},
-	{},
-};
-/*#else
-#define meson6_rtc_dt_match NULL
-#endif*/
-
-struct platform_driver aml_rtc_driver = {
-	.driver = {
-		.name = "aml_rtc",
-		.owner = THIS_MODULE,
-		.of_match_table=meson6_rtc_dt_match,
-	},
-	.probe = aml_rtc_probe,
-//	.remove = __devexit_p(aml_rtc_remove),
-	.remove = (aml_rtc_remove),
-	.suspend = aml_rtc_suspend,
-	.resume=aml_rtc_resume,
-	.shutdown = aml_rtc_shutdown,
-};
-
-static int  __init aml_rtc_init(void)
-{
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	static_register_write(0x180a);
-#else
-	static_register_write(0x3c0a);
-#endif
-	RTC_DBG(RTC_DBG_VAL, "aml_rtc --aml_rtc_init\n");
-	return platform_driver_register(&aml_rtc_driver);
-}
-
-static void __init aml_rtc_exit(void)
-{
-	return platform_driver_unregister(&aml_rtc_driver);
-}
-
-module_init(aml_rtc_init);
-module_exit(aml_rtc_exit);
-
-MODULE_DESCRIPTION("Amlogic internal rtc driver");
-MODULE_LICENSE("GPL");
+/*
+* this driver is written for the internal rtc for M1
+*/
+
+#include<linux/module.h>
+#include<linux/platform_device.h>
+#include<linux/rtc.h>
+#include<linux/slab.h>
+#include<asm/delay.h>
+#include<mach/am_regs.h>
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#include <plat/io.h>
+#endif
+
+ #include <linux/of.h>
+
+int c_dbg_lvl = 0;
+#define RTC_DBG(lvl, x...) do{ if(c_dbg_lvl & lvl) printk(x);} while(0)
+#define RTC_DBG_VAL 1 << 0
+#define RTC_DBG_WR 1 << 1
+
+// Define register AO_RTC_ADDR0 bit map
+#define RTC_REG0_BIT_sclk_static     20
+#define RTC_REG0_BIT_ildo_ctrl_1      7
+#define RTC_REG0_BIT_ildo_ctrl_0      6
+#define RTC_REG0_BIT_test_mode      	5
+#define RTC_REG0_BIT_test_clk         4
+#define RTC_REG0_BIT_test_bypass    	3
+#define RTC_REG0_BIT_sdi              2
+#define RTC_REG0_BIT_sen              1
+#define RTC_REG0_BIT_sclk             0
+
+// Define register AO_RTC_ADDR1 bit map
+#define RTC_REG1_BIT_gpo_to_dig     	3
+#define RTC_REG1_BIT_gpi_to_dig      	2
+#define RTC_REG1_BIT_s_ready          1
+#define RTC_REG1_BIT_sdo              0
+
+// Define register AO_RTC_ADDR3 bit map
+#define RTC_REG3_BIT_count_always   	17
+
+// Define RTC serial protocal
+#define RTC_SER_DATA_BITS           	32
+#define RTC_SER_ADDR_BITS           	3
+
+
+#define s_ready                  			1 << RTC_REG1_BIT_s_ready  
+#define s_do                       		1 << RTC_REG1_BIT_sdo
+#define RESET_RETRY_TIMES           	3
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+#if (defined(CONFIG_MESON_TRUSTZONE) && defined(CONFIG_ARCH_MESON6))
+#include <mach/meson-secure.h>
+#define WR_RTC(addr, data)         meson_secure_reg_write(P_##addr, data)
+#define RD_RTC(addr)               meson_secure_reg_read(P_##addr)	
+#else
+#define WR_RTC(addr, data)         aml_write_reg32(P_##addr, data)
+#define RD_RTC(addr)               aml_read_reg32(P_##addr)	
+#endif
+#else
+#define WR_RTC(addr, data)         WRITE_AOBUS_REG(addr, data)
+#define RD_RTC(addr)                   READ_AOBUS_REG(addr)
+#endif
+
+#define RTC_sbus_LOW(x)             WR_RTC(AO_RTC_ADDR0, \
+                                                                      (RD_RTC(AO_RTC_ADDR0) & \
+                                                                      ~((1<<RTC_REG0_BIT_sen)|(1<<RTC_REG0_BIT_sclk)|(1<<RTC_REG0_BIT_sdi))))
+                                                                      
+#define RTC_sdi_HIGH(x)             WR_RTC(AO_RTC_ADDR0, \
+                                                                  (RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sdi) ))
+                                                                  
+#define RTC_sdi_LOW(x)               WR_RTC(AO_RTC_ADDR0, \
+                                                                   (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sdi) ))
+                                                                   
+#define RTC_sen_HIGH(x)             WR_RTC(AO_RTC_ADDR0, \
+                                                                   (RD_RTC(AO_RTC_ADDR0) | (1<<RTC_REG0_BIT_sen) ))
+                                                                   
+#define RTC_sen_LOW(x)               WR_RTC(AO_RTC_ADDR0, \
+                                                                    (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sen) ))
+                                                                    
+#define RTC_sclk_HIGH(x)             WR_RTC(AO_RTC_ADDR0, \
+                                                                    (RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk)))
+                                                                    
+#define RTC_sclk_LOW(x)               WR_RTC(AO_RTC_ADDR0, \
+                                                                      (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk)))
+                                                                      
+#define RTC_sdo_READBIT             (RD_RTC(AO_RTC_ADDR1)&(1<<RTC_REG1_BIT_sdo))
+
+#define RTC_sclk_static_HIGH(x)   WR_RTC(AO_RTC_ADDR0, \
+                                                                      (RD_RTC(AO_RTC_ADDR0) |(1<<RTC_REG0_BIT_sclk_static)))
+                                                                      
+#define RTC_sclk_static_LOW(x)      WR_RTC(AO_RTC_ADDR0, \
+                                                                        (RD_RTC(AO_RTC_ADDR0) & ~(1<<RTC_REG0_BIT_sclk_static)))
+
+#define RTC_count_always_HIGH(x)     WR_RTC(AO_RTC_ADDR3, \
+                                                                       (RD_RTC(AO_RTC_ADDR3) |(1<<RTC_REG3_BIT_count_always)))
+#define RTC_count_always_LOW(x)      WR_RTC(AO_RTC_ADDR3, \
+                                                                              (RD_RTC(AO_RTC_ADDR3) & ~(1<<RTC_REG3_BIT_count_always)))
+
+#define RTC_Sdo_READBIT                       RD_RTC(AO_RTC_ADDR1)&s_do`
+
+
+//#define RTC_SER_REG_DATA_NOTIFIER   0xb41b// Define RTC register address mapping
+
+//#define P_ISA_TIMERE                (volatile unsigned long *)0xc1109954
+
+// Define RTC register address mapping
+#define RTC_COUNTER_ADDR            0
+#define RTC_GPO_COUNTER_ADDR        1
+#define RTC_SEC_ADJUST_ADDR         2
+#define RTC_UNUSED_ADDR_0           3
+#define RTC_REGMEM_ADDR_0           4
+#define RTC_REGMEM_ADDR_1           5
+#define RTC_REGMEM_ADDR_2           6
+#define RTC_REGMEM_ADDR_3           7
+
+static int  check_osc_clk(void);
+
+int get_rtc_status(void)
+{
+	static int rtc_fail = -1;
+	//if (rtc_fail < 0) {
+		if (check_osc_clk() < 0) {
+			printk("rtc clock error\n");
+			rtc_fail = 1;
+		} else
+			rtc_fail = 0;
+	//}
+	return rtc_fail;
+}
+static DEFINE_SPINLOCK(com_lock);
+
+struct aml_rtc_priv{
+	struct 				rtc_device *rtc;
+  unsigned long base_addr;
+	struct timer_list timer;
+	struct work_struct work;
+	struct workqueue_struct *rtc_work_queue;
+};
+
+static void reset_gpo_work(struct work_struct *work);
+static int get_gpo_flag(void);
+
+static void delay_us(int us)
+{
+	udelay(us);
+}
+
+static void rtc_comm_delay(void)
+{        
+	delay_us(5);
+}
+
+static void rtc_sclk_pulse(void)
+{
+	//unsigned flags;
+	
+	//local_irq_save(flags);
+
+	rtc_comm_delay();
+	RTC_sclk_HIGH(1);
+	rtc_comm_delay();
+	RTC_sclk_LOW(0);
+
+	//local_irq_restore(flags);
+}
+
+#if 1
+static int  check_osc_clk(void)
+{
+	unsigned long   osc_clk_count1; 
+	unsigned long   osc_clk_count2; 
+
+	// Enable count always
+	WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3) | (1 << 17));       
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- check os clk_1\n");
+	/* Wait for 50uS.  32.768khz is 30.5uS.  This should be long  
+	   enough for one full cycle of 32.768 khz                  
+	*/
+	osc_clk_count1 = RD_RTC(AO_RTC_ADDR2);     
+			
+	RTC_DBG(RTC_DBG_VAL, "the aml_rtc os clk 1 is %d\n", 
+				(unsigned int)osc_clk_count1);									
+	delay_us( 50 );   
+	osc_clk_count2 = RD_RTC(AO_RTC_ADDR2);    
+	RTC_DBG(RTC_DBG_VAL, "the aml_rtc os clk 2 is %d\n", 
+				(unsigned int)osc_clk_count2);
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- check os clk_2\n");
+	// disable count always  
+	WR_RTC(AO_RTC_ADDR3, RD_RTC(AO_RTC_ADDR3) & ~(1 << 17));    
+
+	if( osc_clk_count1 == osc_clk_count2 ) { 
+		RTC_DBG(RTC_DBG_VAL, "The osc_clk is not running now!"
+	       			" need to invcrease the power!\n");
+		return(-1); 
+	}
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc : check_os_clk\n");
+	   
+	return(0);
+
+}
+#endif
+void rtc_ser_static_write_auto (unsigned long static_reg_data_in)
+{
+    unsigned long data32;
+    
+    // Program MSB 15-8
+    data32  = (static_reg_data_in >> 8) & 0xff;
+    //WRITE_AOBUS_REG(AO_RTC_ADDR4,data32);
+	WR_RTC(AO_RTC_ADDR4, data32);
+
+    // Program LSB 7-0, and start serializing
+    //data32  = READ_AOBUS_REG(AO_RTC_ADDR0);
+    data32  = RD_RTC(AO_RTC_ADDR0);
+    data32 |= 1                           << 17; // auto_serialize_start 
+    data32 &= ~(0xff << 24);
+    data32 |= (static_reg_data_in & 0xff) << 24; // auto_static_reg
+    //WRITE_AOBUS_REG(AO_RTC_ADDR0,data32);
+    WR_RTC(AO_RTC_ADDR0,data32);
+    // Poll auto_serializer_busy bit until it's low (IDLE)
+    //while ((READ_AOBUS_REG(AO_RTC_ADDR0)) & 1<<22) {}
+    while ((RD_RTC(AO_RTC_ADDR0)) & 1<<22) {}
+}
+
+
+static void rtc_reset_s_ready(void)
+{
+	//RTC_RESET_BIT_HIGH(1);
+	delay_us(100);
+	return;
+}
+
+static int rtc_wait_s_ready(void)
+{
+	int i = 40000;
+	int try_cnt = 0;
+	if (get_rtc_status())
+		return i;
+	/*
+	while (i--){
+		if((*(volatile unsigned *)AO_RTC_ADDR1)&s_ready)
+			break;
+		}
+	return i;
+	*/
+	while (!(RD_RTC(AO_RTC_ADDR1)&s_ready)) {
+		i--;
+		if(i == 0){
+			if(try_cnt > RESET_RETRY_TIMES){
+				break;
+			}
+			rtc_reset_s_ready();
+			try_cnt++;
+			i = 40000;
+		}
+	}
+	
+	return i;
+}
+
+
+static int rtc_comm_init(void)
+{
+	RTC_sbus_LOW(0);
+	if(rtc_wait_s_ready()>0){
+		RTC_sen_HIGH(1);
+		return 0;
+	}
+	return -1;
+}
+
+
+static void rtc_send_bit(unsigned val)
+{
+	if (val)
+		RTC_sdi_HIGH(1);
+	else
+		RTC_sdi_LOW(0);
+	rtc_sclk_pulse();
+}
+
+static void rtc_send_addr_data(unsigned type, unsigned val)
+{
+	unsigned cursor = (type? (1<<(RTC_SER_ADDR_BITS-1))
+					 : (1<<(RTC_SER_DATA_BITS-1)));
+		
+	while(cursor) {
+		rtc_send_bit(val&cursor);
+		cursor >>= 1;
+	}
+}
+
+static void rtc_get_data(unsigned *val)
+{
+	int i;
+	RTC_DBG(RTC_DBG_VAL, "rtc-aml -- rtc get data \n");
+	for (i=0; i<RTC_SER_DATA_BITS; i++) {
+		rtc_sclk_pulse();
+		*val <<= 1;
+		*val  |= RTC_sdo_READBIT;
+	}
+}
+
+static void rtc_set_mode(unsigned mode)
+{
+	RTC_sen_LOW(0);
+	if (mode)
+		RTC_sdi_HIGH (1);//WRITE
+	else
+		RTC_sdi_LOW(0);  //READ
+		rtc_sclk_pulse();
+		RTC_sdi_LOW(0);
+}
+
+static void static_register_write(unsigned data);
+static void	 _ser_access_write_locked(unsigned long addr, unsigned long data);
+static void aml_rtc_reset(void)
+{
+    if (get_rtc_status())
+        return;
+	printk("error, the rtc serial communication abnormal,"
+		" reset the rtc!\n");
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	WRITE_AOBUS_REG(AO_RTI_GEN_CNTL_REG0, 
+			READ_AOBUS_REG(AO_RTI_GEN_CNTL_REG0)|1<<21);
+	udelay(5);
+	WRITE_AOBUS_REG(AO_RTI_GEN_CNTL_REG0, 
+			READ_AOBUS_REG(AO_RTI_GEN_CNTL_REG0)&(~(1<<21)));
+	static_register_write(0x180a);
+	_ser_access_write_locked(RTC_GPO_COUNTER_ADDR,0x500000);
+#else
+	WRITE_CBUS_REG(RESET3_REGISTER, 0x1<<3);
+#endif
+}
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+extern int run_arc_program(void);
+extern int stop_ao_cpu(void);
+#endif
+
+static unsigned int _ser_access_read_locked(unsigned long addr)
+{
+	unsigned val = 0;
+	int s_nrdy_cnt = 0;
+	int rst_times = 0;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	int ret = 0;
+#endif
+	if (get_rtc_status())
+		return 0;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	ret = stop_ao_cpu();
+#endif
+	while(rtc_comm_init()<0){
+		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- rtc_common_init fail\n");
+		if(s_nrdy_cnt>RESET_RETRY_TIMES) {
+			s_nrdy_cnt = 0;
+			rst_times++;
+			if (rst_times > 3) {
+				printk("_ser_access_read_locked error\n");
+				goto out;
+			}
+			aml_rtc_reset();
+		}
+		rtc_reset_s_ready( );
+		s_nrdy_cnt++;
+	}
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- ser_access_read_3\n");
+	rtc_send_addr_data(1,addr);
+	rtc_set_mode(0); //Read
+	rtc_get_data(&val);
+out:
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	if (ret >= 0)
+		run_arc_program();
+#endif
+	return val;
+}
+
+static void _ser_access_write_locked(unsigned long addr, unsigned long data)
+{
+	int s_nrdy_cnt = 0;
+	int rst_times = 0;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	int ret = 0;
+#endif
+	if (get_rtc_status())
+		return;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	ret = stop_ao_cpu();
+#endif
+	while(rtc_comm_init()<0){
+		
+		if(s_nrdy_cnt>RESET_RETRY_TIMES) {
+			s_nrdy_cnt = 0;
+			rst_times++;
+			if (rst_times > 3) {
+				printk("_ser_access_write_locked error\n");
+				goto out;
+			}
+			aml_rtc_reset();
+			printk("error: rtc serial communication abnormal!\n");
+			//return -1;
+		}
+		rtc_reset_s_ready( );
+		s_nrdy_cnt++;
+	}
+	rtc_send_addr_data(0,data);
+	rtc_send_addr_data(1,addr);
+	rtc_set_mode(1); //Write
+out:
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+	if (ret >= 0)
+		run_arc_program();
+#endif
+	return;
+}
+
+static unsigned int ser_access_read(unsigned long addr)
+{
+	unsigned val = 0;
+	unsigned long flags;
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc --ser_access_read_1\n");
+	/*if(check_osc_clk() < 0){
+		RTC_DBG(RTC_DBG_VAL, "aml_rtc -- the osc clk does not work\n");
+		return val;
+	}*/
+
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc -- ser_access_read_2\n");
+	spin_lock_irqsave(&com_lock, flags);
+	val = _ser_access_read_locked(addr);
+	spin_unlock_irqrestore(&com_lock, flags);
+
+	return val;
+}
+
+static int ser_access_write(unsigned long addr, unsigned long data)
+{
+	unsigned long flags;
+	
+	spin_lock_irqsave(&com_lock, flags);
+	_ser_access_write_locked(addr, data);
+	spin_unlock_irqrestore(&com_lock, flags);
+	rtc_wait_s_ready();
+
+	return 0;
+}
+
+/***************************************************************************/
+int rtc_reset_gpo(struct device *dev, unsigned level)
+{
+	unsigned data = 0;
+	data |= 1<<20;
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	if(level){
+		data |= 1<<22;         //gpo pin level high
+		}
+#else
+	//reset mode
+	if(!level){
+		data |= 1<<22;         //gpo pin level high
+	}
+#endif	
+	
+	ser_access_write(RTC_GPO_COUNTER_ADDR, data);
+	rtc_wait_s_ready();
+	
+	return 0;
+}
+
+typedef struct alarm_data_s {
+	int level;
+	unsigned alarm_sec;   //in s
+} alarm_data_t;
+
+/*
+ * Return RTC_GPO_COUNTER bit-24 value.
+ */
+int aml_rtc_alarm_status(void)
+{
+	u32 data32 = ser_access_read(RTC_GPO_COUNTER_ADDR);
+	RTC_DBG(RTC_DBG_VAL, "%s() RTC_GPO_COUNTER=%x\n", __func__, data32);
+	return (data32 & (1 << 24));
+}
+
+//set the rtc alarm
+//after alarm_data->alarm_sec, the gpo lvl will be //alarm_data->level 
+int rtc_set_alarm_aml(struct device *dev, alarm_data_t *alarm_data) {
+	unsigned data = 0;
+	//reset the gpo level
+	
+	rtc_reset_gpo(dev, !(alarm_data->level));
+
+	data |= 2 << 20;    //output defined level after time
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	data |= (alarm_data->level & 1) << 22;    //
+#else
+	data |= (!(alarm_data->level & 1)) << 22;    //
+#endif
+	if(alarm_data->alarm_sec >= 1024*1024){
+		return -1;
+	}
+
+	data |= alarm_data->alarm_sec - 1;
+	
+	printk("write alarm data: %u\n", data);
+	ser_access_write(RTC_GPO_COUNTER_ADDR, data);
+	rtc_wait_s_ready();
+	rtc_comm_delay();
+
+	data = ser_access_read(RTC_GPO_COUNTER_ADDR);
+
+	printk("read alarm data: %u\n", data);
+	printk("read alarm count: %u\n", ser_access_read(RTC_COUNTER_ADDR));
+
+	return 0;
+}
+
+/*************************************************************************/
+
+
+// -----------------------------------------------------------------------------
+//                    Function: rtc_ser_static_write_manual
+// Use part of the serial bus: sclk_static, sdi and sen to shift
+// in a 16-bit static data. Manual mode.
+// -----------------------------------------------------------------------------
+//static void rtc_ser_static_write_manual (unsigned int static_reg_data_in)
+//{    
+//	int i;        
+//       RTC_DBG(RTC_DBG_VAL, "rtc_ser_static_write_manual: data=0x%0/x\n",
+//				 static_reg_data_in);   
+//
+//	// Initialize: sen low for 1 clock cycle   
+//	RTC_sen_LOW(0);    
+//	RTC_sclk_static_LOW(0);    
+//	RTC_sclk_static_HIGH(1);    
+//	RTC_sen_HIGH(1);    
+//	RTC_sclk_static_LOW(0);   
+//	  
+//        // Shift in 16-bit known sequence    
+//	 for (i = 15; i >= 0; i --) {    
+//	 	
+//	     if ((RTC_SER_REG_DATA_NOTIFIER >> i) & 0x1) {            
+//		   RTC_sdi_HIGH(1);        
+//	     }
+//		 else {            
+//		   RTC_sdi_LOW(0);        
+//	     }     
+//			
+//	    RTC_sclk_static_HIGH(1);        
+//	    RTC_sclk_static_LOW(0);   
+//	 }    
+//	 
+//	  // 1 clock cycle turn around    
+//	  RTC_sdi_LOW(0);    
+//	  RTC_sclk_static_HIGH(1);    
+//	  RTC_sclk_static_LOW(0);  
+//	  
+//	  // Shift in 16-bit static register data    
+//	  for (i = 15; i >= 0; i --) {       
+//	  	if ((static_reg_data_in >> i) & 0x1) {            
+//		    RTC_sdi_HIGH(1);        
+//		} 
+//		else {            
+//		    RTC_sdi_LOW(0);        
+//		}        
+//		RTC_sclk_static_HIGH(1);        
+//		RTC_sclk_static_LOW(0);    
+//	   }    
+//	  
+//	  // One more clock cycle to complete write    
+//	  RTC_sen_LOW(0);    
+//	  RTC_sdi_LOW(0);    
+//	  RTC_sclk_static_HIGH(1);    
+//	  RTC_sclk_static_LOW(0);
+//} 
+
+
+static void static_register_write(unsigned data)
+{
+	rtc_ser_static_write_auto(data);	
+}
+
+static int aml_rtc_read_time(struct device *dev, struct rtc_time *tm)
+{
+	unsigned int time_t;
+	
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc: read rtc time\n");
+	time_t = ser_access_read(RTC_COUNTER_ADDR);
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc: have read the rtc time,"
+			" time is %d\n", time_t);
+	if ((int)time_t < 0) {
+		RTC_DBG(RTC_DBG_VAL, "aml_rtc: time(%d) < 0,"
+				" reset to 0", time_t);
+		time_t = 0;
+	}   
+	rtc_time_to_tm(time_t, tm);
+	
+	return 0;
+}
+
+static int aml_rtc_write_time(struct device *dev, struct rtc_time *tm)
+{
+      unsigned long time_t;
+
+      rtc_tm_to_time(tm, &time_t);
+     
+      RTC_DBG(RTC_DBG_VAL, "aml_rtc : write the rtc time, "
+      			"time is %ld\n", time_t);
+      ser_access_write(RTC_COUNTER_ADDR, time_t);
+      RTC_DBG(RTC_DBG_VAL, "aml_rtc : the time has been written\n");
+
+      return 0;
+}
+
+static int aml_rtc_set_alarm(struct device *dev, struct rtc_wkalrm *alarm)
+{
+	alarm_data_t alarm_data;
+	unsigned long alarm_secs, cur_secs;
+	struct rtc_time cur_time;
+	int ret;
+	struct aml_rtc_priv *priv;
+
+	priv = dev_get_drvdata(dev);
+	//rtc_tm_to_time(&alarm->time, &secs);
+	
+	if (alarm->enabled) {
+		alarm_data.level = 0;
+		ret = rtc_tm_to_time(&alarm->time, &alarm_secs);
+		if (ret)
+			return ret;
+		aml_rtc_read_time(dev, &cur_time);
+		ret = rtc_tm_to_time(&cur_time, &cur_secs);
+		if(alarm_secs >= cur_secs) {
+			/*3 seconds later then we real wanted, 
+			  we do not need the alarm very acurate.*/
+			alarm_data.alarm_sec = alarm_secs - cur_secs + 3; 
+		} else
+			alarm_data.alarm_sec =  0;
+
+		rtc_set_alarm_aml(dev, &alarm_data);
+	} else {
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else	
+    	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif    	
+		queue_work(priv->rtc_work_queue, &priv->work);
+	}
+	return 0;
+}
+
+#define AUTO_RESUME_INTERVAL 8
+static int aml_rtc_suspend(struct platform_device *pdev, pm_message_t state)
+{
+#ifdef CONFIG_MESON_SUSPEND_TEST
+	alarm_data_t alarm_data;
+	static int suspend_time = 0;
+	alarm_data.alarm_sec = AUTO_RESUME_INTERVAL;
+        alarm_data.level = 0;
+	rtc_set_alarm_aml(&pdev->dev, &alarm_data);
+	printk("suspend %d times, system will up %ds later!\n", 
+			++suspend_time, alarm_data.alarm_sec);
+#endif /* CONFIG_MESON_SUSPEND_TEST */
+	return 0;
+}
+int aml_rtc_resume(struct platform_device *pdev)
+{	
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else		
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif						
+	
+	printk("resume reset gpo !\n");
+	return 0;
+}
+
+static char *rtc_reg[8]={
+	"RTC_COUNTER    ",
+	"RTC_GPO_COUNTER",
+	"RTC_SEC_ADJUST ",
+	"UNUSED         ",
+	"RTC_REGMEM_0   ",
+	"RTC_REGMEM_1   ",
+	"RTC_REGMEM_2   ",
+	"RTC_REGMEM_3   "
+};
+						
+static ssize_t show_rtc_reg(struct class *class, 
+			struct class_attribute *attr,	char *buf)
+{
+	int i;
+	
+	printk("enter function: %s \n",__FUNCTION__);
+		
+	for (i = 0; i < 8; i++) {
+		printk(" %20s : 0x%x \n",rtc_reg[i],ser_access_read(i));
+	}
+	
+	return 0;
+}
+
+static const struct rtc_class_ops aml_rtc_ops ={
+	.read_time = aml_rtc_read_time,
+	.set_time = aml_rtc_write_time,
+	.set_alarm = aml_rtc_set_alarm,
+};
+
+static struct class_attribute rtc_class_attrs[] = {
+	__ATTR(rtc_reg_log, S_IRUGO | S_IWUSR, show_rtc_reg, NULL),
+	__ATTR_NULL
+};
+
+static struct class aml_rtc_class = {
+	.name = "aml_rtc",
+	.class_attrs = rtc_class_attrs,
+};
+
+
+#ifdef CONFIG_SECURITYKEY
+extern int get_aml_key_kernel(const char* key_name, unsigned char* data, int ascii_flag);
+extern int extenal_api_key_set_version(char *devvesion);
+#endif
+
+static int aml_rtc_probe(struct platform_device *pdev)
+{
+	struct aml_rtc_priv *priv;
+	struct device_node* aml_rtc_node = pdev->dev.of_node;
+	int ret;
+	int sec_adjust = 0;
+
+#ifdef CONFIG_SECURITYKEY
+	static char keyexamples[4096];
+#endif
+#ifdef CONFIG_SECURITYKEY
+	ret = extenal_api_key_set_version("auto3");
+	if(ret >=0){
+		ret = get_aml_key_kernel("keyexample", keyexamples, 1);
+		if(ret >= 0){
+			printk("key name:keyexample, key data:%s\n",keyexamples);
+		}
+		else{
+			printk("get keyexample fail, %s:%d\n",__func__,__LINE__);
+		}
+	}
+#endif
+
+	priv = (struct aml_rtc_priv *)kzalloc(sizeof(*priv), GFP_KERNEL);
+
+	if(!priv)
+		return -ENOMEM;
+
+	INIT_WORK(&priv->work, reset_gpo_work);
+	platform_set_drvdata(pdev, priv);
+
+	priv->rtc_work_queue = create_singlethread_workqueue("rtc");
+	if (priv->rtc_work_queue == NULL) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	
+	/* platform setup code should have handled this; sigh */
+	if (!device_can_wakeup(&pdev->dev))
+		device_init_wakeup(&pdev->dev, 1);
+
+	priv->rtc = rtc_device_register("aml_rtc", &pdev->dev, &
+						aml_rtc_ops, THIS_MODULE);
+
+	if(IS_ERR(priv->rtc)){
+		ret = PTR_ERR(priv->rtc);
+		goto out;
+	}
+
+	//ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+	//static_register_write(0x0004);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
+	ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else
+	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif	
+	rtc_wait_s_ready();
+	
+	ret = of_property_read_u32(aml_rtc_node, "sec_adjust", &sec_adjust);
+	if (!ret) {
+		ser_access_write(RTC_SEC_ADJUST_ADDR, 1<<23 | 10<<19 | 1735 );
+		rtc_wait_s_ready();
+	} 
+
+	//check_osc_clk();
+	//ser_access_write(RTC_COUNTER_ADDR, 0);
+	ret = class_register(&aml_rtc_class);
+	if(ret){
+		printk(" class register nand_class fail!\n");
+	}	
+	
+	return 0;
+
+out:
+	if(priv->rtc_work_queue)
+		destroy_workqueue(priv->rtc_work_queue);
+	kfree(priv);
+	return ret;
+}
+
+static int get_gpo_flag(void)
+{
+	u32 data32 = 0;
+	int ret = 0;
+
+	data32 = ser_access_read(RTC_GPO_COUNTER_ADDR);
+	
+	RTC_DBG(RTC_DBG_VAL, "%s() RTC_GPO_COUNTER=%x\n", __func__, data32);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
+	ret = !(data32 & (1 << 24));
+#else
+    ret = !!(data32 & (1 << 24));
+#endif
+	
+	return ret;
+}
+
+unsigned int aml_read_rtc_mem_reg(unsigned char reg_id)
+{
+	unsigned char reg_array[] = {
+		RTC_REGMEM_ADDR_0,
+		RTC_REGMEM_ADDR_1,
+		RTC_REGMEM_ADDR_2,
+		RTC_REGMEM_ADDR_3,
+	};
+	if (reg_id > 4)
+		return 0;
+	return  ser_access_read(reg_array[reg_id]);
+}
+EXPORT_SYMBOL(aml_read_rtc_mem_reg);
+
+int aml_write_rtc_mem_reg(unsigned char reg_id, unsigned int data)
+{
+	unsigned char reg_array[] = {
+		RTC_REGMEM_ADDR_0,
+		RTC_REGMEM_ADDR_1,
+		RTC_REGMEM_ADDR_2,
+		RTC_REGMEM_ADDR_3,
+	};
+	if (reg_id > 4)
+		return 0;
+	return  ser_access_write(reg_array[reg_id], data);
+}
+EXPORT_SYMBOL(aml_write_rtc_mem_reg);
+
+unsigned int aml_get_rtc_counter(void)
+{
+    unsigned int val;
+    val = ser_access_read(RTC_COUNTER_ADDR);
+    return val;
+}
+EXPORT_SYMBOL(aml_get_rtc_counter);
+
+static void reset_gpo_work(struct work_struct *work)
+{
+	int count = 5;
+	
+	while (get_gpo_flag()) {
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else		
+		ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif						
+		count--;
+		if(count <= 0) {
+			printk("error: can not reset gpo !\n");
+			//count = 5;
+			return;
+			//panic("gpo can not be reset");
+		}
+	}
+	
+	printk("reset gpo !\n");
+
+}
+#if 0
+static int power_down_gpo(unsigned long data)
+{
+	struct aml_rtc_priv *priv = (struct aml_rtc_priv *)data;
+	queue_work(priv->rtc_work_queue, &priv->work);
+	
+	return 0;
+}
+#endif
+static void aml_rtc_shutdown(struct platform_device *pdev)
+{
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6	
+	ser_access_write(RTC_GPO_COUNTER_ADDR,0x500000);
+#else	
+	ser_access_write(RTC_GPO_COUNTER_ADDR,0x100000);
+#endif    
+//    return 0;
+}
+
+static int aml_rtc_remove(struct platform_device *dev)
+{
+	struct aml_rtc_priv *priv = platform_get_drvdata(dev);
+	rtc_device_unregister(priv->rtc);
+	if (priv->rtc_work_queue)
+		destroy_workqueue(priv->rtc_work_queue);
+	del_timer(&priv->timer);
+	kfree(priv);
+	return 0;
+}
+
+//#ifdef CONFIG_OF
+static const struct of_device_id meson6_rtc_dt_match[]={
+	{ .compatible = "amlogic,aml_rtc"},
+	{},
+};
+/*#else
+#define meson6_rtc_dt_match NULL
+#endif*/
+
+struct platform_driver aml_rtc_driver = {
+	.driver = {
+		.name = "aml_rtc",
+		.owner = THIS_MODULE,
+		.of_match_table=meson6_rtc_dt_match,
+	},
+	.probe = aml_rtc_probe,
+//	.remove = __devexit_p(aml_rtc_remove),
+	.remove = (aml_rtc_remove),
+	.suspend = aml_rtc_suspend,
+	.resume=aml_rtc_resume,
+	.shutdown = aml_rtc_shutdown,
+};
+
+static int  __init aml_rtc_init(void)
+{
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	static_register_write(0x180a);
+#else	
+	static_register_write(0x3c0a);
+#endif
+	RTC_DBG(RTC_DBG_VAL, "aml_rtc --aml_rtc_init\n");
+	return platform_driver_register(&aml_rtc_driver);
+}
+
+static void __init aml_rtc_exit(void)
+{
+       return platform_driver_unregister(&aml_rtc_driver);
+}
+
+module_init(aml_rtc_init);
+module_exit(aml_rtc_exit);
+
+MODULE_DESCRIPTION("Amlogic internal rtc driver");
+MODULE_LICENSE("GPL");
